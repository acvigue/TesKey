// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vcsec.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum VCSEC_Activity_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case activityNone // = 0
  case activityStationary // = 1
  case activityMotion // = 2
  case activitySignificantMotion // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .activityNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .activityNone
    case 1: self = .activityStationary
    case 2: self = .activityMotion
    case 3: self = .activitySignificantMotion
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .activityNone: return 0
    case .activityStationary: return 1
    case .activityMotion: return 2
    case .activitySignificantMotion: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_Activity_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_Activity_E] = [
    .activityNone,
    .activityStationary,
    .activityMotion,
    .activitySignificantMotion,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_AppDeviceInfoRequest_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case appDeviceInfoRequestNone // = 0
  case appDeviceInfoRequestGetModelNumber // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .appDeviceInfoRequestNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .appDeviceInfoRequestNone
    case 1: self = .appDeviceInfoRequestGetModelNumber
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .appDeviceInfoRequestNone: return 0
    case .appDeviceInfoRequestGetModelNumber: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_AppDeviceInfoRequest_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_AppDeviceInfoRequest_E] = [
    .appDeviceInfoRequestNone,
    .appDeviceInfoRequestGetModelNumber,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_AppOperatingSystem: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case android // = 1
  case ios // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .android
    case 2: self = .ios
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .android: return 1
    case .ios: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_AppOperatingSystem: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_AppOperatingSystem] = [
    .unknown,
    .android,
    .ios,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_AuthenticationLevel_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case authenticationLevelNone // = 0
  case authenticationLevelUnlock // = 1
  case authenticationLevelDrive // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .authenticationLevelNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .authenticationLevelNone
    case 1: self = .authenticationLevelUnlock
    case 2: self = .authenticationLevelDrive
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .authenticationLevelNone: return 0
    case .authenticationLevelUnlock: return 1
    case .authenticationLevelDrive: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_AuthenticationLevel_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_AuthenticationLevel_E] = [
    .authenticationLevelNone,
    .authenticationLevelUnlock,
    .authenticationLevelDrive,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_AuthenticationReason_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case authenticationreasonNotDocumented // = 0
  case authenticationreasonIdentification // = 1
  case authenticationreasonPowerOnVehicleRequest // = 2
  case authenticationreasonGtwRequest // = 3
  case authenticationreasonUiUnlockPassiveAuth // = 4
  case authenticationreasonPassiveUnlockExteriorHandlePull // = 5
  case authenticationreasonPassiveUnlockInteriorHandlePull // = 6
  case authenticationreasonPassiveUnlockAutopresentDoor // = 7
  case nteredHigherAuthZone // = 8
  case authenticationreasonWalkUpUnlock // = 9
  case authenticationreasonImmobilizer // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .authenticationreasonNotDocumented
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .authenticationreasonNotDocumented
    case 1: self = .authenticationreasonIdentification
    case 2: self = .authenticationreasonPowerOnVehicleRequest
    case 3: self = .authenticationreasonGtwRequest
    case 4: self = .authenticationreasonUiUnlockPassiveAuth
    case 5: self = .authenticationreasonPassiveUnlockExteriorHandlePull
    case 6: self = .authenticationreasonPassiveUnlockInteriorHandlePull
    case 7: self = .authenticationreasonPassiveUnlockAutopresentDoor
    case 8: self = .nteredHigherAuthZone
    case 9: self = .authenticationreasonWalkUpUnlock
    case 10: self = .authenticationreasonImmobilizer
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .authenticationreasonNotDocumented: return 0
    case .authenticationreasonIdentification: return 1
    case .authenticationreasonPowerOnVehicleRequest: return 2
    case .authenticationreasonGtwRequest: return 3
    case .authenticationreasonUiUnlockPassiveAuth: return 4
    case .authenticationreasonPassiveUnlockExteriorHandlePull: return 5
    case .authenticationreasonPassiveUnlockInteriorHandlePull: return 6
    case .authenticationreasonPassiveUnlockAutopresentDoor: return 7
    case .nteredHigherAuthZone: return 8
    case .authenticationreasonWalkUpUnlock: return 9
    case .authenticationreasonImmobilizer: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_AuthenticationReason_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_AuthenticationReason_E] = [
    .authenticationreasonNotDocumented,
    .authenticationreasonIdentification,
    .authenticationreasonPowerOnVehicleRequest,
    .authenticationreasonGtwRequest,
    .authenticationreasonUiUnlockPassiveAuth,
    .authenticationreasonPassiveUnlockExteriorHandlePull,
    .authenticationreasonPassiveUnlockInteriorHandlePull,
    .authenticationreasonPassiveUnlockAutopresentDoor,
    .nteredHigherAuthZone,
    .authenticationreasonWalkUpUnlock,
    .authenticationreasonImmobilizer,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_AuthenticationRejection_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case authenticationrejectionNone // = 0
  case authenticationrejectionDeviceStationary // = 1
  case authenticationrejectionPassiveDisabled // = 2
  case authenticationrejectionNoToken // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .authenticationrejectionNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .authenticationrejectionNone
    case 1: self = .authenticationrejectionDeviceStationary
    case 2: self = .authenticationrejectionPassiveDisabled
    case 3: self = .authenticationrejectionNoToken
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .authenticationrejectionNone: return 0
    case .authenticationrejectionDeviceStationary: return 1
    case .authenticationrejectionPassiveDisabled: return 2
    case .authenticationrejectionNoToken: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_AuthenticationRejection_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_AuthenticationRejection_E] = [
    .authenticationrejectionNone,
    .authenticationrejectionDeviceStationary,
    .authenticationrejectionPassiveDisabled,
    .authenticationrejectionNoToken,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_BLEAdditionalTRIMApplied_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case bleAdditionalTrimAppliedNone // = 0
  case bleAdditionalTrimAppliedApplied // = 1
  case bleAdditionalTrimAppliedNotApplied // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .bleAdditionalTrimAppliedNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bleAdditionalTrimAppliedNone
    case 1: self = .bleAdditionalTrimAppliedApplied
    case 2: self = .bleAdditionalTrimAppliedNotApplied
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .bleAdditionalTrimAppliedNone: return 0
    case .bleAdditionalTrimAppliedApplied: return 1
    case .bleAdditionalTrimAppliedNotApplied: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_BLEAdditionalTRIMApplied_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_BLEAdditionalTRIMApplied_E] = [
    .bleAdditionalTrimAppliedNone,
    .bleAdditionalTrimAppliedApplied,
    .bleAdditionalTrimAppliedNotApplied,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_BLEConfigCommandType_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case bleConfigCommandTypeNone // = 0
  case bleConfigCommandTypeRead // = 1
  case bleConfigCommandTypeWrite // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .bleConfigCommandTypeNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bleConfigCommandTypeNone
    case 1: self = .bleConfigCommandTypeRead
    case 2: self = .bleConfigCommandTypeWrite
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .bleConfigCommandTypeNone: return 0
    case .bleConfigCommandTypeRead: return 1
    case .bleConfigCommandTypeWrite: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_BLEConfigCommandType_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_BLEConfigCommandType_E] = [
    .bleConfigCommandTypeNone,
    .bleConfigCommandTypeRead,
    .bleConfigCommandTypeWrite,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_BLEPresence: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case notPresent // = 0
  case present // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .notPresent
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notPresent
    case 1: self = .present
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .notPresent: return 0
    case .present: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_BLEPresence: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_BLEPresence] = [
    .notPresent,
    .present,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_ClosureMoveType_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case closureMoveTypeNone // = 0
  case closureMoveTypeMove // = 1
  case closureMoveTypeStop // = 2
  case closureMoveTypeOpen // = 3
  case closureMoveTypeClose // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .closureMoveTypeNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .closureMoveTypeNone
    case 1: self = .closureMoveTypeMove
    case 2: self = .closureMoveTypeStop
    case 3: self = .closureMoveTypeOpen
    case 4: self = .closureMoveTypeClose
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .closureMoveTypeNone: return 0
    case .closureMoveTypeMove: return 1
    case .closureMoveTypeStop: return 2
    case .closureMoveTypeOpen: return 3
    case .closureMoveTypeClose: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_ClosureMoveType_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_ClosureMoveType_E] = [
    .closureMoveTypeNone,
    .closureMoveTypeMove,
    .closureMoveTypeStop,
    .closureMoveTypeOpen,
    .closureMoveTypeClose,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_ClosureState_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case closurestateClosed // = 0
  case closurestateOpen // = 1
  case closurestateAjar // = 2
  case closurestateUnknown // = 3
  case closurestateFailedUnlatch // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .closurestateClosed
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .closurestateClosed
    case 1: self = .closurestateOpen
    case 2: self = .closurestateAjar
    case 3: self = .closurestateUnknown
    case 4: self = .closurestateFailedUnlatch
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .closurestateClosed: return 0
    case .closurestateOpen: return 1
    case .closurestateAjar: return 2
    case .closurestateUnknown: return 3
    case .closurestateFailedUnlatch: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_ClosureState_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_ClosureState_E] = [
    .closurestateClosed,
    .closurestateOpen,
    .closurestateAjar,
    .closurestateUnknown,
    .closurestateFailedUnlatch,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_Device_Motion_Confidence: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case low // = 1
  case medium // = 2
  case high // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .low
    case 2: self = .medium
    case 3: self = .high
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .low: return 1
    case .medium: return 2
    case .high: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_Device_Motion_Confidence: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_Device_Motion_Confidence] = [
    .unknown,
    .low,
    .medium,
    .high,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_Device_Motion_State: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case deviceMotionUnknown // = 0
  case deviceMotionStationary // = 1
  case deviceMotionWalking // = 2
  case deviceMotionRunning // = 3
  case deviceMotionAutomotive // = 4
  case deviceMotionCycling // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .deviceMotionUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .deviceMotionUnknown
    case 1: self = .deviceMotionStationary
    case 2: self = .deviceMotionWalking
    case 3: self = .deviceMotionRunning
    case 4: self = .deviceMotionAutomotive
    case 5: self = .deviceMotionCycling
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .deviceMotionUnknown: return 0
    case .deviceMotionStationary: return 1
    case .deviceMotionWalking: return 2
    case .deviceMotionRunning: return 3
    case .deviceMotionAutomotive: return 4
    case .deviceMotionCycling: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_Device_Motion_State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_Device_Motion_State] = [
    .deviceMotionUnknown,
    .deviceMotionStationary,
    .deviceMotionWalking,
    .deviceMotionRunning,
    .deviceMotionAutomotive,
    .deviceMotionCycling,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_GenealogyRequest_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case genealogyrequestNone // = 0
  case genealogyrequestRead // = 1
  case genealogyrequestKeyfobinfoRead // = 2
  case genealogyrequestTpwheelunitinfoRead // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .genealogyrequestNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .genealogyrequestNone
    case 1: self = .genealogyrequestRead
    case 2: self = .genealogyrequestKeyfobinfoRead
    case 3: self = .genealogyrequestTpwheelunitinfoRead
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .genealogyrequestNone: return 0
    case .genealogyrequestRead: return 1
    case .genealogyrequestKeyfobinfoRead: return 2
    case .genealogyrequestTpwheelunitinfoRead: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_GenealogyRequest_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_GenealogyRequest_E] = [
    .genealogyrequestNone,
    .genealogyrequestRead,
    .genealogyrequestKeyfobinfoRead,
    .genealogyrequestTpwheelunitinfoRead,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_GenealogyStatus_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case genealogyStatusNone // = 0
  case genealogyStatusNotWritten // = 1
  case genealogyStatusWriteSuccess // = 2
  case genealogyStatusWriteFailure // = 3
  case genealogyStatusReadSuccess // = 4
  case genealogyStatusReadFailure // = 5
  case genealogyStatusCrcFailure // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .genealogyStatusNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .genealogyStatusNone
    case 1: self = .genealogyStatusNotWritten
    case 2: self = .genealogyStatusWriteSuccess
    case 3: self = .genealogyStatusWriteFailure
    case 4: self = .genealogyStatusReadSuccess
    case 5: self = .genealogyStatusReadFailure
    case 6: self = .genealogyStatusCrcFailure
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .genealogyStatusNone: return 0
    case .genealogyStatusNotWritten: return 1
    case .genealogyStatusWriteSuccess: return 2
    case .genealogyStatusWriteFailure: return 3
    case .genealogyStatusReadSuccess: return 4
    case .genealogyStatusReadFailure: return 5
    case .genealogyStatusCrcFailure: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_GenealogyStatus_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_GenealogyStatus_E] = [
    .genealogyStatusNone,
    .genealogyStatusNotWritten,
    .genealogyStatusWriteSuccess,
    .genealogyStatusWriteFailure,
    .genealogyStatusReadSuccess,
    .genealogyStatusReadFailure,
    .genealogyStatusCrcFailure,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_GenericError_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case genericerrorNone // = 0
  case genericerrorUnknown // = 1
  case genericerrorClosuresOpen // = 2
  case genericerrorAlreadyOn // = 3
  case genericerrorDisabledForUserCommand // = 4
  case genericerrorVehicleNotInPark // = 5
  case genericerrorUnauthorized // = 6
  case genericerrorNotAllowedOverTransport // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .genericerrorNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .genericerrorNone
    case 1: self = .genericerrorUnknown
    case 2: self = .genericerrorClosuresOpen
    case 3: self = .genericerrorAlreadyOn
    case 4: self = .genericerrorDisabledForUserCommand
    case 5: self = .genericerrorVehicleNotInPark
    case 6: self = .genericerrorUnauthorized
    case 7: self = .genericerrorNotAllowedOverTransport
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .genericerrorNone: return 0
    case .genericerrorUnknown: return 1
    case .genericerrorClosuresOpen: return 2
    case .genericerrorAlreadyOn: return 3
    case .genericerrorDisabledForUserCommand: return 4
    case .genericerrorVehicleNotInPark: return 5
    case .genericerrorUnauthorized: return 6
    case .genericerrorNotAllowedOverTransport: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_GenericError_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_GenericError_E] = [
    .genericerrorNone,
    .genericerrorUnknown,
    .genericerrorClosuresOpen,
    .genericerrorAlreadyOn,
    .genericerrorDisabledForUserCommand,
    .genericerrorVehicleNotInPark,
    .genericerrorUnauthorized,
    .genericerrorNotAllowedOverTransport,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_GetReaderKeyCommand: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case startLooking // = 1
  case stopLooking // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .startLooking
    case 2: self = .stopLooking
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .startLooking: return 1
    case .stopLooking: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_GetReaderKeyCommand: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_GetReaderKeyCommand] = [
    .unknown,
    .startLooking,
    .stopLooking,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_HandlePulled_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case handlePulledFrontDriverDoor // = 0
  case handlePulledFrontPassengerDoor // = 1
  case handlePulledRearDriverDoor // = 2
  case handlePulledRearPassengerDoor // = 3
  case handlePulledTrunk // = 4
  case handlePulledChargePort // = 5
  case handlePulledFrontDriverAutoPresentDoor // = 6
  case handlePulledFrontPassengerAutoPresentDoor // = 7
  case handlePulledOther // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .handlePulledFrontDriverDoor
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .handlePulledFrontDriverDoor
    case 1: self = .handlePulledFrontPassengerDoor
    case 2: self = .handlePulledRearDriverDoor
    case 3: self = .handlePulledRearPassengerDoor
    case 4: self = .handlePulledTrunk
    case 5: self = .handlePulledChargePort
    case 6: self = .handlePulledFrontDriverAutoPresentDoor
    case 7: self = .handlePulledFrontPassengerAutoPresentDoor
    case 8: self = .handlePulledOther
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .handlePulledFrontDriverDoor: return 0
    case .handlePulledFrontPassengerDoor: return 1
    case .handlePulledRearDriverDoor: return 2
    case .handlePulledRearPassengerDoor: return 3
    case .handlePulledTrunk: return 4
    case .handlePulledChargePort: return 5
    case .handlePulledFrontDriverAutoPresentDoor: return 6
    case .handlePulledFrontPassengerAutoPresentDoor: return 7
    case .handlePulledOther: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_HandlePulled_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_HandlePulled_E] = [
    .handlePulledFrontDriverDoor,
    .handlePulledFrontPassengerDoor,
    .handlePulledRearDriverDoor,
    .handlePulledRearPassengerDoor,
    .handlePulledTrunk,
    .handlePulledChargePort,
    .handlePulledFrontDriverAutoPresentDoor,
    .handlePulledFrontPassengerAutoPresentDoor,
    .handlePulledOther,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_IMURequest_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case imuRequestNone // = 0
  case imuRequestGetSleepState // = 1
  case nableContinuousActivityUpdate // = 2
  case imuRequestDisableContinuousActivityUpdate // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .imuRequestNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .imuRequestNone
    case 1: self = .imuRequestGetSleepState
    case 2: self = .nableContinuousActivityUpdate
    case 3: self = .imuRequestDisableContinuousActivityUpdate
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .imuRequestNone: return 0
    case .imuRequestGetSleepState: return 1
    case .nableContinuousActivityUpdate: return 2
    case .imuRequestDisableContinuousActivityUpdate: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_IMURequest_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_IMURequest_E] = [
    .imuRequestNone,
    .imuRequestGetSleepState,
    .nableContinuousActivityUpdate,
    .imuRequestDisableContinuousActivityUpdate,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_IMUState_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case imuStateNotConfigured // = 0
  case imuStateActivity // = 1
  case imuStateInactivity // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .imuStateNotConfigured
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .imuStateNotConfigured
    case 1: self = .imuStateActivity
    case 2: self = .imuStateInactivity
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .imuStateNotConfigured: return 0
    case .imuStateActivity: return 1
    case .imuStateInactivity: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_IMUState_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_IMUState_E] = [
    .imuStateNotConfigured,
    .imuStateActivity,
    .imuStateInactivity,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_InformationRequestType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case getStatus // = 0
  case getToken // = 1
  case getCounter // = 2
  case getEphemeralPublicKey // = 3
  case getSessionData // = 4
  case getWhitelistInfo // = 5
  case getWhitelistEntryInfo // = 6
  case getVehicleInfo // = 7
  case getKeystatusInfo // = 8
  case getActiveKey // = 9
  case getCapabilities // = 16
  case UNRECOGNIZED(Int)

  init() {
    self = .getStatus
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .getStatus
    case 1: self = .getToken
    case 2: self = .getCounter
    case 3: self = .getEphemeralPublicKey
    case 4: self = .getSessionData
    case 5: self = .getWhitelistInfo
    case 6: self = .getWhitelistEntryInfo
    case 7: self = .getVehicleInfo
    case 8: self = .getKeystatusInfo
    case 9: self = .getActiveKey
    case 16: self = .getCapabilities
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .getStatus: return 0
    case .getToken: return 1
    case .getCounter: return 2
    case .getEphemeralPublicKey: return 3
    case .getSessionData: return 4
    case .getWhitelistInfo: return 5
    case .getWhitelistEntryInfo: return 6
    case .getVehicleInfo: return 7
    case .getKeystatusInfo: return 8
    case .getActiveKey: return 9
    case .getCapabilities: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_InformationRequestType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_InformationRequestType] = [
    .getStatus,
    .getToken,
    .getCounter,
    .getEphemeralPublicKey,
    .getSessionData,
    .getWhitelistInfo,
    .getWhitelistEntryInfo,
    .getVehicleInfo,
    .getKeystatusInfo,
    .getActiveKey,
    .getCapabilities,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_KeyFormFactor: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case nfcCard // = 1
  case keyFormFactor3ButtonBleCarKeyfob // = 2
  case bleDevice // = 3
  case nfcDevice // = 4
  case bleAndNfcDevice // = 5
  case iosDevice // = 6
  case androidDevice // = 7
  case keyFormFactor3ButtonBleCarKeyfobP60 // = 8
  case cloudKey // = 9
  case keyFormFactor3ButtonGen2CarKeyfobP60 // = 10
  case keyFormFactor5ButtonGen2CarKeyfobP60 // = 11
  case keyFormFactor3ButtonGen2CarKeyfobP60V2 // = 12
  case keyFormFactor3ButtonGen2CarKeyfobP60V3 // = 13
  case nfcCardP71 // = 14
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .nfcCard
    case 2: self = .keyFormFactor3ButtonBleCarKeyfob
    case 3: self = .bleDevice
    case 4: self = .nfcDevice
    case 5: self = .bleAndNfcDevice
    case 6: self = .iosDevice
    case 7: self = .androidDevice
    case 8: self = .keyFormFactor3ButtonBleCarKeyfobP60
    case 9: self = .cloudKey
    case 10: self = .keyFormFactor3ButtonGen2CarKeyfobP60
    case 11: self = .keyFormFactor5ButtonGen2CarKeyfobP60
    case 12: self = .keyFormFactor3ButtonGen2CarKeyfobP60V2
    case 13: self = .keyFormFactor3ButtonGen2CarKeyfobP60V3
    case 14: self = .nfcCardP71
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .nfcCard: return 1
    case .keyFormFactor3ButtonBleCarKeyfob: return 2
    case .bleDevice: return 3
    case .nfcDevice: return 4
    case .bleAndNfcDevice: return 5
    case .iosDevice: return 6
    case .androidDevice: return 7
    case .keyFormFactor3ButtonBleCarKeyfobP60: return 8
    case .cloudKey: return 9
    case .keyFormFactor3ButtonGen2CarKeyfobP60: return 10
    case .keyFormFactor5ButtonGen2CarKeyfobP60: return 11
    case .keyFormFactor3ButtonGen2CarKeyfobP60V2: return 12
    case .keyFormFactor3ButtonGen2CarKeyfobP60V3: return 13
    case .nfcCardP71: return 14
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_KeyFormFactor: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_KeyFormFactor] = [
    .unknown,
    .nfcCard,
    .keyFormFactor3ButtonBleCarKeyfob,
    .bleDevice,
    .nfcDevice,
    .bleAndNfcDevice,
    .iosDevice,
    .androidDevice,
    .keyFormFactor3ButtonBleCarKeyfobP60,
    .cloudKey,
    .keyFormFactor3ButtonGen2CarKeyfobP60,
    .keyFormFactor5ButtonGen2CarKeyfobP60,
    .keyFormFactor3ButtonGen2CarKeyfobP60V2,
    .keyFormFactor3ButtonGen2CarKeyfobP60V3,
    .nfcCardP71,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_LRDetectionResult_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case rrorMaxcnt // = 0
  case rrorNegperiod // = 1
  case rrorLongperiod // = 2
  case lrdetectionresultLeft // = 3
  case lrdetectionresultRight // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .rrorMaxcnt
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rrorMaxcnt
    case 1: self = .rrorNegperiod
    case 2: self = .rrorLongperiod
    case 3: self = .lrdetectionresultLeft
    case 4: self = .lrdetectionresultRight
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .rrorMaxcnt: return 0
    case .rrorNegperiod: return 1
    case .rrorLongperiod: return 2
    case .lrdetectionresultLeft: return 3
    case .lrdetectionresultRight: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_LRDetectionResult_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_LRDetectionResult_E] = [
    .rrorMaxcnt,
    .rrorNegperiod,
    .rrorLongperiod,
    .lrdetectionresultLeft,
    .lrdetectionresultRight,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_MIError_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case errorUnknown // = 0
  case errorSessionLimitExceeded // = 1
  case errorInvalidConfiguration // = 2
  case errorResourceUsageTimeout // = 3
  case errorSessionFailed // = 4
  case errorUnsupportedPlatform // = 5
  case errorUserDidNotAllow // = 6
  case errorBlePeerUnavailable // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .errorUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .errorUnknown
    case 1: self = .errorSessionLimitExceeded
    case 2: self = .errorInvalidConfiguration
    case 3: self = .errorResourceUsageTimeout
    case 4: self = .errorSessionFailed
    case 5: self = .errorUnsupportedPlatform
    case 6: self = .errorUserDidNotAllow
    case 7: self = .errorBlePeerUnavailable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .errorUnknown: return 0
    case .errorSessionLimitExceeded: return 1
    case .errorInvalidConfiguration: return 2
    case .errorResourceUsageTimeout: return 3
    case .errorSessionFailed: return 4
    case .errorUnsupportedPlatform: return 5
    case .errorUserDidNotAllow: return 6
    case .errorBlePeerUnavailable: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_MIError_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_MIError_E] = [
    .errorUnknown,
    .errorSessionLimitExceeded,
    .errorInvalidConfiguration,
    .errorResourceUsageTimeout,
    .errorSessionFailed,
    .errorUnsupportedPlatform,
    .errorUserDidNotAllow,
    .errorBlePeerUnavailable,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_MLXWakePeriod_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case mlxwakeperiod2Ms // = 0
  case mlxwakeperiod3Ms // = 1
  case mlxwakeperiod5Ms // = 2
  case mlxwakeperiod15Ms // = 3
  case mlxwakeperiod30Ms // = 4
  case mlxwakeperiod50Ms // = 5
  case mlxwakeperiod100Ms // = 6
  case mlxwakeperiod150Ms // = 7
  case mlxwakeperiod250Ms // = 8
  case mlxwakeperiod500Ms // = 9
  case mlxwakeperiod1S // = 10
  case mlxwakeperiod2S // = 11
  case mlxwakeperiod25S // = 12
  case mlxwakeperiod3S // = 13
  case mlxwakeperiod4S // = 14
  case mlxwakeperiod5S // = 15
  case mlxwakeperiod6S // = 16
  case mlxwakeperiod7S // = 17
  case mlxwakeperiod8S // = 18
  case mlxwakeperiod9S // = 19
  case mlxwakeperiod10S // = 20
  case mlxwakeperiod11S // = 21
  case mlxwakeperiod12S // = 22
  case mlxwakeperiod15S // = 23
  case mlxwakeperiod20S // = 24
  case mlxwakeperiod30S // = 25
  case mlxwakeperiod1M // = 26
  case mlxwakeperiod2M // = 27
  case mlxwakeperiod3M // = 28
  case mlxwakeperiod4M // = 29
  case mlxwakeperiod5M // = 30
  case mlxwakeperiod10M // = 31
  case mlxwakeperiod16M // = 32
  case mlxwakeperiodNotSet // = 33
  case UNRECOGNIZED(Int)

  init() {
    self = .mlxwakeperiod2Ms
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mlxwakeperiod2Ms
    case 1: self = .mlxwakeperiod3Ms
    case 2: self = .mlxwakeperiod5Ms
    case 3: self = .mlxwakeperiod15Ms
    case 4: self = .mlxwakeperiod30Ms
    case 5: self = .mlxwakeperiod50Ms
    case 6: self = .mlxwakeperiod100Ms
    case 7: self = .mlxwakeperiod150Ms
    case 8: self = .mlxwakeperiod250Ms
    case 9: self = .mlxwakeperiod500Ms
    case 10: self = .mlxwakeperiod1S
    case 11: self = .mlxwakeperiod2S
    case 12: self = .mlxwakeperiod25S
    case 13: self = .mlxwakeperiod3S
    case 14: self = .mlxwakeperiod4S
    case 15: self = .mlxwakeperiod5S
    case 16: self = .mlxwakeperiod6S
    case 17: self = .mlxwakeperiod7S
    case 18: self = .mlxwakeperiod8S
    case 19: self = .mlxwakeperiod9S
    case 20: self = .mlxwakeperiod10S
    case 21: self = .mlxwakeperiod11S
    case 22: self = .mlxwakeperiod12S
    case 23: self = .mlxwakeperiod15S
    case 24: self = .mlxwakeperiod20S
    case 25: self = .mlxwakeperiod30S
    case 26: self = .mlxwakeperiod1M
    case 27: self = .mlxwakeperiod2M
    case 28: self = .mlxwakeperiod3M
    case 29: self = .mlxwakeperiod4M
    case 30: self = .mlxwakeperiod5M
    case 31: self = .mlxwakeperiod10M
    case 32: self = .mlxwakeperiod16M
    case 33: self = .mlxwakeperiodNotSet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .mlxwakeperiod2Ms: return 0
    case .mlxwakeperiod3Ms: return 1
    case .mlxwakeperiod5Ms: return 2
    case .mlxwakeperiod15Ms: return 3
    case .mlxwakeperiod30Ms: return 4
    case .mlxwakeperiod50Ms: return 5
    case .mlxwakeperiod100Ms: return 6
    case .mlxwakeperiod150Ms: return 7
    case .mlxwakeperiod250Ms: return 8
    case .mlxwakeperiod500Ms: return 9
    case .mlxwakeperiod1S: return 10
    case .mlxwakeperiod2S: return 11
    case .mlxwakeperiod25S: return 12
    case .mlxwakeperiod3S: return 13
    case .mlxwakeperiod4S: return 14
    case .mlxwakeperiod5S: return 15
    case .mlxwakeperiod6S: return 16
    case .mlxwakeperiod7S: return 17
    case .mlxwakeperiod8S: return 18
    case .mlxwakeperiod9S: return 19
    case .mlxwakeperiod10S: return 20
    case .mlxwakeperiod11S: return 21
    case .mlxwakeperiod12S: return 22
    case .mlxwakeperiod15S: return 23
    case .mlxwakeperiod20S: return 24
    case .mlxwakeperiod30S: return 25
    case .mlxwakeperiod1M: return 26
    case .mlxwakeperiod2M: return 27
    case .mlxwakeperiod3M: return 28
    case .mlxwakeperiod4M: return 29
    case .mlxwakeperiod5M: return 30
    case .mlxwakeperiod10M: return 31
    case .mlxwakeperiod16M: return 32
    case .mlxwakeperiodNotSet: return 33
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_MLXWakePeriod_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_MLXWakePeriod_E] = [
    .mlxwakeperiod2Ms,
    .mlxwakeperiod3Ms,
    .mlxwakeperiod5Ms,
    .mlxwakeperiod15Ms,
    .mlxwakeperiod30Ms,
    .mlxwakeperiod50Ms,
    .mlxwakeperiod100Ms,
    .mlxwakeperiod150Ms,
    .mlxwakeperiod250Ms,
    .mlxwakeperiod500Ms,
    .mlxwakeperiod1S,
    .mlxwakeperiod2S,
    .mlxwakeperiod25S,
    .mlxwakeperiod3S,
    .mlxwakeperiod4S,
    .mlxwakeperiod5S,
    .mlxwakeperiod6S,
    .mlxwakeperiod7S,
    .mlxwakeperiod8S,
    .mlxwakeperiod9S,
    .mlxwakeperiod10S,
    .mlxwakeperiod11S,
    .mlxwakeperiod12S,
    .mlxwakeperiod15S,
    .mlxwakeperiod20S,
    .mlxwakeperiod30S,
    .mlxwakeperiod1M,
    .mlxwakeperiod2M,
    .mlxwakeperiod3M,
    .mlxwakeperiod4M,
    .mlxwakeperiod5M,
    .mlxwakeperiod10M,
    .mlxwakeperiod16M,
    .mlxwakeperiodNotSet,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_NFCPresence: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case notPresent // = 0
  case presentAtBPillar // = 1
  case presentAtCenterConsole // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .notPresent
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notPresent
    case 1: self = .presentAtBPillar
    case 2: self = .presentAtCenterConsole
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .notPresent: return 0
    case .presentAtBPillar: return 1
    case .presentAtCenterConsole: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_NFCPresence: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_NFCPresence] = [
    .notPresent,
    .presentAtBPillar,
    .presentAtCenterConsole,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_NFCSEDevicePubKeyState_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nfcsecDevicepubkeyStateNone // = 0
  case nfcsecDevicepubkeyStateRetrieved // = 1
  case nfcsecDevicepubkeyStateNotRetrieved // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .nfcsecDevicepubkeyStateNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nfcsecDevicepubkeyStateNone
    case 1: self = .nfcsecDevicepubkeyStateRetrieved
    case 2: self = .nfcsecDevicepubkeyStateNotRetrieved
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nfcsecDevicepubkeyStateNone: return 0
    case .nfcsecDevicepubkeyStateRetrieved: return 1
    case .nfcsecDevicepubkeyStateNotRetrieved: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_NFCSEDevicePubKeyState_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_NFCSEDevicePubKeyState_E] = [
    .nfcsecDevicepubkeyStateNone,
    .nfcsecDevicepubkeyStateRetrieved,
    .nfcsecDevicepubkeyStateNotRetrieved,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_NFCSEInsecureCommandState_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nfcsecInsecureCommandStateNone // = 0
  case nfcsecInsecureCommandStateEnabled // = 1
  case nfcsecInsecureCommandStateDisabled // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .nfcsecInsecureCommandStateNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nfcsecInsecureCommandStateNone
    case 1: self = .nfcsecInsecureCommandStateEnabled
    case 2: self = .nfcsecInsecureCommandStateDisabled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nfcsecInsecureCommandStateNone: return 0
    case .nfcsecInsecureCommandStateEnabled: return 1
    case .nfcsecInsecureCommandStateDisabled: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_NFCSEInsecureCommandState_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_NFCSEInsecureCommandState_E] = [
    .nfcsecInsecureCommandStateNone,
    .nfcsecInsecureCommandStateEnabled,
    .nfcsecInsecureCommandStateDisabled,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_NFCSERequest_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nfcseRequestNone // = 0
  case nfcseRequestRefetchSessionInfo // = 1
  case nfcseRequestDisableInsecureCommands // = 2
  case nfcseRequestGetCurrentState // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .nfcseRequestNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nfcseRequestNone
    case 1: self = .nfcseRequestRefetchSessionInfo
    case 2: self = .nfcseRequestDisableInsecureCommands
    case 3: self = .nfcseRequestGetCurrentState
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nfcseRequestNone: return 0
    case .nfcseRequestRefetchSessionInfo: return 1
    case .nfcseRequestDisableInsecureCommands: return 2
    case .nfcseRequestGetCurrentState: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_NFCSERequest_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_NFCSERequest_E] = [
    .nfcseRequestNone,
    .nfcseRequestRefetchSessionInfo,
    .nfcseRequestDisableInsecureCommands,
    .nfcseRequestGetCurrentState,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_NFCSESharedSecretState_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nfcsecSharedsecretStateNone // = 0
  case nfcsecSharedsecretStateGenerated // = 1
  case nfcsecSharedsecretStateNotGenerated // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .nfcsecSharedsecretStateNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nfcsecSharedsecretStateNone
    case 1: self = .nfcsecSharedsecretStateGenerated
    case 2: self = .nfcsecSharedsecretStateNotGenerated
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nfcsecSharedsecretStateNone: return 0
    case .nfcsecSharedsecretStateGenerated: return 1
    case .nfcsecSharedsecretStateNotGenerated: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_NFCSESharedSecretState_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_NFCSESharedSecretState_E] = [
    .nfcsecSharedsecretStateNone,
    .nfcsecSharedsecretStateGenerated,
    .nfcsecSharedsecretStateNotGenerated,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_NFCSEVehiclePubKeyState_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nfcsecVehiclepubkeyStateNone // = 0
  case nfcsecVehiclepubkeyStateRetrieved // = 1
  case nfcsecVehiclepubkeyStateNotRetrieved // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .nfcsecVehiclepubkeyStateNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nfcsecVehiclepubkeyStateNone
    case 1: self = .nfcsecVehiclepubkeyStateRetrieved
    case 2: self = .nfcsecVehiclepubkeyStateNotRetrieved
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nfcsecVehiclepubkeyStateNone: return 0
    case .nfcsecVehiclepubkeyStateRetrieved: return 1
    case .nfcsecVehiclepubkeyStateNotRetrieved: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_NFCSEVehiclePubKeyState_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_NFCSEVehiclePubKeyState_E] = [
    .nfcsecVehiclepubkeyStateNone,
    .nfcsecVehiclepubkeyStateRetrieved,
    .nfcsecVehiclepubkeyStateNotRetrieved,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_OperationStatus_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case operationstatusOk // = 0
  case operationstatusWait // = 1
  case rror // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .operationstatusOk
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .operationstatusOk
    case 1: self = .operationstatusWait
    case 2: self = .rror
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .operationstatusOk: return 0
    case .operationstatusWait: return 1
    case .rror: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_OperationStatus_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_OperationStatus_E] = [
    .operationstatusOk,
    .operationstatusWait,
    .rror,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_RCI_control_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case rciControlNone // = 0
  case rciControlTurnOff // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .rciControlNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rciControlNone
    case 1: self = .rciControlTurnOff
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .rciControlNone: return 0
    case .rciControlTurnOff: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_RCI_control_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_RCI_control_E] = [
    .rciControlNone,
    .rciControlTurnOff,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_ResetTrackerCommand_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case resettrackerCommandNone // = 0
  case resettrackerCommandGetStats // = 1
  case resettrackerCommandClearStats // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .resettrackerCommandNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .resettrackerCommandNone
    case 1: self = .resettrackerCommandGetStats
    case 2: self = .resettrackerCommandClearStats
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .resettrackerCommandNone: return 0
    case .resettrackerCommandGetStats: return 1
    case .resettrackerCommandClearStats: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_ResetTrackerCommand_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_ResetTrackerCommand_E] = [
    .resettrackerCommandNone,
    .resettrackerCommandGetStats,
    .resettrackerCommandClearStats,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_RKEAction_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case rkeActionUnlock // = 0
  case rkeActionLock // = 1
  case rkeActionOpenTrunk // = 2
  case rkeActionOpenFrunk // = 3
  case rkeActionOpenChargePort // = 4
  case rkeActionCloseChargePort // = 5
  case rkeActionCancelExternalAuthenticate // = 6
  case rkeActionSinglePressTop // = 7
  case rkeActionDoublePressTop // = 8
  case rkeActionTriplePressTop // = 9
  case rkeActionHoldTop // = 10
  case rkeActionSinglePressBack // = 11
  case rkeActionDoublePressBack // = 12
  case rkeActionTriplePressBack // = 13
  case rkeActionHoldBack // = 14
  case rkeActionSinglePressFront // = 15
  case rkeActionDoublePressFront // = 16
  case rkeActionTriplePressFront // = 17
  case rkeActionHoldFront // = 18
  case rkeActionUnknown // = 19
  case rkeActionRemoteDrive // = 20
  case rkeActionSinglePressLeft // = 21
  case rkeActionDoublePressLeft // = 22
  case rkeActionTriplePressLeft // = 23
  case rkeActionHoldLeft // = 24
  case rkeActionSinglePressRight // = 25
  case rkeActionDoublePressRight // = 26
  case rkeActionTriplePressRight // = 27
  case rkeActionHoldRight // = 28
  case rkeActionAutoSecureVehicle // = 29
  case rkeActionWakeVehicle // = 30
  case UNRECOGNIZED(Int)

  init() {
    self = .rkeActionUnlock
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rkeActionUnlock
    case 1: self = .rkeActionLock
    case 2: self = .rkeActionOpenTrunk
    case 3: self = .rkeActionOpenFrunk
    case 4: self = .rkeActionOpenChargePort
    case 5: self = .rkeActionCloseChargePort
    case 6: self = .rkeActionCancelExternalAuthenticate
    case 7: self = .rkeActionSinglePressTop
    case 8: self = .rkeActionDoublePressTop
    case 9: self = .rkeActionTriplePressTop
    case 10: self = .rkeActionHoldTop
    case 11: self = .rkeActionSinglePressBack
    case 12: self = .rkeActionDoublePressBack
    case 13: self = .rkeActionTriplePressBack
    case 14: self = .rkeActionHoldBack
    case 15: self = .rkeActionSinglePressFront
    case 16: self = .rkeActionDoublePressFront
    case 17: self = .rkeActionTriplePressFront
    case 18: self = .rkeActionHoldFront
    case 19: self = .rkeActionUnknown
    case 20: self = .rkeActionRemoteDrive
    case 21: self = .rkeActionSinglePressLeft
    case 22: self = .rkeActionDoublePressLeft
    case 23: self = .rkeActionTriplePressLeft
    case 24: self = .rkeActionHoldLeft
    case 25: self = .rkeActionSinglePressRight
    case 26: self = .rkeActionDoublePressRight
    case 27: self = .rkeActionTriplePressRight
    case 28: self = .rkeActionHoldRight
    case 29: self = .rkeActionAutoSecureVehicle
    case 30: self = .rkeActionWakeVehicle
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .rkeActionUnlock: return 0
    case .rkeActionLock: return 1
    case .rkeActionOpenTrunk: return 2
    case .rkeActionOpenFrunk: return 3
    case .rkeActionOpenChargePort: return 4
    case .rkeActionCloseChargePort: return 5
    case .rkeActionCancelExternalAuthenticate: return 6
    case .rkeActionSinglePressTop: return 7
    case .rkeActionDoublePressTop: return 8
    case .rkeActionTriplePressTop: return 9
    case .rkeActionHoldTop: return 10
    case .rkeActionSinglePressBack: return 11
    case .rkeActionDoublePressBack: return 12
    case .rkeActionTriplePressBack: return 13
    case .rkeActionHoldBack: return 14
    case .rkeActionSinglePressFront: return 15
    case .rkeActionDoublePressFront: return 16
    case .rkeActionTriplePressFront: return 17
    case .rkeActionHoldFront: return 18
    case .rkeActionUnknown: return 19
    case .rkeActionRemoteDrive: return 20
    case .rkeActionSinglePressLeft: return 21
    case .rkeActionDoublePressLeft: return 22
    case .rkeActionTriplePressLeft: return 23
    case .rkeActionHoldLeft: return 24
    case .rkeActionSinglePressRight: return 25
    case .rkeActionDoublePressRight: return 26
    case .rkeActionTriplePressRight: return 27
    case .rkeActionHoldRight: return 28
    case .rkeActionAutoSecureVehicle: return 29
    case .rkeActionWakeVehicle: return 30
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_RKEAction_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_RKEAction_E] = [
    .rkeActionUnlock,
    .rkeActionLock,
    .rkeActionOpenTrunk,
    .rkeActionOpenFrunk,
    .rkeActionOpenChargePort,
    .rkeActionCloseChargePort,
    .rkeActionCancelExternalAuthenticate,
    .rkeActionSinglePressTop,
    .rkeActionDoublePressTop,
    .rkeActionTriplePressTop,
    .rkeActionHoldTop,
    .rkeActionSinglePressBack,
    .rkeActionDoublePressBack,
    .rkeActionTriplePressBack,
    .rkeActionHoldBack,
    .rkeActionSinglePressFront,
    .rkeActionDoublePressFront,
    .rkeActionTriplePressFront,
    .rkeActionHoldFront,
    .rkeActionUnknown,
    .rkeActionRemoteDrive,
    .rkeActionSinglePressLeft,
    .rkeActionDoublePressLeft,
    .rkeActionTriplePressLeft,
    .rkeActionHoldLeft,
    .rkeActionSinglePressRight,
    .rkeActionDoublePressRight,
    .rkeActionTriplePressRight,
    .rkeActionHoldRight,
    .rkeActionAutoSecureVehicle,
    .rkeActionWakeVehicle,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_Role: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case service // = 1
  case owner // = 2
  case driver // = 3
  case fm // = 4
  case vehicleMonitor // = 5
  case chargingManager // = 6
  case serviceTech // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .service
    case 2: self = .owner
    case 3: self = .driver
    case 4: self = .fm
    case 5: self = .vehicleMonitor
    case 6: self = .chargingManager
    case 7: self = .serviceTech
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .service: return 1
    case .owner: return 2
    case .driver: return 3
    case .fm: return 4
    case .vehicleMonitor: return 5
    case .chargingManager: return 6
    case .serviceTech: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_Role: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_Role] = [
    .none,
    .service,
    .owner,
    .driver,
    .fm,
    .vehicleMonitor,
    .chargingManager,
    .serviceTech,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_Session_Info_Status: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ok // = 0
  case keyNotOnWhitelist // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .ok
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .keyNotOnWhitelist
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ok: return 0
    case .keyNotOnWhitelist: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_Session_Info_Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_Session_Info_Status] = [
    .ok,
    .keyNotOnWhitelist,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_SignatureType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case aesGcm // = 0
  case ecdsa // = 1
  case presentKey // = 2
  case aesGcmToken // = 3
  case unsigned // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .aesGcm
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .aesGcm
    case 1: self = .ecdsa
    case 2: self = .presentKey
    case 3: self = .aesGcmToken
    case 4: self = .unsigned
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .aesGcm: return 0
    case .ecdsa: return 1
    case .presentKey: return 2
    case .aesGcmToken: return 3
    case .unsigned: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_SignatureType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_SignatureType] = [
    .aesGcm,
    .ecdsa,
    .presentKey,
    .aesGcmToken,
    .unsigned,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_SignedMessage_information_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case signedmessageInformationNone // = 0
  case signedmessageInformationFaultUnknown // = 1
  case signedmessageInformationFaultNotOnWhitelist // = 2
  case signedmessageInformationFaultIvSmallerThanExpected // = 3
  case signedmessageInformationFaultInvalidToken // = 4
  case signedmessageInformationFaultTokenAndCounterInvalid // = 5
  case signedmessageInformationFaultAesDecryptAuth // = 6
  case signedmessageInformationFaultEcdsaInput // = 7
  case signedmessageInformationFaultEcdsaSignature // = 8
  case signedmessageInformationFaultLocalEntityStart // = 9
  case signedmessageInformationFaultLocalEntityResult // = 10
  case signedmessageInformationFaultCouldNotRetrieveKey // = 11
  case signedmessageInformationFaultCouldNotRetrieveToken // = 12
  case signedmessageInformationFaultSignatureTooShort // = 13
  case signedmessageInformationFaultTokenIsIncorrectLength // = 14
  case signedmessageInformationFaultIncorrectEpoch // = 15
  case signedmessageInformationFaultIvIncorrectLength // = 16
  case signedmessageInformationFaultTimeExpired // = 17
  case signedmessageInformationFaultNotProvisionedWithIdentity // = 18
  case signedmessageInformationFaultCouldNotHashMetadata // = 19
  case UNRECOGNIZED(Int)

  init() {
    self = .signedmessageInformationNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .signedmessageInformationNone
    case 1: self = .signedmessageInformationFaultUnknown
    case 2: self = .signedmessageInformationFaultNotOnWhitelist
    case 3: self = .signedmessageInformationFaultIvSmallerThanExpected
    case 4: self = .signedmessageInformationFaultInvalidToken
    case 5: self = .signedmessageInformationFaultTokenAndCounterInvalid
    case 6: self = .signedmessageInformationFaultAesDecryptAuth
    case 7: self = .signedmessageInformationFaultEcdsaInput
    case 8: self = .signedmessageInformationFaultEcdsaSignature
    case 9: self = .signedmessageInformationFaultLocalEntityStart
    case 10: self = .signedmessageInformationFaultLocalEntityResult
    case 11: self = .signedmessageInformationFaultCouldNotRetrieveKey
    case 12: self = .signedmessageInformationFaultCouldNotRetrieveToken
    case 13: self = .signedmessageInformationFaultSignatureTooShort
    case 14: self = .signedmessageInformationFaultTokenIsIncorrectLength
    case 15: self = .signedmessageInformationFaultIncorrectEpoch
    case 16: self = .signedmessageInformationFaultIvIncorrectLength
    case 17: self = .signedmessageInformationFaultTimeExpired
    case 18: self = .signedmessageInformationFaultNotProvisionedWithIdentity
    case 19: self = .signedmessageInformationFaultCouldNotHashMetadata
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .signedmessageInformationNone: return 0
    case .signedmessageInformationFaultUnknown: return 1
    case .signedmessageInformationFaultNotOnWhitelist: return 2
    case .signedmessageInformationFaultIvSmallerThanExpected: return 3
    case .signedmessageInformationFaultInvalidToken: return 4
    case .signedmessageInformationFaultTokenAndCounterInvalid: return 5
    case .signedmessageInformationFaultAesDecryptAuth: return 6
    case .signedmessageInformationFaultEcdsaInput: return 7
    case .signedmessageInformationFaultEcdsaSignature: return 8
    case .signedmessageInformationFaultLocalEntityStart: return 9
    case .signedmessageInformationFaultLocalEntityResult: return 10
    case .signedmessageInformationFaultCouldNotRetrieveKey: return 11
    case .signedmessageInformationFaultCouldNotRetrieveToken: return 12
    case .signedmessageInformationFaultSignatureTooShort: return 13
    case .signedmessageInformationFaultTokenIsIncorrectLength: return 14
    case .signedmessageInformationFaultIncorrectEpoch: return 15
    case .signedmessageInformationFaultIvIncorrectLength: return 16
    case .signedmessageInformationFaultTimeExpired: return 17
    case .signedmessageInformationFaultNotProvisionedWithIdentity: return 18
    case .signedmessageInformationFaultCouldNotHashMetadata: return 19
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_SignedMessage_information_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_SignedMessage_information_E] = [
    .signedmessageInformationNone,
    .signedmessageInformationFaultUnknown,
    .signedmessageInformationFaultNotOnWhitelist,
    .signedmessageInformationFaultIvSmallerThanExpected,
    .signedmessageInformationFaultInvalidToken,
    .signedmessageInformationFaultTokenAndCounterInvalid,
    .signedmessageInformationFaultAesDecryptAuth,
    .signedmessageInformationFaultEcdsaInput,
    .signedmessageInformationFaultEcdsaSignature,
    .signedmessageInformationFaultLocalEntityStart,
    .signedmessageInformationFaultLocalEntityResult,
    .signedmessageInformationFaultCouldNotRetrieveKey,
    .signedmessageInformationFaultCouldNotRetrieveToken,
    .signedmessageInformationFaultSignatureTooShort,
    .signedmessageInformationFaultTokenIsIncorrectLength,
    .signedmessageInformationFaultIncorrectEpoch,
    .signedmessageInformationFaultIvIncorrectLength,
    .signedmessageInformationFaultTimeExpired,
    .signedmessageInformationFaultNotProvisionedWithIdentity,
    .signedmessageInformationFaultCouldNotHashMetadata,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_SleepManagerCommand_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case sleepmanagerCommandNone // = 0
  case sleepmanagerGetStats // = 1
  case sleepmanagerResetStats // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .sleepmanagerCommandNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sleepmanagerCommandNone
    case 1: self = .sleepmanagerGetStats
    case 2: self = .sleepmanagerResetStats
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .sleepmanagerCommandNone: return 0
    case .sleepmanagerGetStats: return 1
    case .sleepmanagerResetStats: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_SleepManagerCommand_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_SleepManagerCommand_E] = [
    .sleepmanagerCommandNone,
    .sleepmanagerGetStats,
    .sleepmanagerResetStats,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_TPDataRequest_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case tpDatarequestNone // = 0
  case tpDatarequestPressureTemperature // = 1
  case tpDatarequestNewSensorInfo // = 2
  case tpDatarequestWheelRotationDirection // = 3
  case tpDatarequestAccel // = 4
  case tpDatarequestMotionDetectionStart // = 5
  case tpDatarequestReadAlarms // = 6
  case tpDatarequestMotionDetectionStop // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .tpDatarequestNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tpDatarequestNone
    case 1: self = .tpDatarequestPressureTemperature
    case 2: self = .tpDatarequestNewSensorInfo
    case 3: self = .tpDatarequestWheelRotationDirection
    case 4: self = .tpDatarequestAccel
    case 5: self = .tpDatarequestMotionDetectionStart
    case 6: self = .tpDatarequestReadAlarms
    case 7: self = .tpDatarequestMotionDetectionStop
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .tpDatarequestNone: return 0
    case .tpDatarequestPressureTemperature: return 1
    case .tpDatarequestNewSensorInfo: return 2
    case .tpDatarequestWheelRotationDirection: return 3
    case .tpDatarequestAccel: return 4
    case .tpDatarequestMotionDetectionStart: return 5
    case .tpDatarequestReadAlarms: return 6
    case .tpDatarequestMotionDetectionStop: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_TPDataRequest_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_TPDataRequest_E] = [
    .tpDatarequestNone,
    .tpDatarequestPressureTemperature,
    .tpDatarequestNewSensorInfo,
    .tpDatarequestWheelRotationDirection,
    .tpDatarequestAccel,
    .tpDatarequestMotionDetectionStart,
    .tpDatarequestReadAlarms,
    .tpDatarequestMotionDetectionStop,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_TPMSAdvType_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case tpmsAdvTypeSemi // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .tpmsAdvTypeSemi
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tpmsAdvTypeSemi
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .tpmsAdvTypeSemi: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_TPMSAdvType_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_TPMSAdvType_E] = [
    .tpmsAdvTypeSemi,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_TPNotifyReason_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case tpNotifyReasonUnknown // = 0
  case tpNotifyReasonLowPressure // = 1
  case tpNotifyReasonPtValueUpdate // = 2
  case tpNotifyReasonWheelMoving // = 3
  case tpNotifyReasonWheelRotationDirectionCalculationReady // = 4
  case tpNotifyReasonLf // = 5
  case tpNotifyReasonFault // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .tpNotifyReasonUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tpNotifyReasonUnknown
    case 1: self = .tpNotifyReasonLowPressure
    case 2: self = .tpNotifyReasonPtValueUpdate
    case 3: self = .tpNotifyReasonWheelMoving
    case 4: self = .tpNotifyReasonWheelRotationDirectionCalculationReady
    case 5: self = .tpNotifyReasonLf
    case 6: self = .tpNotifyReasonFault
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .tpNotifyReasonUnknown: return 0
    case .tpNotifyReasonLowPressure: return 1
    case .tpNotifyReasonPtValueUpdate: return 2
    case .tpNotifyReasonWheelMoving: return 3
    case .tpNotifyReasonWheelRotationDirectionCalculationReady: return 4
    case .tpNotifyReasonLf: return 5
    case .tpNotifyReasonFault: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_TPNotifyReason_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_TPNotifyReason_E] = [
    .tpNotifyReasonUnknown,
    .tpNotifyReasonLowPressure,
    .tpNotifyReasonPtValueUpdate,
    .tpNotifyReasonWheelMoving,
    .tpNotifyReasonWheelRotationDirectionCalculationReady,
    .tpNotifyReasonLf,
    .tpNotifyReasonFault,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_TPNotifyTrackerCommand_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case tpNotifytrackerCommandNone // = 0
  case tpNotifytrackerCommandGetStats // = 1
  case tpNotifytrackerCommandClearStats // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .tpNotifytrackerCommandNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tpNotifytrackerCommandNone
    case 1: self = .tpNotifytrackerCommandGetStats
    case 2: self = .tpNotifytrackerCommandClearStats
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .tpNotifytrackerCommandNone: return 0
    case .tpNotifytrackerCommandGetStats: return 1
    case .tpNotifytrackerCommandClearStats: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_TPNotifyTrackerCommand_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_TPNotifyTrackerCommand_E] = [
    .tpNotifytrackerCommandNone,
    .tpNotifytrackerCommandGetStats,
    .tpNotifytrackerCommandClearStats,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_UpdaterLocation: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case application // = 1
  case bootloader // = 2
  case secondaryApplication // = 3
  case applicationInExternalFlash // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .application
    case 2: self = .bootloader
    case 3: self = .secondaryApplication
    case 4: self = .applicationInExternalFlash
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .application: return 1
    case .bootloader: return 2
    case .secondaryApplication: return 3
    case .applicationInExternalFlash: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_UpdaterLocation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_UpdaterLocation] = [
    .none,
    .application,
    .bootloader,
    .secondaryApplication,
    .applicationInExternalFlash,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_UpdaterStatusCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case error // = 0
  case wait // = 1
  case blockStaged // = 2
  case imageStaged // = 3
  case crcCheckSuccess // = 4
  case crcCheckFail // = 5
  case hashFail // = 6
  case signatureFail // = 7
  case errorHashRestoreFail // = 8
  case locationSet // = 9
  case UNRECOGNIZED(Int)

  init() {
    self = .error
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .error
    case 1: self = .wait
    case 2: self = .blockStaged
    case 3: self = .imageStaged
    case 4: self = .crcCheckSuccess
    case 5: self = .crcCheckFail
    case 6: self = .hashFail
    case 7: self = .signatureFail
    case 8: self = .errorHashRestoreFail
    case 9: self = .locationSet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .error: return 0
    case .wait: return 1
    case .blockStaged: return 2
    case .imageStaged: return 3
    case .crcCheckSuccess: return 4
    case .crcCheckFail: return 5
    case .hashFail: return 6
    case .signatureFail: return 7
    case .errorHashRestoreFail: return 8
    case .locationSet: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_UpdaterStatusCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_UpdaterStatusCode] = [
    .error,
    .wait,
    .blockStaged,
    .imageStaged,
    .crcCheckSuccess,
    .crcCheckFail,
    .hashFail,
    .signatureFail,
    .errorHashRestoreFail,
    .locationSet,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_UWBAvailability: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case available // = 1
  case unavailableUnsupportedDevice // = 2
  case unavailablePermissionDenied // = 3
  case unavailable // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .available
    case 2: self = .unavailableUnsupportedDevice
    case 3: self = .unavailablePermissionDenied
    case 4: self = .unavailable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .available: return 1
    case .unavailableUnsupportedDevice: return 2
    case .unavailablePermissionDenied: return 3
    case .unavailable: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_UWBAvailability: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_UWBAvailability] = [
    .unknown,
    .available,
    .unavailableUnsupportedDevice,
    .unavailablePermissionDenied,
    .unavailable,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_VehicleLockState_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case vehiclelockstateUnlocked // = 0
  case vehiclelockstateLocked // = 1
  case vehiclelockstateInternalLocked // = 2
  case vehiclelockstateSelectiveUnlocked // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .vehiclelockstateUnlocked
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .vehiclelockstateUnlocked
    case 1: self = .vehiclelockstateLocked
    case 2: self = .vehiclelockstateInternalLocked
    case 3: self = .vehiclelockstateSelectiveUnlocked
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .vehiclelockstateUnlocked: return 0
    case .vehiclelockstateLocked: return 1
    case .vehiclelockstateInternalLocked: return 2
    case .vehiclelockstateSelectiveUnlocked: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_VehicleLockState_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_VehicleLockState_E] = [
    .vehiclelockstateUnlocked,
    .vehiclelockstateLocked,
    .vehiclelockstateInternalLocked,
    .vehiclelockstateSelectiveUnlocked,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_VehicleSleepStatus_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case vehicleSleepStatusUnknown // = 0
  case vehicleSleepStatusAwake // = 1
  case vehicleSleepStatusAsleep // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .vehicleSleepStatusUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .vehicleSleepStatusUnknown
    case 1: self = .vehicleSleepStatusAwake
    case 2: self = .vehicleSleepStatusAsleep
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .vehicleSleepStatusUnknown: return 0
    case .vehicleSleepStatusAwake: return 1
    case .vehicleSleepStatusAsleep: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_VehicleSleepStatus_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_VehicleSleepStatus_E] = [
    .vehicleSleepStatusUnknown,
    .vehicleSleepStatusAwake,
    .vehicleSleepStatusAsleep,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_WhitelistKeyPermission_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case whitelistkeypermissionAddToWhitelist // = 0
  case whitelistkeypermissionLocalUnlock // = 1
  case whitelistkeypermissionLocalDrive // = 2
  case whitelistkeypermissionRemoteUnlock // = 3
  case whitelistkeypermissionRemoteDrive // = 4
  case whitelistkeypermissionChangePermissions // = 5
  case whitelistkeypermissionRemoveFromWhitelist // = 6
  case whitelistkeypermissionRemoveSelfFromWhitelist // = 7
  case whitelistkeypermissionModifyFleetReservedSlots // = 8
  case whitelistkeypermissionUnknown // = 31
  case UNRECOGNIZED(Int)

  init() {
    self = .whitelistkeypermissionAddToWhitelist
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .whitelistkeypermissionAddToWhitelist
    case 1: self = .whitelistkeypermissionLocalUnlock
    case 2: self = .whitelistkeypermissionLocalDrive
    case 3: self = .whitelistkeypermissionRemoteUnlock
    case 4: self = .whitelistkeypermissionRemoteDrive
    case 5: self = .whitelistkeypermissionChangePermissions
    case 6: self = .whitelistkeypermissionRemoveFromWhitelist
    case 7: self = .whitelistkeypermissionRemoveSelfFromWhitelist
    case 8: self = .whitelistkeypermissionModifyFleetReservedSlots
    case 31: self = .whitelistkeypermissionUnknown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .whitelistkeypermissionAddToWhitelist: return 0
    case .whitelistkeypermissionLocalUnlock: return 1
    case .whitelistkeypermissionLocalDrive: return 2
    case .whitelistkeypermissionRemoteUnlock: return 3
    case .whitelistkeypermissionRemoteDrive: return 4
    case .whitelistkeypermissionChangePermissions: return 5
    case .whitelistkeypermissionRemoveFromWhitelist: return 6
    case .whitelistkeypermissionRemoveSelfFromWhitelist: return 7
    case .whitelistkeypermissionModifyFleetReservedSlots: return 8
    case .whitelistkeypermissionUnknown: return 31
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_WhitelistKeyPermission_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_WhitelistKeyPermission_E] = [
    .whitelistkeypermissionAddToWhitelist,
    .whitelistkeypermissionLocalUnlock,
    .whitelistkeypermissionLocalDrive,
    .whitelistkeypermissionRemoteUnlock,
    .whitelistkeypermissionRemoteDrive,
    .whitelistkeypermissionChangePermissions,
    .whitelistkeypermissionRemoveFromWhitelist,
    .whitelistkeypermissionRemoveSelfFromWhitelist,
    .whitelistkeypermissionModifyFleetReservedSlots,
    .whitelistkeypermissionUnknown,
  ]
}

#endif  // swift(>=4.2)

enum VCSEC_WhitelistOperation_information_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case whitelistoperationInformationNone // = 0
  case whitelistoperationInformationUndocumentedError // = 1
  case whitelistoperationInformationNoPermissionToRemoveOneself // = 2
  case whitelistoperationInformationKeyfobSlotsFull // = 3
  case whitelistoperationInformationWhitelistFull // = 4
  case whitelistoperationInformationNoPermissionToAdd // = 5
  case whitelistoperationInformationInvalidPublicKey // = 6
  case whitelistoperationInformationNoPermissionToRemove // = 7
  case whitelistoperationInformationNoPermissionToChangePermissions // = 8
  case whitelistoperationInformationAttemptingToElevateOtherAboveOneself // = 9
  case whitelistoperationInformationAttemptingToDemoteSuperiorToOneself // = 10
  case whitelistoperationInformationAttemptingToRemoveOwnPermissions // = 11
  case whitelistoperationInformationPublicKeyNotOnWhitelist // = 12
  case whitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist // = 13
  case whitelistoperationInformationNotAllowedToAddUnlessOnReader // = 14
  case whitelistoperationInformationFmModifyingOutsideOfFMode // = 15
  case whitelistoperationInformationFmAttemptingToAddPermanentKey // = 16
  case whitelistoperationInformationFmAttemptingToRemovePermanentKey // = 17
  case whitelistoperationInformationKeychainWhileFsFull // = 18
  case whitelistoperationInformationAttemptingToAddKeyWithoutRole // = 19
  case whitelistoperationInformationAttemptingToAddKeyWithServiceRole // = 20
  case whitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech // = 21
  case whitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode // = 22
  case UNRECOGNIZED(Int)

  init() {
    self = .whitelistoperationInformationNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .whitelistoperationInformationNone
    case 1: self = .whitelistoperationInformationUndocumentedError
    case 2: self = .whitelistoperationInformationNoPermissionToRemoveOneself
    case 3: self = .whitelistoperationInformationKeyfobSlotsFull
    case 4: self = .whitelistoperationInformationWhitelistFull
    case 5: self = .whitelistoperationInformationNoPermissionToAdd
    case 6: self = .whitelistoperationInformationInvalidPublicKey
    case 7: self = .whitelistoperationInformationNoPermissionToRemove
    case 8: self = .whitelistoperationInformationNoPermissionToChangePermissions
    case 9: self = .whitelistoperationInformationAttemptingToElevateOtherAboveOneself
    case 10: self = .whitelistoperationInformationAttemptingToDemoteSuperiorToOneself
    case 11: self = .whitelistoperationInformationAttemptingToRemoveOwnPermissions
    case 12: self = .whitelistoperationInformationPublicKeyNotOnWhitelist
    case 13: self = .whitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist
    case 14: self = .whitelistoperationInformationNotAllowedToAddUnlessOnReader
    case 15: self = .whitelistoperationInformationFmModifyingOutsideOfFMode
    case 16: self = .whitelistoperationInformationFmAttemptingToAddPermanentKey
    case 17: self = .whitelistoperationInformationFmAttemptingToRemovePermanentKey
    case 18: self = .whitelistoperationInformationKeychainWhileFsFull
    case 19: self = .whitelistoperationInformationAttemptingToAddKeyWithoutRole
    case 20: self = .whitelistoperationInformationAttemptingToAddKeyWithServiceRole
    case 21: self = .whitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech
    case 22: self = .whitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .whitelistoperationInformationNone: return 0
    case .whitelistoperationInformationUndocumentedError: return 1
    case .whitelistoperationInformationNoPermissionToRemoveOneself: return 2
    case .whitelistoperationInformationKeyfobSlotsFull: return 3
    case .whitelistoperationInformationWhitelistFull: return 4
    case .whitelistoperationInformationNoPermissionToAdd: return 5
    case .whitelistoperationInformationInvalidPublicKey: return 6
    case .whitelistoperationInformationNoPermissionToRemove: return 7
    case .whitelistoperationInformationNoPermissionToChangePermissions: return 8
    case .whitelistoperationInformationAttemptingToElevateOtherAboveOneself: return 9
    case .whitelistoperationInformationAttemptingToDemoteSuperiorToOneself: return 10
    case .whitelistoperationInformationAttemptingToRemoveOwnPermissions: return 11
    case .whitelistoperationInformationPublicKeyNotOnWhitelist: return 12
    case .whitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist: return 13
    case .whitelistoperationInformationNotAllowedToAddUnlessOnReader: return 14
    case .whitelistoperationInformationFmModifyingOutsideOfFMode: return 15
    case .whitelistoperationInformationFmAttemptingToAddPermanentKey: return 16
    case .whitelistoperationInformationFmAttemptingToRemovePermanentKey: return 17
    case .whitelistoperationInformationKeychainWhileFsFull: return 18
    case .whitelistoperationInformationAttemptingToAddKeyWithoutRole: return 19
    case .whitelistoperationInformationAttemptingToAddKeyWithServiceRole: return 20
    case .whitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech: return 21
    case .whitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode: return 22
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VCSEC_WhitelistOperation_information_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VCSEC_WhitelistOperation_information_E] = [
    .whitelistoperationInformationNone,
    .whitelistoperationInformationUndocumentedError,
    .whitelistoperationInformationNoPermissionToRemoveOneself,
    .whitelistoperationInformationKeyfobSlotsFull,
    .whitelistoperationInformationWhitelistFull,
    .whitelistoperationInformationNoPermissionToAdd,
    .whitelistoperationInformationInvalidPublicKey,
    .whitelistoperationInformationNoPermissionToRemove,
    .whitelistoperationInformationNoPermissionToChangePermissions,
    .whitelistoperationInformationAttemptingToElevateOtherAboveOneself,
    .whitelistoperationInformationAttemptingToDemoteSuperiorToOneself,
    .whitelistoperationInformationAttemptingToRemoveOwnPermissions,
    .whitelistoperationInformationPublicKeyNotOnWhitelist,
    .whitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist,
    .whitelistoperationInformationNotAllowedToAddUnlessOnReader,
    .whitelistoperationInformationFmModifyingOutsideOfFMode,
    .whitelistoperationInformationFmAttemptingToAddPermanentKey,
    .whitelistoperationInformationFmAttemptingToRemovePermanentKey,
    .whitelistoperationInformationKeychainWhileFsFull,
    .whitelistoperationInformationAttemptingToAddKeyWithoutRole,
    .whitelistoperationInformationAttemptingToAddKeyWithServiceRole,
    .whitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech,
    .whitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode,
  ]
}

#endif  // swift(>=4.2)

struct VCSEC_AccelData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var xAccelG: Int32 = 0

  var zAccelG: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_ActiveKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var activeKey: VCSEC_KeyIdentifier {
    get {return _activeKey ?? VCSEC_KeyIdentifier()}
    set {_activeKey = newValue}
  }
  /// Returns true if `activeKey` has been explicitly set.
  var hasActiveKey: Bool {return self._activeKey != nil}
  /// Clears the value of `activeKey`. Subsequent reads from it will return its default value.
  mutating func clearActiveKey() {self._activeKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _activeKey: VCSEC_KeyIdentifier? = nil
}

struct VCSEC_Alert {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: VCSEC_Alert.OneOf_SubMessage? = nil

  var alertHandlePulledWithoutAuth: VCSEC_AlertHandlePulledWithoutAuth {
    get {
      if case .alertHandlePulledWithoutAuth(let v)? = subMessage {return v}
      return VCSEC_AlertHandlePulledWithoutAuth()
    }
    set {subMessage = .alertHandlePulledWithoutAuth(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case alertHandlePulledWithoutAuth(VCSEC_AlertHandlePulledWithoutAuth)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_Alert.OneOf_SubMessage, rhs: VCSEC_Alert.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.alertHandlePulledWithoutAuth, .alertHandlePulledWithoutAuth): return {
        guard case .alertHandlePulledWithoutAuth(let l) = lhs, case .alertHandlePulledWithoutAuth(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

struct VCSEC_AlertHandlePulledWithoutAuth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeSinceAlertSetMs: UInt32 = 0

  var handlePulled: VCSEC_HandlePulled_E = .handlePulledFrontDriverDoor

  var connectionCount: UInt32 = 0

  var unknownDevicePresent: Bool = false

  var authRequested: Bool = false

  var deviceSpecificPayload: [VCSEC_HandlePulledWithoutAuthDeviceSpecificPayload] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_AppDeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hardwareModelSha256: Data = Data()

  var os: VCSEC_AppOperatingSystem = .unknown

  var uwbavailable: VCSEC_UWBAvailability = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_AuthenticationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionInfo: VCSEC_AuthenticationRequestToken {
    get {return _sessionInfo ?? VCSEC_AuthenticationRequestToken()}
    set {_sessionInfo = newValue}
  }
  /// Returns true if `sessionInfo` has been explicitly set.
  var hasSessionInfo: Bool {return self._sessionInfo != nil}
  /// Clears the value of `sessionInfo`. Subsequent reads from it will return its default value.
  mutating func clearSessionInfo() {self._sessionInfo = nil}

  var requestedLevel: VCSEC_AuthenticationLevel_E = .authenticationLevelNone

  var reasonsForAuth: [VCSEC_AuthenticationReason_E] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sessionInfo: VCSEC_AuthenticationRequestToken? = nil
}

struct VCSEC_AuthenticationRequestToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_AuthenticationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var authenticationLevel: VCSEC_AuthenticationLevel_E = .authenticationLevelNone

  var estimatedDistance: UInt32 = 0

  var authenticationRejection: VCSEC_AuthenticationRejection_E = .authenticationrejectionNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_BLEConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: VCSEC_BLEConfig.OneOf_SubMessage? = nil

  var advinterval: UInt32 {
    get {
      if case .advinterval(let v)? = subMessage {return v}
      return 0
    }
    set {subMessage = .advinterval(newValue)}
  }

  var sleepClockAccuracy: UInt32 {
    get {
      if case .sleepClockAccuracy(let v)? = subMessage {return v}
      return 0
    }
    set {subMessage = .sleepClockAccuracy(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case advinterval(UInt32)
    case sleepClockAccuracy(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_BLEConfig.OneOf_SubMessage, rhs: VCSEC_BLEConfig.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.advinterval, .advinterval): return {
        guard case .advinterval(let l) = lhs, case .advinterval(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sleepClockAccuracy, .sleepClockAccuracy): return {
        guard case .sleepClockAccuracy(let l) = lhs, case .sleepClockAccuracy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VCSEC_BLEConfigAll {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var advinterval: UInt32 = 0

  var sleepClockAccuracy: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_BLEConfigCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bleconfigCommandType: VCSEC_BLEConfigCommandType_E = .bleConfigCommandTypeNone

  var bleconfig: VCSEC_BLEConfig {
    get {return _bleconfig ?? VCSEC_BLEConfig()}
    set {_bleconfig = newValue}
  }
  /// Returns true if `bleconfig` has been explicitly set.
  var hasBleconfig: Bool {return self._bleconfig != nil}
  /// Clears the value of `bleconfig`. Subsequent reads from it will return its default value.
  mutating func clearBleconfig() {self._bleconfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bleconfig: VCSEC_BLEConfig? = nil
}

struct VCSEC_Capabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargePortOpen: Bool = false

  var chargePortClose: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_ClosureMoveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frontDriverDoor: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var frontPassengerDoor: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var rearDriverDoor: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var rearPassengerDoor: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var rearTrunk: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var frontTrunk: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var chargePort: VCSEC_ClosureMoveType_E = .closureMoveTypeNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_ClosureStatuses {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frontDriverDoor: VCSEC_ClosureState_E = .closurestateClosed

  var frontPassengerDoor: VCSEC_ClosureState_E = .closurestateClosed

  var rearDriverDoor: VCSEC_ClosureState_E = .closurestateClosed

  var rearPassengerDoor: VCSEC_ClosureState_E = .closurestateClosed

  var rearTrunk: VCSEC_ClosureState_E = .closurestateClosed

  var frontTrunk: VCSEC_ClosureState_E = .closurestateClosed

  var chargePort: VCSEC_ClosureState_E = .closurestateClosed

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_CodeDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var codeDescriptorLocation: VCSEC_UpdaterLocation = .none

  var version: UInt32 = 0

  var codeDescriptorBytes: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_CommandStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operationStatus: VCSEC_OperationStatus_E = .operationstatusOk

  var subMessage: VCSEC_CommandStatus.OneOf_SubMessage? = nil

  var signedMessageStatus: VCSEC_SignedMessage_status {
    get {
      if case .signedMessageStatus(let v)? = subMessage {return v}
      return VCSEC_SignedMessage_status()
    }
    set {subMessage = .signedMessageStatus(newValue)}
  }

  var whitelistOperationStatus: VCSEC_WhitelistOperation_status {
    get {
      if case .whitelistOperationStatus(let v)? = subMessage {return v}
      return VCSEC_WhitelistOperation_status()
    }
    set {subMessage = .whitelistOperationStatus(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case signedMessageStatus(VCSEC_SignedMessage_status)
    case whitelistOperationStatus(VCSEC_WhitelistOperation_status)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_CommandStatus.OneOf_SubMessage, rhs: VCSEC_CommandStatus.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.signedMessageStatus, .signedMessageStatus): return {
        guard case .signedMessageStatus(let l) = lhs, case .signedMessageStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whitelistOperationStatus, .whitelistOperationStatus): return {
        guard case .whitelistOperationStatus(let l) = lhs, case .whitelistOperationStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VCSEC_ConnectionMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var goodConnEventCount: UInt32 = 0

  var missedConnEventCount: UInt32 = 0

  var badCrcconnEventCount: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_DelaySleepRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var delayTimeMs: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_DeviceMotion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var states: [VCSEC_Device_Motion_State] = []

  var confidence: VCSEC_Device_Motion_Confidence = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_FromRCI {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_FromVCSECMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: VCSEC_FromVCSECMessage.OneOf_SubMessage? = nil

  var vehicleStatus: VCSEC_VehicleStatus {
    get {
      if case .vehicleStatus(let v)? = subMessage {return v}
      return VCSEC_VehicleStatus()
    }
    set {subMessage = .vehicleStatus(newValue)}
  }

  var sessionInfo: VCSEC_SessionInfo {
    get {
      if case .sessionInfo(let v)? = subMessage {return v}
      return VCSEC_SessionInfo()
    }
    set {subMessage = .sessionInfo(newValue)}
  }

  var authenticationRequest: VCSEC_AuthenticationRequest {
    get {
      if case .authenticationRequest(let v)? = subMessage {return v}
      return VCSEC_AuthenticationRequest()
    }
    set {subMessage = .authenticationRequest(newValue)}
  }

  var commandStatus: VCSEC_CommandStatus {
    get {
      if case .commandStatus(let v)? = subMessage {return v}
      return VCSEC_CommandStatus()
    }
    set {subMessage = .commandStatus(newValue)}
  }

  var personalizationInformation: VCSEC_PersonalizationInformation {
    get {
      if case .personalizationInformation(let v)? = subMessage {return v}
      return VCSEC_PersonalizationInformation()
    }
    set {subMessage = .personalizationInformation(newValue)}
  }

  var whitelistInfo: VCSEC_WhitelistInfo {
    get {
      if case .whitelistInfo(let v)? = subMessage {return v}
      return VCSEC_WhitelistInfo()
    }
    set {subMessage = .whitelistInfo(newValue)}
  }

  var whitelistEntryInfo: VCSEC_WhitelistEntryInfo {
    get {
      if case .whitelistEntryInfo(let v)? = subMessage {return v}
      return VCSEC_WhitelistEntryInfo()
    }
    set {subMessage = .whitelistEntryInfo(newValue)}
  }

  var vehicleInfo: VCSEC_VehicleInfo {
    get {
      if case .vehicleInfo(let v)? = subMessage {return v}
      return VCSEC_VehicleInfo()
    }
    set {subMessage = .vehicleInfo(newValue)}
  }

  var capabilities: VCSEC_Capabilities {
    get {
      if case .capabilities(let v)? = subMessage {return v}
      return VCSEC_Capabilities()
    }
    set {subMessage = .capabilities(newValue)}
  }

  var keyStatusInfo: VCSEC_KeyStatusInfo {
    get {
      if case .keyStatusInfo(let v)? = subMessage {return v}
      return VCSEC_KeyStatusInfo()
    }
    set {subMessage = .keyStatusInfo(newValue)}
  }

  var activeKey: VCSEC_ActiveKey {
    get {
      if case .activeKey(let v)? = subMessage {return v}
      return VCSEC_ActiveKey()
    }
    set {subMessage = .activeKey(newValue)}
  }

  var unknownKeyInfo: VCSEC_UnknownKeyInfo {
    get {
      if case .unknownKeyInfo(let v)? = subMessage {return v}
      return VCSEC_UnknownKeyInfo()
    }
    set {subMessage = .unknownKeyInfo(newValue)}
  }

  var updaterCommand: VCSEC_UpdaterCommand {
    get {
      if case .updaterCommand(let v)? = subMessage {return v}
      return VCSEC_UpdaterCommand()
    }
    set {subMessage = .updaterCommand(newValue)}
  }

  var genealogyRequest: VCSEC_GenealogyRequest_E {
    get {
      if case .genealogyRequest(let v)? = subMessage {return v}
      return .genealogyrequestNone
    }
    set {subMessage = .genealogyRequest(newValue)}
  }

  var sleepManagerRequest: VCSEC_SleepManagerRequest {
    get {
      if case .sleepManagerRequest(let v)? = subMessage {return v}
      return VCSEC_SleepManagerRequest()
    }
    set {subMessage = .sleepManagerRequest(newValue)}
  }

  var imuRequest: VCSEC_IMURequest_E {
    get {
      if case .imuRequest(let v)? = subMessage {return v}
      return .imuRequestNone
    }
    set {subMessage = .imuRequest(newValue)}
  }

  var nfcseRequest: VCSEC_NFCSERequest_E {
    get {
      if case .nfcseRequest(let v)? = subMessage {return v}
      return .nfcseRequestNone
    }
    set {subMessage = .nfcseRequest(newValue)}
  }

  var tpdataRequest: VCSEC_TPDataRequest_E {
    get {
      if case .tpdataRequest(let v)? = subMessage {return v}
      return .tpDatarequestNone
    }
    set {subMessage = .tpdataRequest(newValue)}
  }

  var resetTrackerCommand: VCSEC_ResetTrackerCommand_E {
    get {
      if case .resetTrackerCommand(let v)? = subMessage {return v}
      return .resettrackerCommandNone
    }
    set {subMessage = .resetTrackerCommand(newValue)}
  }

  var tpnotifyTrackerCommand: VCSEC_TPNotifyTrackerCommand_E {
    get {
      if case .tpnotifyTrackerCommand(let v)? = subMessage {return v}
      return .tpNotifytrackerCommandNone
    }
    set {subMessage = .tpnotifyTrackerCommand(newValue)}
  }

  var setTpconfiguration: VCSEC_SetTPConfigration {
    get {
      if case .setTpconfiguration(let v)? = subMessage {return v}
      return VCSEC_SetTPConfigration()
    }
    set {subMessage = .setTpconfiguration(newValue)}
  }

  var unsecureNotification: VCSEC_UnsecureNotification {
    get {
      if case .unsecureNotification(let v)? = subMessage {return v}
      return VCSEC_UnsecureNotification()
    }
    set {subMessage = .unsecureNotification(newValue)}
  }

  var epochSessionInfo: VCSEC_Signatures.SessionInfo {
    get {
      if case .epochSessionInfo(let v)? = subMessage {return v}
      return VCSEC_Signatures.SessionInfo()
    }
    set {subMessage = .epochSessionInfo(newValue)}
  }

  var toRcicommand: VCSEC_ToRCI {
    get {
      if case .toRcicommand(let v)? = subMessage {return v}
      return VCSEC_ToRCI()
    }
    set {subMessage = .toRcicommand(newValue)}
  }

  var rciControl: VCSEC_RCI_control_E {
    get {
      if case .rciControl(let v)? = subMessage {return v}
      return .rciControlNone
    }
    set {subMessage = .rciControl(newValue)}
  }

  var bleconfigCommand: VCSEC_BLEConfigCommand {
    get {
      if case .bleconfigCommand(let v)? = subMessage {return v}
      return VCSEC_BLEConfigCommand()
    }
    set {subMessage = .bleconfigCommand(newValue)}
  }

  var appDeviceInfoRequest: VCSEC_AppDeviceInfoRequest_E {
    get {
      if case .appDeviceInfoRequest(let v)? = subMessage {return v}
      return .appDeviceInfoRequestNone
    }
    set {subMessage = .appDeviceInfoRequest(newValue)}
  }

  var alert: VCSEC_Alert {
    get {
      if case .alert(let v)? = subMessage {return v}
      return VCSEC_Alert()
    }
    set {subMessage = .alert(newValue)}
  }

  var nominalError: VCSEC_NominalError {
    get {
      if case .nominalError(let v)? = subMessage {return v}
      return VCSEC_NominalError()
    }
    set {subMessage = .nominalError(newValue)}
  }

  var misessionRequest: VCSEC_MISessionRequest {
    get {
      if case .misessionRequest(let v)? = subMessage {return v}
      return VCSEC_MISessionRequest()
    }
    set {subMessage = .misessionRequest(newValue)}
  }

  var misessionStop: VCSEC_MISessionStop {
    get {
      if case .misessionStop(let v)? = subMessage {return v}
      return VCSEC_MISessionStop()
    }
    set {subMessage = .misessionStop(newValue)}
  }

  var clearTpmsalarms_p: VCSEC_TPMSAlarms {
    get {
      if case .clearTpmsalarms_p(let v)? = subMessage {return v}
      return VCSEC_TPMSAlarms()
    }
    set {subMessage = .clearTpmsalarms_p(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case vehicleStatus(VCSEC_VehicleStatus)
    case sessionInfo(VCSEC_SessionInfo)
    case authenticationRequest(VCSEC_AuthenticationRequest)
    case commandStatus(VCSEC_CommandStatus)
    case personalizationInformation(VCSEC_PersonalizationInformation)
    case whitelistInfo(VCSEC_WhitelistInfo)
    case whitelistEntryInfo(VCSEC_WhitelistEntryInfo)
    case vehicleInfo(VCSEC_VehicleInfo)
    case capabilities(VCSEC_Capabilities)
    case keyStatusInfo(VCSEC_KeyStatusInfo)
    case activeKey(VCSEC_ActiveKey)
    case unknownKeyInfo(VCSEC_UnknownKeyInfo)
    case updaterCommand(VCSEC_UpdaterCommand)
    case genealogyRequest(VCSEC_GenealogyRequest_E)
    case sleepManagerRequest(VCSEC_SleepManagerRequest)
    case imuRequest(VCSEC_IMURequest_E)
    case nfcseRequest(VCSEC_NFCSERequest_E)
    case tpdataRequest(VCSEC_TPDataRequest_E)
    case resetTrackerCommand(VCSEC_ResetTrackerCommand_E)
    case tpnotifyTrackerCommand(VCSEC_TPNotifyTrackerCommand_E)
    case setTpconfiguration(VCSEC_SetTPConfigration)
    case unsecureNotification(VCSEC_UnsecureNotification)
    case epochSessionInfo(VCSEC_Signatures.SessionInfo)
    case toRcicommand(VCSEC_ToRCI)
    case rciControl(VCSEC_RCI_control_E)
    case bleconfigCommand(VCSEC_BLEConfigCommand)
    case appDeviceInfoRequest(VCSEC_AppDeviceInfoRequest_E)
    case alert(VCSEC_Alert)
    case nominalError(VCSEC_NominalError)
    case misessionRequest(VCSEC_MISessionRequest)
    case misessionStop(VCSEC_MISessionStop)
    case clearTpmsalarms_p(VCSEC_TPMSAlarms)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_FromVCSECMessage.OneOf_SubMessage, rhs: VCSEC_FromVCSECMessage.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.vehicleStatus, .vehicleStatus): return {
        guard case .vehicleStatus(let l) = lhs, case .vehicleStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionInfo, .sessionInfo): return {
        guard case .sessionInfo(let l) = lhs, case .sessionInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.authenticationRequest, .authenticationRequest): return {
        guard case .authenticationRequest(let l) = lhs, case .authenticationRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.commandStatus, .commandStatus): return {
        guard case .commandStatus(let l) = lhs, case .commandStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.personalizationInformation, .personalizationInformation): return {
        guard case .personalizationInformation(let l) = lhs, case .personalizationInformation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whitelistInfo, .whitelistInfo): return {
        guard case .whitelistInfo(let l) = lhs, case .whitelistInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whitelistEntryInfo, .whitelistEntryInfo): return {
        guard case .whitelistEntryInfo(let l) = lhs, case .whitelistEntryInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleInfo, .vehicleInfo): return {
        guard case .vehicleInfo(let l) = lhs, case .vehicleInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.capabilities, .capabilities): return {
        guard case .capabilities(let l) = lhs, case .capabilities(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keyStatusInfo, .keyStatusInfo): return {
        guard case .keyStatusInfo(let l) = lhs, case .keyStatusInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.activeKey, .activeKey): return {
        guard case .activeKey(let l) = lhs, case .activeKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unknownKeyInfo, .unknownKeyInfo): return {
        guard case .unknownKeyInfo(let l) = lhs, case .unknownKeyInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updaterCommand, .updaterCommand): return {
        guard case .updaterCommand(let l) = lhs, case .updaterCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.genealogyRequest, .genealogyRequest): return {
        guard case .genealogyRequest(let l) = lhs, case .genealogyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sleepManagerRequest, .sleepManagerRequest): return {
        guard case .sleepManagerRequest(let l) = lhs, case .sleepManagerRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.imuRequest, .imuRequest): return {
        guard case .imuRequest(let l) = lhs, case .imuRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nfcseRequest, .nfcseRequest): return {
        guard case .nfcseRequest(let l) = lhs, case .nfcseRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpdataRequest, .tpdataRequest): return {
        guard case .tpdataRequest(let l) = lhs, case .tpdataRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resetTrackerCommand, .resetTrackerCommand): return {
        guard case .resetTrackerCommand(let l) = lhs, case .resetTrackerCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpnotifyTrackerCommand, .tpnotifyTrackerCommand): return {
        guard case .tpnotifyTrackerCommand(let l) = lhs, case .tpnotifyTrackerCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setTpconfiguration, .setTpconfiguration): return {
        guard case .setTpconfiguration(let l) = lhs, case .setTpconfiguration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsecureNotification, .unsecureNotification): return {
        guard case .unsecureNotification(let l) = lhs, case .unsecureNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.epochSessionInfo, .epochSessionInfo): return {
        guard case .epochSessionInfo(let l) = lhs, case .epochSessionInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.toRcicommand, .toRcicommand): return {
        guard case .toRcicommand(let l) = lhs, case .toRcicommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rciControl, .rciControl): return {
        guard case .rciControl(let l) = lhs, case .rciControl(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bleconfigCommand, .bleconfigCommand): return {
        guard case .bleconfigCommand(let l) = lhs, case .bleconfigCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appDeviceInfoRequest, .appDeviceInfoRequest): return {
        guard case .appDeviceInfoRequest(let l) = lhs, case .appDeviceInfoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.alert, .alert): return {
        guard case .alert(let l) = lhs, case .alert(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nominalError, .nominalError): return {
        guard case .nominalError(let l) = lhs, case .nominalError(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.misessionRequest, .misessionRequest): return {
        guard case .misessionRequest(let l) = lhs, case .misessionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.misessionStop, .misessionStop): return {
        guard case .misessionStop(let l) = lhs, case .misessionStop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clearTpmsalarms_p, .clearTpmsalarms_p): return {
        guard case .clearTpmsalarms_p(let l) = lhs, case .clearTpmsalarms_p(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VCSEC_Genealogy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serialNumber: Data = Data()

  var partNumber: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_GenealogyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentGenealogy: VCSEC_Genealogy {
    get {return _currentGenealogy ?? VCSEC_Genealogy()}
    set {_currentGenealogy = newValue}
  }
  /// Returns true if `currentGenealogy` has been explicitly set.
  var hasCurrentGenealogy: Bool {return self._currentGenealogy != nil}
  /// Clears the value of `currentGenealogy`. Subsequent reads from it will return its default value.
  mutating func clearCurrentGenealogy() {self._currentGenealogy = nil}

  var status: VCSEC_GenealogyStatus_E = .genealogyStatusNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _currentGenealogy: VCSEC_Genealogy? = nil
}

struct VCSEC_GetCodeDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var location: VCSEC_UpdaterLocation = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_GetReaderKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: VCSEC_GetReaderKeyCommand = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_GetSessionInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyIdentity: VCSEC_KeyIdentity {
    get {return _keyIdentity ?? VCSEC_KeyIdentity()}
    set {_keyIdentity = newValue}
  }
  /// Returns true if `keyIdentity` has been explicitly set.
  var hasKeyIdentity: Bool {return self._keyIdentity != nil}
  /// Clears the value of `keyIdentity`. Subsequent reads from it will return its default value.
  mutating func clearKeyIdentity() {self._keyIdentity = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyIdentity: VCSEC_KeyIdentity? = nil
}

struct VCSEC_HandlePulledWithoutAuthDeviceSpecificPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyChannel: UInt32 {
    get {return _storage._keyChannel}
    set {_uniqueStorage()._keyChannel = newValue}
  }

  var authenticationLevel: VCSEC_AuthenticationLevel_E {
    get {return _storage._authenticationLevel}
    set {_uniqueStorage()._authenticationLevel = newValue}
  }

  var present: Bool {
    get {return _storage._present}
    set {_uniqueStorage()._present = newValue}
  }

  var rssileft: Int32 {
    get {return _storage._rssileft}
    set {_uniqueStorage()._rssileft = newValue}
  }

  var rssiright: Int32 {
    get {return _storage._rssiright}
    set {_uniqueStorage()._rssiright = newValue}
  }

  var rssirear: Int32 {
    get {return _storage._rssirear}
    set {_uniqueStorage()._rssirear = newValue}
  }

  var rssicenter: Int32 {
    get {return _storage._rssicenter}
    set {_uniqueStorage()._rssicenter = newValue}
  }

  var rssifront: Int32 {
    get {return _storage._rssifront}
    set {_uniqueStorage()._rssifront = newValue}
  }

  var rssisecondary: Int32 {
    get {return _storage._rssisecondary}
    set {_uniqueStorage()._rssisecondary = newValue}
  }

  var rssinfccradle: Int32 {
    get {return _storage._rssinfccradle}
    set {_uniqueStorage()._rssinfccradle = newValue}
  }

  var rssirearLeft: Int32 {
    get {return _storage._rssirearLeft}
    set {_uniqueStorage()._rssirearLeft = newValue}
  }

  var rssirearRight: Int32 {
    get {return _storage._rssirearRight}
    set {_uniqueStorage()._rssirearRight = newValue}
  }

  var highThreshLeftPresent: Bool {
    get {return _storage._highThreshLeftPresent}
    set {_uniqueStorage()._highThreshLeftPresent = newValue}
  }

  var highThreshRightPresent: Bool {
    get {return _storage._highThreshRightPresent}
    set {_uniqueStorage()._highThreshRightPresent = newValue}
  }

  var highThreshCenterPresent: Bool {
    get {return _storage._highThreshCenterPresent}
    set {_uniqueStorage()._highThreshCenterPresent = newValue}
  }

  var highThreshFrontPresent: Bool {
    get {return _storage._highThreshFrontPresent}
    set {_uniqueStorage()._highThreshFrontPresent = newValue}
  }

  var highThreshRearPresent: Bool {
    get {return _storage._highThreshRearPresent}
    set {_uniqueStorage()._highThreshRearPresent = newValue}
  }

  var highThreshRearLeftPresent: Bool {
    get {return _storage._highThreshRearLeftPresent}
    set {_uniqueStorage()._highThreshRearLeftPresent = newValue}
  }

  var highThreshRearRightPresent: Bool {
    get {return _storage._highThreshRearRightPresent}
    set {_uniqueStorage()._highThreshRearRightPresent = newValue}
  }

  var highThreshSecondaryPresent: Bool {
    get {return _storage._highThreshSecondaryPresent}
    set {_uniqueStorage()._highThreshSecondaryPresent = newValue}
  }

  var highThreshNfcpresent: Bool {
    get {return _storage._highThreshNfcpresent}
    set {_uniqueStorage()._highThreshNfcpresent = newValue}
  }

  var sortedDeltaBayesLeftPresent: Bool {
    get {return _storage._sortedDeltaBayesLeftPresent}
    set {_uniqueStorage()._sortedDeltaBayesLeftPresent = newValue}
  }

  var sortedDeltaBayesRightPresent: Bool {
    get {return _storage._sortedDeltaBayesRightPresent}
    set {_uniqueStorage()._sortedDeltaBayesRightPresent = newValue}
  }

  var rawDeltaBayesLeftPresent: Bool {
    get {return _storage._rawDeltaBayesLeftPresent}
    set {_uniqueStorage()._rawDeltaBayesLeftPresent = newValue}
  }

  var rawDeltaBayesRightPresent: Bool {
    get {return _storage._rawDeltaBayesRightPresent}
    set {_uniqueStorage()._rawDeltaBayesRightPresent = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct VCSEC_InformationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var informationRequestType: VCSEC_InformationRequestType = .getStatus

  var subMessage: VCSEC_InformationRequest.OneOf_SubMessage? = nil

  var keyID: VCSEC_KeyIdentifier {
    get {
      if case .keyID(let v)? = subMessage {return v}
      return VCSEC_KeyIdentifier()
    }
    set {subMessage = .keyID(newValue)}
  }

  var publicKey: Data {
    get {
      if case .publicKey(let v)? = subMessage {return v}
      return Data()
    }
    set {subMessage = .publicKey(newValue)}
  }

  var slot: UInt32 {
    get {
      if case .slot(let v)? = subMessage {return v}
      return 0
    }
    set {subMessage = .slot(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case keyID(VCSEC_KeyIdentifier)
    case publicKey(Data)
    case slot(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_InformationRequest.OneOf_SubMessage, rhs: VCSEC_InformationRequest.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.keyID, .keyID): return {
        guard case .keyID(let l) = lhs, case .keyID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publicKey, .publicKey): return {
        guard case .publicKey(let l) = lhs, case .publicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.slot, .slot): return {
        guard case .slot(let l) = lhs, case .slot(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VCSEC_KeyfobInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appCrc: Data = Data()

  var batteryVoltageMV: UInt32 = 0

  var temperatureDegreesC: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_KeyIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKeySha1: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_KeyIdentity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: VCSEC_KeyIdentity.OneOf_SubMessage? = nil

  var publicKey: Data {
    get {
      if case .publicKey(let v)? = subMessage {return v}
      return Data()
    }
    set {subMessage = .publicKey(newValue)}
  }

  var keyID: Data {
    get {
      if case .keyID(let v)? = subMessage {return v}
      return Data()
    }
    set {subMessage = .keyID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case publicKey(Data)
    case keyID(Data)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_KeyIdentity.OneOf_SubMessage, rhs: VCSEC_KeyIdentity.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.publicKey, .publicKey): return {
        guard case .publicKey(let l) = lhs, case .publicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keyID, .keyID): return {
        guard case .keyID(let l) = lhs, case .keyID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VCSEC_KeyMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyFormFactor: VCSEC_KeyFormFactor = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_KeyStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyID: VCSEC_KeyIdentifier {
    get {return _keyID ?? VCSEC_KeyIdentifier()}
    set {_keyID = newValue}
  }
  /// Returns true if `keyID` has been explicitly set.
  var hasKeyID: Bool {return self._keyID != nil}
  /// Clears the value of `keyID`. Subsequent reads from it will return its default value.
  mutating func clearKeyID() {self._keyID = nil}

  var nfcPresence: VCSEC_NFCPresence = .notPresent

  var blePresence: VCSEC_BLEPresence = .notPresent

  var publicKey: VCSEC_PublicKey {
    get {return _publicKey ?? VCSEC_PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var keyFormFactor: VCSEC_KeyFormFactor = .unknown

  var slot: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyID: VCSEC_KeyIdentifier? = nil
  fileprivate var _publicKey: VCSEC_PublicKey? = nil
}

struct VCSEC_KeyStatusInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyStatuses: [VCSEC_KeyStatus] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_MIConfigurationData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data_: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_MISessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: UInt32 = 0

  var accessoryConfigurationData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_MISessionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: UInt32 = 0

  var subMessage: VCSEC_MISessionResponse.OneOf_SubMessage? = nil

  var miconfigurationData: VCSEC_MIConfigurationData {
    get {
      if case .miconfigurationData(let v)? = subMessage {return v}
      return VCSEC_MIConfigurationData()
    }
    set {subMessage = .miconfigurationData(newValue)}
  }

  var errorCode: VCSEC_MIError_E {
    get {
      if case .errorCode(let v)? = subMessage {return v}
      return .errorUnknown
    }
    set {subMessage = .errorCode(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case miconfigurationData(VCSEC_MIConfigurationData)
    case errorCode(VCSEC_MIError_E)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_MISessionResponse.OneOf_SubMessage, rhs: VCSEC_MISessionResponse.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.miconfigurationData, .miconfigurationData): return {
        guard case .miconfigurationData(let l) = lhs, case .miconfigurationData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.errorCode, .errorCode): return {
        guard case .errorCode(let l) = lhs, case .errorCode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VCSEC_MISessionStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: VCSEC_MISessionStop.OneOf_SubMessage? = nil

  var sessionID: UInt32 {
    get {
      if case .sessionID(let v)? = subMessage {return v}
      return 0
    }
    set {subMessage = .sessionID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case sessionID(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_MISessionStop.OneOf_SubMessage, rhs: VCSEC_MISessionStop.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sessionID, .sessionID): return {
        guard case .sessionID(let l) = lhs, case .sessionID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

struct VCSEC_MISessionStopped {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: VCSEC_MISessionStopped.OneOf_SubMessage? = nil

  var sessionID: UInt32 {
    get {
      if case .sessionID(let v)? = subMessage {return v}
      return 0
    }
    set {subMessage = .sessionID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case sessionID(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_MISessionStopped.OneOf_SubMessage, rhs: VCSEC_MISessionStopped.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sessionID, .sessionID): return {
        guard case .sessionID(let l) = lhs, case .sessionID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

struct VCSEC_NFCSEState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var devicePubKeyState: VCSEC_NFCSEDevicePubKeyState_E = .nfcsecDevicepubkeyStateNone

  var vehiclePubKeyState: VCSEC_NFCSEVehiclePubKeyState_E = .nfcsecVehiclepubkeyStateNone

  var sharedSecretState: VCSEC_NFCSESharedSecretState_E = .nfcsecSharedsecretStateNone

  var insecureCommandState: VCSEC_NFCSEInsecureCommandState_E = .nfcsecInsecureCommandStateNone

  var vehiclePubKey: VCSEC_PublicKey {
    get {return _vehiclePubKey ?? VCSEC_PublicKey()}
    set {_vehiclePubKey = newValue}
  }
  /// Returns true if `vehiclePubKey` has been explicitly set.
  var hasVehiclePubKey: Bool {return self._vehiclePubKey != nil}
  /// Clears the value of `vehiclePubKey`. Subsequent reads from it will return its default value.
  mutating func clearVehiclePubKey() {self._vehiclePubKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _vehiclePubKey: VCSEC_PublicKey? = nil
}

struct VCSEC_NominalError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var genericError: VCSEC_GenericError_E = .genericerrorNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_PermissionChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: VCSEC_PublicKey {
    get {return _key ?? VCSEC_PublicKey()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var permission: [VCSEC_WhitelistKeyPermission_E] = []

  var secondsToBeActive: UInt32 = 0

  var keyRole: VCSEC_Role = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: VCSEC_PublicKey? = nil
}

struct VCSEC_PersonalizationInformation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vin: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_PublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKeyRaw: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_RCISignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: Data = Data()

  var tag: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_ReplaceKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyToAdd: VCSEC_PublicKey {
    get {return _keyToAdd ?? VCSEC_PublicKey()}
    set {_keyToAdd = newValue}
  }
  /// Returns true if `keyToAdd` has been explicitly set.
  var hasKeyToAdd: Bool {return self._keyToAdd != nil}
  /// Clears the value of `keyToAdd`. Subsequent reads from it will return its default value.
  mutating func clearKeyToAdd() {self._keyToAdd = nil}

  var keyRole: VCSEC_Role = .none

  var impermanent: Bool = false

  var subMessage: VCSEC_ReplaceKey.OneOf_SubMessage? = nil

  var publicKeyToReplace: VCSEC_PublicKey {
    get {
      if case .publicKeyToReplace(let v)? = subMessage {return v}
      return VCSEC_PublicKey()
    }
    set {subMessage = .publicKeyToReplace(newValue)}
  }

  var slotToReplace: UInt32 {
    get {
      if case .slotToReplace(let v)? = subMessage {return v}
      return 0
    }
    set {subMessage = .slotToReplace(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case publicKeyToReplace(VCSEC_PublicKey)
    case slotToReplace(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_ReplaceKey.OneOf_SubMessage, rhs: VCSEC_ReplaceKey.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.publicKeyToReplace, .publicKeyToReplace): return {
        guard case .publicKeyToReplace(let l) = lhs, case .publicKeyToReplace(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.slotToReplace, .slotToReplace): return {
        guard case .slotToReplace(let l) = lhs, case .slotToReplace(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _keyToAdd: VCSEC_PublicKey? = nil
}

struct VCSEC_ResetTrackerStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totalResetsDueToPowerOn: UInt32 = 0

  var totalResetsDueToPinReset: UInt32 = 0

  var totalResetsDueToVddsloss: UInt32 = 0

  var totalResetsDueToVddloss: UInt32 = 0

  var totalResetsDueToVddrloss: UInt32 = 0

  var totalResetsDueToClockLoss: UInt32 = 0

  var totalResetsDueToSystemReset: UInt32 = 0

  var totalResetsDueToWarmReset: UInt32 = 0

  var totalResetsDueToWakeupFromShutdown: UInt32 = 0

  var totalResetsDueToWakeupFromTcknoise: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_SessionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: Data = Data()

  var counter: UInt32 = 0

  var publicKey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_SetTPConfigration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stationaryConfig: VCSEC_TPStationaryConfig {
    get {return _stationaryConfig ?? VCSEC_TPStationaryConfig()}
    set {_stationaryConfig = newValue}
  }
  /// Returns true if `stationaryConfig` has been explicitly set.
  var hasStationaryConfig: Bool {return self._stationaryConfig != nil}
  /// Clears the value of `stationaryConfig`. Subsequent reads from it will return its default value.
  mutating func clearStationaryConfig() {self._stationaryConfig = nil}

  var motionConfig: VCSEC_TPMotionConfig {
    get {return _motionConfig ?? VCSEC_TPMotionConfig()}
    set {_motionConfig = newValue}
  }
  /// Returns true if `motionConfig` has been explicitly set.
  var hasMotionConfig: Bool {return self._motionConfig != nil}
  /// Clears the value of `motionConfig`. Subsequent reads from it will return its default value.
  mutating func clearMotionConfig() {self._motionConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stationaryConfig: VCSEC_TPStationaryConfig? = nil
  fileprivate var _motionConfig: VCSEC_TPMotionConfig? = nil
}

struct VCSEC_SetUpdaterLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterLocation: VCSEC_UpdaterLocation = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_Signatures {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct SessionInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var counter: UInt32 = 0

    var publicKey: Data = Data()

    var epoch: Data = Data()

    var clockTime: UInt32 = 0

    var status: VCSEC_Session_Info_Status = .ok

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct VCSEC_SignedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: Data = Data()

  var protobufMessageAsBytes: Data = Data()

  var signatureType: VCSEC_SignatureType = .aesGcm

  var signature: Data = Data()

  var keyID: Data = Data()

  var counter: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_SignedMessage_status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var counter: UInt32 = 0

  var signedMessageInformation: VCSEC_SignedMessage_information_E = .signedmessageInformationNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_SleepManagerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: VCSEC_SleepManagerRequest.OneOf_SubMessage? = nil

  var delaySleepRequest: VCSEC_DelaySleepRequest {
    get {
      if case .delaySleepRequest(let v)? = subMessage {return v}
      return VCSEC_DelaySleepRequest()
    }
    set {subMessage = .delaySleepRequest(newValue)}
  }

  var sleepManagerCommand: VCSEC_SleepManagerCommand_E {
    get {
      if case .sleepManagerCommand(let v)? = subMessage {return v}
      return .sleepmanagerCommandNone
    }
    set {subMessage = .sleepManagerCommand(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case delaySleepRequest(VCSEC_DelaySleepRequest)
    case sleepManagerCommand(VCSEC_SleepManagerCommand_E)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_SleepManagerRequest.OneOf_SubMessage, rhs: VCSEC_SleepManagerRequest.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.delaySleepRequest, .delaySleepRequest): return {
        guard case .delaySleepRequest(let l) = lhs, case .delaySleepRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sleepManagerCommand, .sleepManagerCommand): return {
        guard case .sleepManagerCommand(let l) = lhs, case .sleepManagerCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VCSEC_SleepManagerStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totalCputime: UInt32 = 0

  var totalAwakeTime: UInt32 = 0

  var isBletrimApplied: VCSEC_BLEAdditionalTRIMApplied_E = .bleAdditionalTrimAppliedNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_StageBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockAddress: UInt32 = 0

  var blockToStage: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_ToRCI {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: Data = Data()

  var subMessage: VCSEC_ToRCI.OneOf_SubMessage? = nil

  var hmacSignature: Data {
    get {
      if case .hmacSignature(let v)? = subMessage {return v}
      return Data()
    }
    set {subMessage = .hmacSignature(newValue)}
  }

  var rciSignature: VCSEC_RCISignature {
    get {
      if case .rciSignature(let v)? = subMessage {return v}
      return VCSEC_RCISignature()
    }
    set {subMessage = .rciSignature(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case hmacSignature(Data)
    case rciSignature(VCSEC_RCISignature)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_ToRCI.OneOf_SubMessage, rhs: VCSEC_ToRCI.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hmacSignature, .hmacSignature): return {
        guard case .hmacSignature(let l) = lhs, case .hmacSignature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rciSignature, .rciSignature): return {
        guard case .rciSignature(let l) = lhs, case .rciSignature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VCSEC_ToVCSECMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: VCSEC_ToVCSECMessage.OneOf_SubMessage? = nil

  var signedMessage: VCSEC_SignedMessage {
    get {
      if case .signedMessage(let v)? = subMessage {return v}
      return VCSEC_SignedMessage()
    }
    set {subMessage = .signedMessage(newValue)}
  }

  var unsignedMessage: VCSEC_UnsignedMessage {
    get {
      if case .unsignedMessage(let v)? = subMessage {return v}
      return VCSEC_UnsignedMessage()
    }
    set {subMessage = .unsignedMessage(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case signedMessage(VCSEC_SignedMessage)
    case unsignedMessage(VCSEC_UnsignedMessage)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_ToVCSECMessage.OneOf_SubMessage, rhs: VCSEC_ToVCSECMessage.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.signedMessage, .signedMessage): return {
        guard case .signedMessage(let l) = lhs, case .signedMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsignedMessage, .unsignedMessage): return {
        guard case .unsignedMessage(let l) = lhs, case .unsignedMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VCSEC_TPAdv {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pressure: Int32 = 0

  var temperature: Int32 = 0

  var tpnotifyReason: VCSEC_TPNotifyReason_E = .tpNotifyReasonUnknown

  var batteryVoltageMV: UInt32 = 0

  var advertismentCount: UInt32 = 0

  var tpmsadvType: VCSEC_TPMSAdvType_E = .tpmsAdvTypeSemi

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_TPData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pressure: Int32 = 0

  var temperature: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_TPLRDetection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lrdetectionResult: VCSEC_LRDetectionResult_E = .rrorMaxcnt

  var totalPeriodMs: UInt32 = 0

  var x90DegCnt: UInt32 = 0

  var x270DegCnt: UInt32 = 0

  var zAccelerationDg: Int32 = 0

  var zAccelDiffCnt: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_TPMotionConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pressureDelta: UInt32 = 0

  var temperatureDelta: UInt32 = 0

  var ptmeasurePeriod: VCSEC_MLXWakePeriod_E = .mlxwakeperiod2Ms

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_TPMSAlarms {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pressure: Bool = false

  var temperature: Bool = false

  var acceleration: Bool = false

  var voltage: Bool = false

  var lfdetect: Bool = false

  var wheelMotion: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_TPNewSensorData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sensorPublicKey: VCSEC_PublicKey {
    get {return _sensorPublicKey ?? VCSEC_PublicKey()}
    set {_sensorPublicKey = newValue}
  }
  /// Returns true if `sensorPublicKey` has been explicitly set.
  var hasSensorPublicKey: Bool {return self._sensorPublicKey != nil}
  /// Clears the value of `sensorPublicKey`. Subsequent reads from it will return its default value.
  mutating func clearSensorPublicKey() {self._sensorPublicKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sensorPublicKey: VCSEC_PublicKey? = nil
}

struct VCSEC_TPNotifyTrackerStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var notifyReasonUnknownCount: UInt32 = 0

  var notifyReasonLowPressureCount: UInt32 = 0

  var notifyReasonPtvalueUpdateCount: UInt32 = 0

  var notifyReasonWheelMovingCount: UInt32 = 0

  var notifyReasonWheelRotationDirectionReadyCount: UInt32 = 0

  var notifyReasonLfcount: UInt32 = 0

  var notifyReasonFaultCount: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_TPStationaryConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lowPressureThreshold: UInt32 = 0

  var pressureDelta: UInt32 = 0

  var accelMeasurePeriod: VCSEC_MLXWakePeriod_E = .mlxwakeperiod2Ms

  var absoluteAccelWakeThreshold: Int32 = 0

  var ptmeasureMod: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_TPWheelUnitInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tiappCrc: Data = Data()

  var mlxappCrc: Data = Data()

  var batteryVoltageMV: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_UnknownKeyInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyStatus: VCSEC_KeyStatus {
    get {return _keyStatus ?? VCSEC_KeyStatus()}
    set {_keyStatus = newValue}
  }
  /// Returns true if `keyStatus` has been explicitly set.
  var hasKeyStatus: Bool {return self._keyStatus != nil}
  /// Clears the value of `keyStatus`. Subsequent reads from it will return its default value.
  mutating func clearKeyStatus() {self._keyStatus = nil}

  var publicKey: VCSEC_PublicKey {
    get {return _publicKey ?? VCSEC_PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var keyFormFactor: VCSEC_KeyFormFactor = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyStatus: VCSEC_KeyStatus? = nil
  fileprivate var _publicKey: VCSEC_PublicKey? = nil
}

struct VCSEC_UnsecureNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var notifyUser: Bool = false

  var closureStatuses: VCSEC_ClosureStatuses {
    get {return _closureStatuses ?? VCSEC_ClosureStatuses()}
    set {_closureStatuses = newValue}
  }
  /// Returns true if `closureStatuses` has been explicitly set.
  var hasClosureStatuses: Bool {return self._closureStatuses != nil}
  /// Clears the value of `closureStatuses`. Subsequent reads from it will return its default value.
  mutating func clearClosureStatuses() {self._closureStatuses = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _closureStatuses: VCSEC_ClosureStatuses? = nil
}

struct VCSEC_UnsignedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var personalizationInformation: VCSEC_PersonalizationInformation {
    get {return _personalizationInformation ?? VCSEC_PersonalizationInformation()}
    set {_personalizationInformation = newValue}
  }
  /// Returns true if `personalizationInformation` has been explicitly set.
  var hasPersonalizationInformation: Bool {return self._personalizationInformation != nil}
  /// Clears the value of `personalizationInformation`. Subsequent reads from it will return its default value.
  mutating func clearPersonalizationInformation() {self._personalizationInformation = nil}

  var subMessage: VCSEC_UnsignedMessage.OneOf_SubMessage? = nil

  var informationRequest: VCSEC_InformationRequest {
    get {
      if case .informationRequest(let v)? = subMessage {return v}
      return VCSEC_InformationRequest()
    }
    set {subMessage = .informationRequest(newValue)}
  }

  var rkeaction: VCSEC_RKEAction_E {
    get {
      if case .rkeaction(let v)? = subMessage {return v}
      return .rkeActionUnlock
    }
    set {subMessage = .rkeaction(newValue)}
  }

  var authenticationResponse: VCSEC_AuthenticationResponse {
    get {
      if case .authenticationResponse(let v)? = subMessage {return v}
      return VCSEC_AuthenticationResponse()
    }
    set {subMessage = .authenticationResponse(newValue)}
  }

  var closureMoveRequest: VCSEC_ClosureMoveRequest {
    get {
      if case .closureMoveRequest(let v)? = subMessage {return v}
      return VCSEC_ClosureMoveRequest()
    }
    set {subMessage = .closureMoveRequest(newValue)}
  }

  var tpadv: VCSEC_TPAdv {
    get {
      if case .tpadv(let v)? = subMessage {return v}
      return VCSEC_TPAdv()
    }
    set {subMessage = .tpadv(newValue)}
  }

  var whitelistOperation: VCSEC_WhitelistOperation {
    get {
      if case .whitelistOperation(let v)? = subMessage {return v}
      return VCSEC_WhitelistOperation()
    }
    set {subMessage = .whitelistOperation(newValue)}
  }

  var updaterResponse: VCSEC_UpdaterResponse {
    get {
      if case .updaterResponse(let v)? = subMessage {return v}
      return VCSEC_UpdaterResponse()
    }
    set {subMessage = .updaterResponse(newValue)}
  }

  var genealogyResponse: VCSEC_GenealogyResponse {
    get {
      if case .genealogyResponse(let v)? = subMessage {return v}
      return VCSEC_GenealogyResponse()
    }
    set {subMessage = .genealogyResponse(newValue)}
  }

  var setMetaDataForKey: VCSEC_KeyMetadata {
    get {
      if case .setMetaDataForKey(let v)? = subMessage {return v}
      return VCSEC_KeyMetadata()
    }
    set {subMessage = .setMetaDataForKey(newValue)}
  }

  var keyfobInfo: VCSEC_KeyfobInfo {
    get {
      if case .keyfobInfo(let v)? = subMessage {return v}
      return VCSEC_KeyfobInfo()
    }
    set {subMessage = .keyfobInfo(newValue)}
  }

  var imustate: VCSEC_IMUState_E {
    get {
      if case .imustate(let v)? = subMessage {return v}
      return .imuStateNotConfigured
    }
    set {subMessage = .imustate(newValue)}
  }

  var nfcseState: VCSEC_NFCSEState {
    get {
      if case .nfcseState(let v)? = subMessage {return v}
      return VCSEC_NFCSEState()
    }
    set {subMessage = .nfcseState(newValue)}
  }

  var lowPowerDeviceSleepManagerStats: VCSEC_SleepManagerStats {
    get {
      if case .lowPowerDeviceSleepManagerStats(let v)? = subMessage {return v}
      return VCSEC_SleepManagerStats()
    }
    set {subMessage = .lowPowerDeviceSleepManagerStats(newValue)}
  }

  var tpdata: VCSEC_TPData {
    get {
      if case .tpdata(let v)? = subMessage {return v}
      return VCSEC_TPData()
    }
    set {subMessage = .tpdata(newValue)}
  }

  var tpwheelUnitInfo: VCSEC_TPWheelUnitInfo {
    get {
      if case .tpwheelUnitInfo(let v)? = subMessage {return v}
      return VCSEC_TPWheelUnitInfo()
    }
    set {subMessage = .tpwheelUnitInfo(newValue)}
  }

  var resetTrackerStats: VCSEC_ResetTrackerStats {
    get {
      if case .resetTrackerStats(let v)? = subMessage {return v}
      return VCSEC_ResetTrackerStats()
    }
    set {subMessage = .resetTrackerStats(newValue)}
  }

  var tpnotifyTrackerStats: VCSEC_TPNotifyTrackerStats {
    get {
      if case .tpnotifyTrackerStats(let v)? = subMessage {return v}
      return VCSEC_TPNotifyTrackerStats()
    }
    set {subMessage = .tpnotifyTrackerStats(newValue)}
  }

  var tpnewSensorData: VCSEC_TPNewSensorData {
    get {
      if case .tpnewSensorData(let v)? = subMessage {return v}
      return VCSEC_TPNewSensorData()
    }
    set {subMessage = .tpnewSensorData(newValue)}
  }

  var tplrdetection: VCSEC_TPLRDetection {
    get {
      if case .tplrdetection(let v)? = subMessage {return v}
      return VCSEC_TPLRDetection()
    }
    set {subMessage = .tplrdetection(newValue)}
  }

  var connectionMetrics: VCSEC_ConnectionMetrics {
    get {
      if case .connectionMetrics(let v)? = subMessage {return v}
      return VCSEC_ConnectionMetrics()
    }
    set {subMessage = .connectionMetrics(newValue)}
  }

  var deviceActivity: VCSEC_Activity_E {
    get {
      if case .deviceActivity(let v)? = subMessage {return v}
      return .activityNone
    }
    set {subMessage = .deviceActivity(newValue)}
  }

  var getEpochSessionInfo: VCSEC_GetSessionInfoRequest {
    get {
      if case .getEpochSessionInfo(let v)? = subMessage {return v}
      return VCSEC_GetSessionInfoRequest()
    }
    set {subMessage = .getEpochSessionInfo(newValue)}
  }

  var fromRciresponse: VCSEC_FromRCI {
    get {
      if case .fromRciresponse(let v)? = subMessage {return v}
      return VCSEC_FromRCI()
    }
    set {subMessage = .fromRciresponse(newValue)}
  }

  var bleconfigAll: VCSEC_BLEConfigAll {
    get {
      if case .bleconfigAll(let v)? = subMessage {return v}
      return VCSEC_BLEConfigAll()
    }
    set {subMessage = .bleconfigAll(newValue)}
  }

  var deviceMotion: VCSEC_DeviceMotion {
    get {
      if case .deviceMotion(let v)? = subMessage {return v}
      return VCSEC_DeviceMotion()
    }
    set {subMessage = .deviceMotion(newValue)}
  }

  var appDeviceInfo: VCSEC_AppDeviceInfo {
    get {
      if case .appDeviceInfo(let v)? = subMessage {return v}
      return VCSEC_AppDeviceInfo()
    }
    set {subMessage = .appDeviceInfo(newValue)}
  }

  var getReaderKey: VCSEC_GetReaderKey {
    get {
      if case .getReaderKey(let v)? = subMessage {return v}
      return VCSEC_GetReaderKey()
    }
    set {subMessage = .getReaderKey(newValue)}
  }

  var misessionResponse: VCSEC_MISessionResponse {
    get {
      if case .misessionResponse(let v)? = subMessage {return v}
      return VCSEC_MISessionResponse()
    }
    set {subMessage = .misessionResponse(newValue)}
  }

  var misessionStopped: VCSEC_MISessionStopped {
    get {
      if case .misessionStopped(let v)? = subMessage {return v}
      return VCSEC_MISessionStopped()
    }
    set {subMessage = .misessionStopped(newValue)}
  }

  var accelData: VCSEC_AccelData {
    get {
      if case .accelData(let v)? = subMessage {return v}
      return VCSEC_AccelData()
    }
    set {subMessage = .accelData(newValue)}
  }

  var tpmsalarms: VCSEC_TPMSAlarms {
    get {
      if case .tpmsalarms(let v)? = subMessage {return v}
      return VCSEC_TPMSAlarms()
    }
    set {subMessage = .tpmsalarms(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case informationRequest(VCSEC_InformationRequest)
    case rkeaction(VCSEC_RKEAction_E)
    case authenticationResponse(VCSEC_AuthenticationResponse)
    case closureMoveRequest(VCSEC_ClosureMoveRequest)
    case tpadv(VCSEC_TPAdv)
    case whitelistOperation(VCSEC_WhitelistOperation)
    case updaterResponse(VCSEC_UpdaterResponse)
    case genealogyResponse(VCSEC_GenealogyResponse)
    case setMetaDataForKey(VCSEC_KeyMetadata)
    case keyfobInfo(VCSEC_KeyfobInfo)
    case imustate(VCSEC_IMUState_E)
    case nfcseState(VCSEC_NFCSEState)
    case lowPowerDeviceSleepManagerStats(VCSEC_SleepManagerStats)
    case tpdata(VCSEC_TPData)
    case tpwheelUnitInfo(VCSEC_TPWheelUnitInfo)
    case resetTrackerStats(VCSEC_ResetTrackerStats)
    case tpnotifyTrackerStats(VCSEC_TPNotifyTrackerStats)
    case tpnewSensorData(VCSEC_TPNewSensorData)
    case tplrdetection(VCSEC_TPLRDetection)
    case connectionMetrics(VCSEC_ConnectionMetrics)
    case deviceActivity(VCSEC_Activity_E)
    case getEpochSessionInfo(VCSEC_GetSessionInfoRequest)
    case fromRciresponse(VCSEC_FromRCI)
    case bleconfigAll(VCSEC_BLEConfigAll)
    case deviceMotion(VCSEC_DeviceMotion)
    case appDeviceInfo(VCSEC_AppDeviceInfo)
    case getReaderKey(VCSEC_GetReaderKey)
    case misessionResponse(VCSEC_MISessionResponse)
    case misessionStopped(VCSEC_MISessionStopped)
    case accelData(VCSEC_AccelData)
    case tpmsalarms(VCSEC_TPMSAlarms)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_UnsignedMessage.OneOf_SubMessage, rhs: VCSEC_UnsignedMessage.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.informationRequest, .informationRequest): return {
        guard case .informationRequest(let l) = lhs, case .informationRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rkeaction, .rkeaction): return {
        guard case .rkeaction(let l) = lhs, case .rkeaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.authenticationResponse, .authenticationResponse): return {
        guard case .authenticationResponse(let l) = lhs, case .authenticationResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.closureMoveRequest, .closureMoveRequest): return {
        guard case .closureMoveRequest(let l) = lhs, case .closureMoveRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpadv, .tpadv): return {
        guard case .tpadv(let l) = lhs, case .tpadv(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whitelistOperation, .whitelistOperation): return {
        guard case .whitelistOperation(let l) = lhs, case .whitelistOperation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updaterResponse, .updaterResponse): return {
        guard case .updaterResponse(let l) = lhs, case .updaterResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.genealogyResponse, .genealogyResponse): return {
        guard case .genealogyResponse(let l) = lhs, case .genealogyResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setMetaDataForKey, .setMetaDataForKey): return {
        guard case .setMetaDataForKey(let l) = lhs, case .setMetaDataForKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keyfobInfo, .keyfobInfo): return {
        guard case .keyfobInfo(let l) = lhs, case .keyfobInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.imustate, .imustate): return {
        guard case .imustate(let l) = lhs, case .imustate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nfcseState, .nfcseState): return {
        guard case .nfcseState(let l) = lhs, case .nfcseState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lowPowerDeviceSleepManagerStats, .lowPowerDeviceSleepManagerStats): return {
        guard case .lowPowerDeviceSleepManagerStats(let l) = lhs, case .lowPowerDeviceSleepManagerStats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpdata, .tpdata): return {
        guard case .tpdata(let l) = lhs, case .tpdata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpwheelUnitInfo, .tpwheelUnitInfo): return {
        guard case .tpwheelUnitInfo(let l) = lhs, case .tpwheelUnitInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resetTrackerStats, .resetTrackerStats): return {
        guard case .resetTrackerStats(let l) = lhs, case .resetTrackerStats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpnotifyTrackerStats, .tpnotifyTrackerStats): return {
        guard case .tpnotifyTrackerStats(let l) = lhs, case .tpnotifyTrackerStats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpnewSensorData, .tpnewSensorData): return {
        guard case .tpnewSensorData(let l) = lhs, case .tpnewSensorData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tplrdetection, .tplrdetection): return {
        guard case .tplrdetection(let l) = lhs, case .tplrdetection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.connectionMetrics, .connectionMetrics): return {
        guard case .connectionMetrics(let l) = lhs, case .connectionMetrics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deviceActivity, .deviceActivity): return {
        guard case .deviceActivity(let l) = lhs, case .deviceActivity(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getEpochSessionInfo, .getEpochSessionInfo): return {
        guard case .getEpochSessionInfo(let l) = lhs, case .getEpochSessionInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fromRciresponse, .fromRciresponse): return {
        guard case .fromRciresponse(let l) = lhs, case .fromRciresponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bleconfigAll, .bleconfigAll): return {
        guard case .bleconfigAll(let l) = lhs, case .bleconfigAll(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deviceMotion, .deviceMotion): return {
        guard case .deviceMotion(let l) = lhs, case .deviceMotion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appDeviceInfo, .appDeviceInfo): return {
        guard case .appDeviceInfo(let l) = lhs, case .appDeviceInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getReaderKey, .getReaderKey): return {
        guard case .getReaderKey(let l) = lhs, case .getReaderKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.misessionResponse, .misessionResponse): return {
        guard case .misessionResponse(let l) = lhs, case .misessionResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.misessionStopped, .misessionStopped): return {
        guard case .misessionStopped(let l) = lhs, case .misessionStopped(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accelData, .accelData): return {
        guard case .accelData(let l) = lhs, case .accelData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpmsalarms, .tpmsalarms): return {
        guard case .tpmsalarms(let l) = lhs, case .tpmsalarms(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _personalizationInformation: VCSEC_PersonalizationInformation? = nil
}

struct VCSEC_UpdaterCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: VCSEC_UpdaterCommand.OneOf_SubMessage? = nil

  var getCodeDescriptor: VCSEC_GetCodeDescriptor {
    get {
      if case .getCodeDescriptor(let v)? = subMessage {return v}
      return VCSEC_GetCodeDescriptor()
    }
    set {subMessage = .getCodeDescriptor(newValue)}
  }

  var setUpdaterLocation: VCSEC_SetUpdaterLocation {
    get {
      if case .setUpdaterLocation(let v)? = subMessage {return v}
      return VCSEC_SetUpdaterLocation()
    }
    set {subMessage = .setUpdaterLocation(newValue)}
  }

  var stageBlock: VCSEC_StageBlock {
    get {
      if case .stageBlock(let v)? = subMessage {return v}
      return VCSEC_StageBlock()
    }
    set {subMessage = .stageBlock(newValue)}
  }

  var verifyAndInstallApp: VCSEC_VerifyAndInstallApp {
    get {
      if case .verifyAndInstallApp(let v)? = subMessage {return v}
      return VCSEC_VerifyAndInstallApp()
    }
    set {subMessage = .verifyAndInstallApp(newValue)}
  }

  var firmwareInfo: Data {
    get {
      if case .firmwareInfo(let v)? = subMessage {return v}
      return Data()
    }
    set {subMessage = .firmwareInfo(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case getCodeDescriptor(VCSEC_GetCodeDescriptor)
    case setUpdaterLocation(VCSEC_SetUpdaterLocation)
    case stageBlock(VCSEC_StageBlock)
    case verifyAndInstallApp(VCSEC_VerifyAndInstallApp)
    case firmwareInfo(Data)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_UpdaterCommand.OneOf_SubMessage, rhs: VCSEC_UpdaterCommand.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getCodeDescriptor, .getCodeDescriptor): return {
        guard case .getCodeDescriptor(let l) = lhs, case .getCodeDescriptor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setUpdaterLocation, .setUpdaterLocation): return {
        guard case .setUpdaterLocation(let l) = lhs, case .setUpdaterLocation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stageBlock, .stageBlock): return {
        guard case .stageBlock(let l) = lhs, case .stageBlock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.verifyAndInstallApp, .verifyAndInstallApp): return {
        guard case .verifyAndInstallApp(let l) = lhs, case .verifyAndInstallApp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.firmwareInfo, .firmwareInfo): return {
        guard case .firmwareInfo(let l) = lhs, case .firmwareInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VCSEC_UpdaterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: VCSEC_UpdaterResponse.OneOf_SubMessage? = nil

  var codeDescriptorMessage: VCSEC_CodeDescriptor {
    get {
      if case .codeDescriptorMessage(let v)? = subMessage {return v}
      return VCSEC_CodeDescriptor()
    }
    set {subMessage = .codeDescriptorMessage(newValue)}
  }

  var updaterStatus: VCSEC_UpdaterStatus {
    get {
      if case .updaterStatus(let v)? = subMessage {return v}
      return VCSEC_UpdaterStatus()
    }
    set {subMessage = .updaterStatus(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case codeDescriptorMessage(VCSEC_CodeDescriptor)
    case updaterStatus(VCSEC_UpdaterStatus)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_UpdaterResponse.OneOf_SubMessage, rhs: VCSEC_UpdaterResponse.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.codeDescriptorMessage, .codeDescriptorMessage): return {
        guard case .codeDescriptorMessage(let l) = lhs, case .codeDescriptorMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updaterStatus, .updaterStatus): return {
        guard case .updaterStatus(let l) = lhs, case .updaterStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VCSEC_UpdaterStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var statusCode: VCSEC_UpdaterStatusCode = .error

  var location: VCSEC_UpdaterLocation = .none

  var nextAddressNumber: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_VehicleInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_VehicleStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var closureStatuses: VCSEC_ClosureStatuses {
    get {return _closureStatuses ?? VCSEC_ClosureStatuses()}
    set {_closureStatuses = newValue}
  }
  /// Returns true if `closureStatuses` has been explicitly set.
  var hasClosureStatuses: Bool {return self._closureStatuses != nil}
  /// Clears the value of `closureStatuses`. Subsequent reads from it will return its default value.
  mutating func clearClosureStatuses() {self._closureStatuses = nil}

  var vehicleLockState: VCSEC_VehicleLockState_E = .vehiclelockstateUnlocked

  var vehicleSleepStatus: VCSEC_VehicleSleepStatus_E = .vehicleSleepStatusUnknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _closureStatuses: VCSEC_ClosureStatuses? = nil
}

struct VCSEC_VerifyAndInstallApp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sha256: Data = Data()

  var rValue: Data = Data()

  var sValue: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_WhitelistEntryInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyID: VCSEC_KeyIdentifier {
    get {return _keyID ?? VCSEC_KeyIdentifier()}
    set {_keyID = newValue}
  }
  /// Returns true if `keyID` has been explicitly set.
  var hasKeyID: Bool {return self._keyID != nil}
  /// Clears the value of `keyID`. Subsequent reads from it will return its default value.
  mutating func clearKeyID() {self._keyID = nil}

  var publicKey: VCSEC_PublicKey {
    get {return _publicKey ?? VCSEC_PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var permissions: [VCSEC_WhitelistKeyPermission_E] = []

  var metadataForKey: VCSEC_KeyMetadata {
    get {return _metadataForKey ?? VCSEC_KeyMetadata()}
    set {_metadataForKey = newValue}
  }
  /// Returns true if `metadataForKey` has been explicitly set.
  var hasMetadataForKey: Bool {return self._metadataForKey != nil}
  /// Clears the value of `metadataForKey`. Subsequent reads from it will return its default value.
  mutating func clearMetadataForKey() {self._metadataForKey = nil}

  var secondsEntryRemainsActive: UInt32 = 0

  var slot: UInt32 = 0

  var keyRole: VCSEC_Role = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyID: VCSEC_KeyIdentifier? = nil
  fileprivate var _publicKey: VCSEC_PublicKey? = nil
  fileprivate var _metadataForKey: VCSEC_KeyMetadata? = nil
}

struct VCSEC_WhitelistInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numberOfEntries: UInt32 = 0

  var whitelistEntries: [VCSEC_KeyIdentifier] = []

  var slotMask: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VCSEC_WhitelistOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadataForKey: VCSEC_KeyMetadata {
    get {return _metadataForKey ?? VCSEC_KeyMetadata()}
    set {_metadataForKey = newValue}
  }
  /// Returns true if `metadataForKey` has been explicitly set.
  var hasMetadataForKey: Bool {return self._metadataForKey != nil}
  /// Clears the value of `metadataForKey`. Subsequent reads from it will return its default value.
  mutating func clearMetadataForKey() {self._metadataForKey = nil}

  var subMessage: VCSEC_WhitelistOperation.OneOf_SubMessage? = nil

  var addPublicKeyToWhitelist: VCSEC_PublicKey {
    get {
      if case .addPublicKeyToWhitelist(let v)? = subMessage {return v}
      return VCSEC_PublicKey()
    }
    set {subMessage = .addPublicKeyToWhitelist(newValue)}
  }

  var removePublicKeyFromWhitelist: VCSEC_PublicKey {
    get {
      if case .removePublicKeyFromWhitelist(let v)? = subMessage {return v}
      return VCSEC_PublicKey()
    }
    set {subMessage = .removePublicKeyFromWhitelist(newValue)}
  }

  var addPermissionsToPublicKey: VCSEC_PermissionChange {
    get {
      if case .addPermissionsToPublicKey(let v)? = subMessage {return v}
      return VCSEC_PermissionChange()
    }
    set {subMessage = .addPermissionsToPublicKey(newValue)}
  }

  var removePermissionsFromPublicKey: VCSEC_PermissionChange {
    get {
      if case .removePermissionsFromPublicKey(let v)? = subMessage {return v}
      return VCSEC_PermissionChange()
    }
    set {subMessage = .removePermissionsFromPublicKey(newValue)}
  }

  var addKeyToWhitelistAndAddPermissions: VCSEC_PermissionChange {
    get {
      if case .addKeyToWhitelistAndAddPermissions(let v)? = subMessage {return v}
      return VCSEC_PermissionChange()
    }
    set {subMessage = .addKeyToWhitelistAndAddPermissions(newValue)}
  }

  var updateKeyAndPermissions: VCSEC_PermissionChange {
    get {
      if case .updateKeyAndPermissions(let v)? = subMessage {return v}
      return VCSEC_PermissionChange()
    }
    set {subMessage = .updateKeyAndPermissions(newValue)}
  }

  var addImpermanentKey: VCSEC_PermissionChange {
    get {
      if case .addImpermanentKey(let v)? = subMessage {return v}
      return VCSEC_PermissionChange()
    }
    set {subMessage = .addImpermanentKey(newValue)}
  }

  var addImpermanentKeyAndRemoveExisting: VCSEC_PermissionChange {
    get {
      if case .addImpermanentKeyAndRemoveExisting(let v)? = subMessage {return v}
      return VCSEC_PermissionChange()
    }
    set {subMessage = .addImpermanentKeyAndRemoveExisting(newValue)}
  }

  var removeAllImpermanentKeys: Bool {
    get {
      if case .removeAllImpermanentKeys(let v)? = subMessage {return v}
      return false
    }
    set {subMessage = .removeAllImpermanentKeys(newValue)}
  }

  var replaceKey: VCSEC_ReplaceKey {
    get {
      if case .replaceKey(let v)? = subMessage {return v}
      return VCSEC_ReplaceKey()
    }
    set {subMessage = .replaceKey(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case addPublicKeyToWhitelist(VCSEC_PublicKey)
    case removePublicKeyFromWhitelist(VCSEC_PublicKey)
    case addPermissionsToPublicKey(VCSEC_PermissionChange)
    case removePermissionsFromPublicKey(VCSEC_PermissionChange)
    case addKeyToWhitelistAndAddPermissions(VCSEC_PermissionChange)
    case updateKeyAndPermissions(VCSEC_PermissionChange)
    case addImpermanentKey(VCSEC_PermissionChange)
    case addImpermanentKeyAndRemoveExisting(VCSEC_PermissionChange)
    case removeAllImpermanentKeys(Bool)
    case replaceKey(VCSEC_ReplaceKey)

  #if !swift(>=4.1)
    static func ==(lhs: VCSEC_WhitelistOperation.OneOf_SubMessage, rhs: VCSEC_WhitelistOperation.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.addPublicKeyToWhitelist, .addPublicKeyToWhitelist): return {
        guard case .addPublicKeyToWhitelist(let l) = lhs, case .addPublicKeyToWhitelist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removePublicKeyFromWhitelist, .removePublicKeyFromWhitelist): return {
        guard case .removePublicKeyFromWhitelist(let l) = lhs, case .removePublicKeyFromWhitelist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addPermissionsToPublicKey, .addPermissionsToPublicKey): return {
        guard case .addPermissionsToPublicKey(let l) = lhs, case .addPermissionsToPublicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removePermissionsFromPublicKey, .removePermissionsFromPublicKey): return {
        guard case .removePermissionsFromPublicKey(let l) = lhs, case .removePermissionsFromPublicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addKeyToWhitelistAndAddPermissions, .addKeyToWhitelistAndAddPermissions): return {
        guard case .addKeyToWhitelistAndAddPermissions(let l) = lhs, case .addKeyToWhitelistAndAddPermissions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateKeyAndPermissions, .updateKeyAndPermissions): return {
        guard case .updateKeyAndPermissions(let l) = lhs, case .updateKeyAndPermissions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addImpermanentKey, .addImpermanentKey): return {
        guard case .addImpermanentKey(let l) = lhs, case .addImpermanentKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addImpermanentKeyAndRemoveExisting, .addImpermanentKeyAndRemoveExisting): return {
        guard case .addImpermanentKeyAndRemoveExisting(let l) = lhs, case .addImpermanentKeyAndRemoveExisting(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeAllImpermanentKeys, .removeAllImpermanentKeys): return {
        guard case .removeAllImpermanentKeys(let l) = lhs, case .removeAllImpermanentKeys(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.replaceKey, .replaceKey): return {
        guard case .replaceKey(let l) = lhs, case .replaceKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _metadataForKey: VCSEC_KeyMetadata? = nil
}

struct VCSEC_WhitelistOperation_status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var whitelistOperationInformation: VCSEC_WhitelistOperation_information_E = .whitelistoperationInformationNone

  var signerOfOperation: VCSEC_KeyIdentifier {
    get {return _signerOfOperation ?? VCSEC_KeyIdentifier()}
    set {_signerOfOperation = newValue}
  }
  /// Returns true if `signerOfOperation` has been explicitly set.
  var hasSignerOfOperation: Bool {return self._signerOfOperation != nil}
  /// Clears the value of `signerOfOperation`. Subsequent reads from it will return its default value.
  mutating func clearSignerOfOperation() {self._signerOfOperation = nil}

  var operationStatus: VCSEC_OperationStatus_E = .operationstatusOk

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signerOfOperation: VCSEC_KeyIdentifier? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension VCSEC_Activity_E: @unchecked Sendable {}
extension VCSEC_AppDeviceInfoRequest_E: @unchecked Sendable {}
extension VCSEC_AppOperatingSystem: @unchecked Sendable {}
extension VCSEC_AuthenticationLevel_E: @unchecked Sendable {}
extension VCSEC_AuthenticationReason_E: @unchecked Sendable {}
extension VCSEC_AuthenticationRejection_E: @unchecked Sendable {}
extension VCSEC_BLEAdditionalTRIMApplied_E: @unchecked Sendable {}
extension VCSEC_BLEConfigCommandType_E: @unchecked Sendable {}
extension VCSEC_BLEPresence: @unchecked Sendable {}
extension VCSEC_ClosureMoveType_E: @unchecked Sendable {}
extension VCSEC_ClosureState_E: @unchecked Sendable {}
extension VCSEC_Device_Motion_Confidence: @unchecked Sendable {}
extension VCSEC_Device_Motion_State: @unchecked Sendable {}
extension VCSEC_GenealogyRequest_E: @unchecked Sendable {}
extension VCSEC_GenealogyStatus_E: @unchecked Sendable {}
extension VCSEC_GenericError_E: @unchecked Sendable {}
extension VCSEC_GetReaderKeyCommand: @unchecked Sendable {}
extension VCSEC_HandlePulled_E: @unchecked Sendable {}
extension VCSEC_IMURequest_E: @unchecked Sendable {}
extension VCSEC_IMUState_E: @unchecked Sendable {}
extension VCSEC_InformationRequestType: @unchecked Sendable {}
extension VCSEC_KeyFormFactor: @unchecked Sendable {}
extension VCSEC_LRDetectionResult_E: @unchecked Sendable {}
extension VCSEC_MIError_E: @unchecked Sendable {}
extension VCSEC_MLXWakePeriod_E: @unchecked Sendable {}
extension VCSEC_NFCPresence: @unchecked Sendable {}
extension VCSEC_NFCSEDevicePubKeyState_E: @unchecked Sendable {}
extension VCSEC_NFCSEInsecureCommandState_E: @unchecked Sendable {}
extension VCSEC_NFCSERequest_E: @unchecked Sendable {}
extension VCSEC_NFCSESharedSecretState_E: @unchecked Sendable {}
extension VCSEC_NFCSEVehiclePubKeyState_E: @unchecked Sendable {}
extension VCSEC_OperationStatus_E: @unchecked Sendable {}
extension VCSEC_RCI_control_E: @unchecked Sendable {}
extension VCSEC_ResetTrackerCommand_E: @unchecked Sendable {}
extension VCSEC_RKEAction_E: @unchecked Sendable {}
extension VCSEC_Role: @unchecked Sendable {}
extension VCSEC_Session_Info_Status: @unchecked Sendable {}
extension VCSEC_SignatureType: @unchecked Sendable {}
extension VCSEC_SignedMessage_information_E: @unchecked Sendable {}
extension VCSEC_SleepManagerCommand_E: @unchecked Sendable {}
extension VCSEC_TPDataRequest_E: @unchecked Sendable {}
extension VCSEC_TPMSAdvType_E: @unchecked Sendable {}
extension VCSEC_TPNotifyReason_E: @unchecked Sendable {}
extension VCSEC_TPNotifyTrackerCommand_E: @unchecked Sendable {}
extension VCSEC_UpdaterLocation: @unchecked Sendable {}
extension VCSEC_UpdaterStatusCode: @unchecked Sendable {}
extension VCSEC_UWBAvailability: @unchecked Sendable {}
extension VCSEC_VehicleLockState_E: @unchecked Sendable {}
extension VCSEC_VehicleSleepStatus_E: @unchecked Sendable {}
extension VCSEC_WhitelistKeyPermission_E: @unchecked Sendable {}
extension VCSEC_WhitelistOperation_information_E: @unchecked Sendable {}
extension VCSEC_AccelData: @unchecked Sendable {}
extension VCSEC_ActiveKey: @unchecked Sendable {}
extension VCSEC_Alert: @unchecked Sendable {}
extension VCSEC_Alert.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_AlertHandlePulledWithoutAuth: @unchecked Sendable {}
extension VCSEC_AppDeviceInfo: @unchecked Sendable {}
extension VCSEC_AuthenticationRequest: @unchecked Sendable {}
extension VCSEC_AuthenticationRequestToken: @unchecked Sendable {}
extension VCSEC_AuthenticationResponse: @unchecked Sendable {}
extension VCSEC_BLEConfig: @unchecked Sendable {}
extension VCSEC_BLEConfig.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_BLEConfigAll: @unchecked Sendable {}
extension VCSEC_BLEConfigCommand: @unchecked Sendable {}
extension VCSEC_Capabilities: @unchecked Sendable {}
extension VCSEC_ClosureMoveRequest: @unchecked Sendable {}
extension VCSEC_ClosureStatuses: @unchecked Sendable {}
extension VCSEC_CodeDescriptor: @unchecked Sendable {}
extension VCSEC_CommandStatus: @unchecked Sendable {}
extension VCSEC_CommandStatus.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_ConnectionMetrics: @unchecked Sendable {}
extension VCSEC_DelaySleepRequest: @unchecked Sendable {}
extension VCSEC_DeviceMotion: @unchecked Sendable {}
extension VCSEC_FromRCI: @unchecked Sendable {}
extension VCSEC_FromVCSECMessage: @unchecked Sendable {}
extension VCSEC_FromVCSECMessage.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_Genealogy: @unchecked Sendable {}
extension VCSEC_GenealogyResponse: @unchecked Sendable {}
extension VCSEC_GetCodeDescriptor: @unchecked Sendable {}
extension VCSEC_GetReaderKey: @unchecked Sendable {}
extension VCSEC_GetSessionInfoRequest: @unchecked Sendable {}
extension VCSEC_HandlePulledWithoutAuthDeviceSpecificPayload: @unchecked Sendable {}
extension VCSEC_InformationRequest: @unchecked Sendable {}
extension VCSEC_InformationRequest.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_KeyfobInfo: @unchecked Sendable {}
extension VCSEC_KeyIdentifier: @unchecked Sendable {}
extension VCSEC_KeyIdentity: @unchecked Sendable {}
extension VCSEC_KeyIdentity.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_KeyMetadata: @unchecked Sendable {}
extension VCSEC_KeyStatus: @unchecked Sendable {}
extension VCSEC_KeyStatusInfo: @unchecked Sendable {}
extension VCSEC_MIConfigurationData: @unchecked Sendable {}
extension VCSEC_MISessionRequest: @unchecked Sendable {}
extension VCSEC_MISessionResponse: @unchecked Sendable {}
extension VCSEC_MISessionResponse.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_MISessionStop: @unchecked Sendable {}
extension VCSEC_MISessionStop.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_MISessionStopped: @unchecked Sendable {}
extension VCSEC_MISessionStopped.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_NFCSEState: @unchecked Sendable {}
extension VCSEC_NominalError: @unchecked Sendable {}
extension VCSEC_PermissionChange: @unchecked Sendable {}
extension VCSEC_PersonalizationInformation: @unchecked Sendable {}
extension VCSEC_PublicKey: @unchecked Sendable {}
extension VCSEC_RCISignature: @unchecked Sendable {}
extension VCSEC_ReplaceKey: @unchecked Sendable {}
extension VCSEC_ReplaceKey.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_ResetTrackerStats: @unchecked Sendable {}
extension VCSEC_SessionInfo: @unchecked Sendable {}
extension VCSEC_SetTPConfigration: @unchecked Sendable {}
extension VCSEC_SetUpdaterLocation: @unchecked Sendable {}
extension VCSEC_Signatures: @unchecked Sendable {}
extension VCSEC_Signatures.SessionInfo: @unchecked Sendable {}
extension VCSEC_SignedMessage: @unchecked Sendable {}
extension VCSEC_SignedMessage_status: @unchecked Sendable {}
extension VCSEC_SleepManagerRequest: @unchecked Sendable {}
extension VCSEC_SleepManagerRequest.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_SleepManagerStats: @unchecked Sendable {}
extension VCSEC_StageBlock: @unchecked Sendable {}
extension VCSEC_ToRCI: @unchecked Sendable {}
extension VCSEC_ToRCI.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_ToVCSECMessage: @unchecked Sendable {}
extension VCSEC_ToVCSECMessage.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_TPAdv: @unchecked Sendable {}
extension VCSEC_TPData: @unchecked Sendable {}
extension VCSEC_TPLRDetection: @unchecked Sendable {}
extension VCSEC_TPMotionConfig: @unchecked Sendable {}
extension VCSEC_TPMSAlarms: @unchecked Sendable {}
extension VCSEC_TPNewSensorData: @unchecked Sendable {}
extension VCSEC_TPNotifyTrackerStats: @unchecked Sendable {}
extension VCSEC_TPStationaryConfig: @unchecked Sendable {}
extension VCSEC_TPWheelUnitInfo: @unchecked Sendable {}
extension VCSEC_UnknownKeyInfo: @unchecked Sendable {}
extension VCSEC_UnsecureNotification: @unchecked Sendable {}
extension VCSEC_UnsignedMessage: @unchecked Sendable {}
extension VCSEC_UnsignedMessage.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_UpdaterCommand: @unchecked Sendable {}
extension VCSEC_UpdaterCommand.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_UpdaterResponse: @unchecked Sendable {}
extension VCSEC_UpdaterResponse.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_UpdaterStatus: @unchecked Sendable {}
extension VCSEC_VehicleInfo: @unchecked Sendable {}
extension VCSEC_VehicleStatus: @unchecked Sendable {}
extension VCSEC_VerifyAndInstallApp: @unchecked Sendable {}
extension VCSEC_WhitelistEntryInfo: @unchecked Sendable {}
extension VCSEC_WhitelistInfo: @unchecked Sendable {}
extension VCSEC_WhitelistOperation: @unchecked Sendable {}
extension VCSEC_WhitelistOperation.OneOf_SubMessage: @unchecked Sendable {}
extension VCSEC_WhitelistOperation_status: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "VCSEC"

extension VCSEC_Activity_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTIVITY_NONE"),
    1: .same(proto: "ACTIVITY_STATIONARY"),
    2: .same(proto: "ACTIVITY_MOTION"),
    3: .same(proto: "ACTIVITY_SIGNIFICANT_MOTION"),
  ]
}

extension VCSEC_AppDeviceInfoRequest_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_DEVICE_INFO_REQUEST_NONE"),
    1: .same(proto: "APP_DEVICE_INFO_REQUEST_GET_MODEL_NUMBER"),
  ]
}

extension VCSEC_AppOperatingSystem: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ANDROID"),
    2: .same(proto: "IOS"),
  ]
}

extension VCSEC_AuthenticationLevel_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTHENTICATION_LEVEL_NONE"),
    1: .same(proto: "AUTHENTICATION_LEVEL_UNLOCK"),
    2: .same(proto: "AUTHENTICATION_LEVEL_DRIVE"),
  ]
}

extension VCSEC_AuthenticationReason_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTHENTICATIONREASON_NOT_DOCUMENTED"),
    1: .same(proto: "AUTHENTICATIONREASON_IDENTIFICATION"),
    2: .same(proto: "AUTHENTICATIONREASON_POWER_ON_VEHICLE_REQUEST"),
    3: .same(proto: "AUTHENTICATIONREASON_GTW_REQUEST"),
    4: .same(proto: "AUTHENTICATIONREASON_UI_UNLOCK_PASSIVE_AUTH"),
    5: .same(proto: "AUTHENTICATIONREASON_PASSIVE_UNLOCK_EXTERIOR_HANDLE_PULL"),
    6: .same(proto: "AUTHENTICATIONREASON_PASSIVE_UNLOCK_INTERIOR_HANDLE_PULL"),
    7: .same(proto: "AUTHENTICATIONREASON_PASSIVE_UNLOCK_AUTOPRESENT_DOOR"),
    8: .same(proto: "AUTHENTICATIONREASON_ENTERED_HIGHER_AUTH_ZONE"),
    9: .same(proto: "AUTHENTICATIONREASON_WALK_UP_UNLOCK"),
    10: .same(proto: "AUTHENTICATIONREASON_IMMOBILIZER"),
  ]
}

extension VCSEC_AuthenticationRejection_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTHENTICATIONREJECTION_NONE"),
    1: .same(proto: "AUTHENTICATIONREJECTION_DEVICE_STATIONARY"),
    2: .same(proto: "AUTHENTICATIONREJECTION_PASSIVE_DISABLED"),
    3: .same(proto: "AUTHENTICATIONREJECTION_NO_TOKEN"),
  ]
}

extension VCSEC_BLEAdditionalTRIMApplied_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLE_ADDITIONAL_TRIM_APPLIED_NONE"),
    1: .same(proto: "BLE_ADDITIONAL_TRIM_APPLIED_APPLIED"),
    2: .same(proto: "BLE_ADDITIONAL_TRIM_APPLIED_NOT_APPLIED"),
  ]
}

extension VCSEC_BLEConfigCommandType_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLE_CONFIG_COMMAND_TYPE_NONE"),
    1: .same(proto: "BLE_CONFIG_COMMAND_TYPE_READ"),
    2: .same(proto: "BLE_CONFIG_COMMAND_TYPE_WRITE"),
  ]
}

extension VCSEC_BLEPresence: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLE_PRESENCE_NOT_PRESENT"),
    1: .same(proto: "BLE_PRESENCE_PRESENT"),
  ]
}

extension VCSEC_ClosureMoveType_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLOSURE_MOVE_TYPE_NONE"),
    1: .same(proto: "CLOSURE_MOVE_TYPE_MOVE"),
    2: .same(proto: "CLOSURE_MOVE_TYPE_STOP"),
    3: .same(proto: "CLOSURE_MOVE_TYPE_OPEN"),
    4: .same(proto: "CLOSURE_MOVE_TYPE_CLOSE"),
  ]
}

extension VCSEC_ClosureState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLOSURESTATE_CLOSED"),
    1: .same(proto: "CLOSURESTATE_OPEN"),
    2: .same(proto: "CLOSURESTATE_AJAR"),
    3: .same(proto: "CLOSURESTATE_UNKNOWN"),
    4: .same(proto: "CLOSURESTATE_FAILED_UNLATCH"),
  ]
}

extension VCSEC_Device_Motion_Confidence: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_MOTION_CONFIDENCE_UNKNOWN"),
    1: .same(proto: "DEVICE_MOTION_CONFIDENCE_LOW"),
    2: .same(proto: "DEVICE_MOTION_CONFIDENCE_MEDIUM"),
    3: .same(proto: "DEVICE_MOTION_CONFIDENCE_HIGH"),
  ]
}

extension VCSEC_Device_Motion_State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_MOTION_UNKNOWN"),
    1: .same(proto: "DEVICE_MOTION_STATIONARY"),
    2: .same(proto: "DEVICE_MOTION_WALKING"),
    3: .same(proto: "DEVICE_MOTION_RUNNING"),
    4: .same(proto: "DEVICE_MOTION_AUTOMOTIVE"),
    5: .same(proto: "DEVICE_MOTION_CYCLING"),
  ]
}

extension VCSEC_GenealogyRequest_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GENEALOGYREQUEST_NONE"),
    1: .same(proto: "GENEALOGYREQUEST_READ"),
    2: .same(proto: "GENEALOGYREQUEST_KEYFOBINFO_READ"),
    3: .same(proto: "GENEALOGYREQUEST_TPWHEELUNITINFO_READ"),
  ]
}

extension VCSEC_GenealogyStatus_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GENEALOGY_STATUS_NONE"),
    1: .same(proto: "GENEALOGY_STATUS_NOT_WRITTEN"),
    2: .same(proto: "GENEALOGY_STATUS_WRITE_SUCCESS"),
    3: .same(proto: "GENEALOGY_STATUS_WRITE_FAILURE"),
    4: .same(proto: "GENEALOGY_STATUS_READ_SUCCESS"),
    5: .same(proto: "GENEALOGY_STATUS_READ_FAILURE"),
    6: .same(proto: "GENEALOGY_STATUS_CRC_FAILURE"),
  ]
}

extension VCSEC_GenericError_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GENERICERROR_NONE"),
    1: .same(proto: "GENERICERROR_UNKNOWN"),
    2: .same(proto: "GENERICERROR_CLOSURES_OPEN"),
    3: .same(proto: "GENERICERROR_ALREADY_ON"),
    4: .same(proto: "GENERICERROR_DISABLED_FOR_USER_COMMAND"),
    5: .same(proto: "GENERICERROR_VEHICLE_NOT_IN_PARK"),
    6: .same(proto: "GENERICERROR_UNAUTHORIZED"),
    7: .same(proto: "GENERICERROR_NOT_ALLOWED_OVER_TRANSPORT"),
  ]
}

extension VCSEC_GetReaderKeyCommand: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET_READER_KEY_COMMAND_UNKNOWN"),
    1: .same(proto: "GET_READER_KEY_COMMAND_START_LOOKING"),
    2: .same(proto: "GET_READER_KEY_COMMAND_STOP_LOOKING"),
  ]
}

extension VCSEC_HandlePulled_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HANDLE_PULLED_FRONT_DRIVER_DOOR"),
    1: .same(proto: "HANDLE_PULLED_FRONT_PASSENGER_DOOR"),
    2: .same(proto: "HANDLE_PULLED_REAR_DRIVER_DOOR"),
    3: .same(proto: "HANDLE_PULLED_REAR_PASSENGER_DOOR"),
    4: .same(proto: "HANDLE_PULLED_TRUNK"),
    5: .same(proto: "HANDLE_PULLED_CHARGE_PORT"),
    6: .same(proto: "HANDLE_PULLED_FRONT_DRIVER_AUTO_PRESENT_DOOR"),
    7: .same(proto: "HANDLE_PULLED_FRONT_PASSENGER_AUTO_PRESENT_DOOR"),
    8: .same(proto: "HANDLE_PULLED_OTHER"),
  ]
}

extension VCSEC_IMURequest_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IMU_REQUEST_NONE"),
    1: .same(proto: "IMU_REQUEST_GET_SLEEP_STATE"),
    2: .same(proto: "IMU_REQUEST_ENABLE_CONTINUOUS_ACTIVITY_UPDATE"),
    3: .same(proto: "IMU_REQUEST_DISABLE_CONTINUOUS_ACTIVITY_UPDATE"),
  ]
}

extension VCSEC_IMUState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IMU_STATE_NOT_CONFIGURED"),
    1: .same(proto: "IMU_STATE_ACTIVITY"),
    2: .same(proto: "IMU_STATE_INACTIVITY"),
  ]
}

extension VCSEC_InformationRequestType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INFORMATION_REQUEST_TYPE_GET_STATUS"),
    1: .same(proto: "INFORMATION_REQUEST_TYPE_GET_TOKEN"),
    2: .same(proto: "INFORMATION_REQUEST_TYPE_GET_COUNTER"),
    3: .same(proto: "INFORMATION_REQUEST_TYPE_GET_EPHEMERAL_PUBLIC_KEY"),
    4: .same(proto: "INFORMATION_REQUEST_TYPE_GET_SESSION_DATA"),
    5: .same(proto: "INFORMATION_REQUEST_TYPE_GET_WHITELIST_INFO"),
    6: .same(proto: "INFORMATION_REQUEST_TYPE_GET_WHITELIST_ENTRY_INFO"),
    7: .same(proto: "INFORMATION_REQUEST_TYPE_GET_VEHICLE_INFO"),
    8: .same(proto: "INFORMATION_REQUEST_TYPE_GET_KEYSTATUS_INFO"),
    9: .same(proto: "INFORMATION_REQUEST_TYPE_GET_ACTIVE_KEY"),
    16: .same(proto: "INFORMATION_REQUEST_TYPE_GET_CAPABILITIES"),
  ]
}

extension VCSEC_KeyFormFactor: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY_FORM_FACTOR_UNKNOWN"),
    1: .same(proto: "KEY_FORM_FACTOR_NFC_CARD"),
    2: .same(proto: "KEY_FORM_FACTOR_3_BUTTON_BLE_CAR_KEYFOB"),
    3: .same(proto: "KEY_FORM_FACTOR_BLE_DEVICE"),
    4: .same(proto: "KEY_FORM_FACTOR_NFC_DEVICE"),
    5: .same(proto: "KEY_FORM_FACTOR_BLE_AND_NFC_DEVICE"),
    6: .same(proto: "KEY_FORM_FACTOR_IOS_DEVICE"),
    7: .same(proto: "KEY_FORM_FACTOR_ANDROID_DEVICE"),
    8: .same(proto: "KEY_FORM_FACTOR_3_BUTTON_BLE_CAR_KEYFOB_P60"),
    9: .same(proto: "KEY_FORM_FACTOR_CLOUD_KEY"),
    10: .same(proto: "KEY_FORM_FACTOR_3_BUTTON_GEN2_CAR_KEYFOB_P60"),
    11: .same(proto: "KEY_FORM_FACTOR_5_BUTTON_GEN2_CAR_KEYFOB_P60"),
    12: .same(proto: "KEY_FORM_FACTOR_3_BUTTON_GEN2_CAR_KEYFOB_P60_V2"),
    13: .same(proto: "KEY_FORM_FACTOR_3_BUTTON_GEN2_CAR_KEYFOB_P60_V3"),
    14: .same(proto: "KEY_FORM_FACTOR_NFC_CARD_P71"),
  ]
}

extension VCSEC_LRDetectionResult_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LRDETECTIONRESULT_ERROR_MAXCNT"),
    1: .same(proto: "LRDETECTIONRESULT_ERROR_NEGPERIOD"),
    2: .same(proto: "LRDETECTIONRESULT_ERROR_LONGPERIOD"),
    3: .same(proto: "LRDETECTIONRESULT_LEFT"),
    4: .same(proto: "LRDETECTIONRESULT_RIGHT"),
  ]
}

extension VCSEC_MIError_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_UNKNOWN"),
    1: .same(proto: "ERROR_SESSION_LIMIT_EXCEEDED"),
    2: .same(proto: "ERROR_INVALID_CONFIGURATION"),
    3: .same(proto: "ERROR_RESOURCE_USAGE_TIMEOUT"),
    4: .same(proto: "ERROR_SESSION_FAILED"),
    5: .same(proto: "ERROR_UNSUPPORTED_PLATFORM"),
    6: .same(proto: "ERROR_USER_DID_NOT_ALLOW"),
    7: .same(proto: "ERROR_BLE_PEER_UNAVAILABLE"),
  ]
}

extension VCSEC_MLXWakePeriod_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MLXWAKEPERIOD_2_MS"),
    1: .same(proto: "MLXWAKEPERIOD_3_MS"),
    2: .same(proto: "MLXWAKEPERIOD_5_MS"),
    3: .same(proto: "MLXWAKEPERIOD_15_MS"),
    4: .same(proto: "MLXWAKEPERIOD_30_MS"),
    5: .same(proto: "MLXWAKEPERIOD_50_MS"),
    6: .same(proto: "MLXWAKEPERIOD_100_MS"),
    7: .same(proto: "MLXWAKEPERIOD_150_MS"),
    8: .same(proto: "MLXWAKEPERIOD_250_MS"),
    9: .same(proto: "MLXWAKEPERIOD_500_MS"),
    10: .same(proto: "MLXWAKEPERIOD_1_S"),
    11: .same(proto: "MLXWAKEPERIOD_2_S"),
    12: .same(proto: "MLXWAKEPERIOD_2_5_S"),
    13: .same(proto: "MLXWAKEPERIOD_3_S"),
    14: .same(proto: "MLXWAKEPERIOD_4_S"),
    15: .same(proto: "MLXWAKEPERIOD_5_S"),
    16: .same(proto: "MLXWAKEPERIOD_6_S"),
    17: .same(proto: "MLXWAKEPERIOD_7_S"),
    18: .same(proto: "MLXWAKEPERIOD_8_S"),
    19: .same(proto: "MLXWAKEPERIOD_9_S"),
    20: .same(proto: "MLXWAKEPERIOD_10_S"),
    21: .same(proto: "MLXWAKEPERIOD_11_S"),
    22: .same(proto: "MLXWAKEPERIOD_12_S"),
    23: .same(proto: "MLXWAKEPERIOD_15_S"),
    24: .same(proto: "MLXWAKEPERIOD_20_S"),
    25: .same(proto: "MLXWAKEPERIOD_30_S"),
    26: .same(proto: "MLXWAKEPERIOD_1_M"),
    27: .same(proto: "MLXWAKEPERIOD_2_M"),
    28: .same(proto: "MLXWAKEPERIOD_3_M"),
    29: .same(proto: "MLXWAKEPERIOD_4_M"),
    30: .same(proto: "MLXWAKEPERIOD_5_M"),
    31: .same(proto: "MLXWAKEPERIOD_10_M"),
    32: .same(proto: "MLXWAKEPERIOD_16_M"),
    33: .same(proto: "MLXWAKEPERIOD_NOT_SET"),
  ]
}

extension VCSEC_NFCPresence: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NFC_PRESENCE_NOT_PRESENT"),
    1: .same(proto: "NFC_PRESENCE_PRESENT_AT_B_PILLAR"),
    2: .same(proto: "NFC_PRESENCE_PRESENT_AT_CENTER_CONSOLE"),
  ]
}

extension VCSEC_NFCSEDevicePubKeyState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NFCSEC_DEVICEPUBKEY_STATE_NONE"),
    1: .same(proto: "NFCSEC_DEVICEPUBKEY_STATE_RETRIEVED"),
    2: .same(proto: "NFCSEC_DEVICEPUBKEY_STATE_NOT_RETRIEVED"),
  ]
}

extension VCSEC_NFCSEInsecureCommandState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NFCSEC_INSECURE_COMMAND_STATE_NONE"),
    1: .same(proto: "NFCSEC_INSECURE_COMMAND_STATE_ENABLED"),
    2: .same(proto: "NFCSEC_INSECURE_COMMAND_STATE_DISABLED"),
  ]
}

extension VCSEC_NFCSERequest_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NFCSE_REQUEST_NONE"),
    1: .same(proto: "NFCSE_REQUEST_REFETCH_SESSION_INFO"),
    2: .same(proto: "NFCSE_REQUEST_DISABLE_INSECURE_COMMANDS"),
    3: .same(proto: "NFCSE_REQUEST_GET_CURRENT_STATE"),
  ]
}

extension VCSEC_NFCSESharedSecretState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NFCSEC_SHAREDSECRET_STATE_NONE"),
    1: .same(proto: "NFCSEC_SHAREDSECRET_STATE_GENERATED"),
    2: .same(proto: "NFCSEC_SHAREDSECRET_STATE_NOT_GENERATED"),
  ]
}

extension VCSEC_NFCSEVehiclePubKeyState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NFCSEC_VEHICLEPUBKEY_STATE_NONE"),
    1: .same(proto: "NFCSEC_VEHICLEPUBKEY_STATE_RETRIEVED"),
    2: .same(proto: "NFCSEC_VEHICLEPUBKEY_STATE_NOT_RETRIEVED"),
  ]
}

extension VCSEC_OperationStatus_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATIONSTATUS_OK"),
    1: .same(proto: "OPERATIONSTATUS_WAIT"),
    2: .same(proto: "OPERATIONSTATUS_ERROR"),
  ]
}

extension VCSEC_RCI_control_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RCI_CONTROL_NONE"),
    1: .same(proto: "RCI_CONTROL_TURN_OFF"),
  ]
}

extension VCSEC_ResetTrackerCommand_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESETTRACKER_COMMAND_NONE"),
    1: .same(proto: "RESETTRACKER_COMMAND_GET_STATS"),
    2: .same(proto: "RESETTRACKER_COMMAND_CLEAR_STATS"),
  ]
}

extension VCSEC_RKEAction_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RKE_ACTION_UNLOCK"),
    1: .same(proto: "RKE_ACTION_LOCK"),
    2: .same(proto: "RKE_ACTION_OPEN_TRUNK"),
    3: .same(proto: "RKE_ACTION_OPEN_FRUNK"),
    4: .same(proto: "RKE_ACTION_OPEN_CHARGE_PORT"),
    5: .same(proto: "RKE_ACTION_CLOSE_CHARGE_PORT"),
    6: .same(proto: "RKE_ACTION_CANCEL_EXTERNAL_AUTHENTICATE"),
    7: .same(proto: "RKE_ACTION_SINGLE_PRESS_TOP"),
    8: .same(proto: "RKE_ACTION_DOUBLE_PRESS_TOP"),
    9: .same(proto: "RKE_ACTION_TRIPLE_PRESS_TOP"),
    10: .same(proto: "RKE_ACTION_HOLD_TOP"),
    11: .same(proto: "RKE_ACTION_SINGLE_PRESS_BACK"),
    12: .same(proto: "RKE_ACTION_DOUBLE_PRESS_BACK"),
    13: .same(proto: "RKE_ACTION_TRIPLE_PRESS_BACK"),
    14: .same(proto: "RKE_ACTION_HOLD_BACK"),
    15: .same(proto: "RKE_ACTION_SINGLE_PRESS_FRONT"),
    16: .same(proto: "RKE_ACTION_DOUBLE_PRESS_FRONT"),
    17: .same(proto: "RKE_ACTION_TRIPLE_PRESS_FRONT"),
    18: .same(proto: "RKE_ACTION_HOLD_FRONT"),
    19: .same(proto: "RKE_ACTION_UNKNOWN"),
    20: .same(proto: "RKE_ACTION_REMOTE_DRIVE"),
    21: .same(proto: "RKE_ACTION_SINGLE_PRESS_LEFT"),
    22: .same(proto: "RKE_ACTION_DOUBLE_PRESS_LEFT"),
    23: .same(proto: "RKE_ACTION_TRIPLE_PRESS_LEFT"),
    24: .same(proto: "RKE_ACTION_HOLD_LEFT"),
    25: .same(proto: "RKE_ACTION_SINGLE_PRESS_RIGHT"),
    26: .same(proto: "RKE_ACTION_DOUBLE_PRESS_RIGHT"),
    27: .same(proto: "RKE_ACTION_TRIPLE_PRESS_RIGHT"),
    28: .same(proto: "RKE_ACTION_HOLD_RIGHT"),
    29: .same(proto: "RKE_ACTION_AUTO_SECURE_VEHICLE"),
    30: .same(proto: "RKE_ACTION_WAKE_VEHICLE"),
  ]
}

extension VCSEC_Role: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROLE_NONE"),
    1: .same(proto: "ROLE_SERVICE"),
    2: .same(proto: "ROLE_OWNER"),
    3: .same(proto: "ROLE_DRIVER"),
    4: .same(proto: "ROLE_FM"),
    5: .same(proto: "ROLE_VEHICLE_MONITOR"),
    6: .same(proto: "ROLE_CHARGING_MANAGER"),
    7: .same(proto: "ROLE_SERVICE_TECH"),
  ]
}

extension VCSEC_Session_Info_Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SESSION_INFO_STATUS_OK"),
    1: .same(proto: "SESSION_INFO_STATUS_KEY_NOT_ON_WHITELIST"),
  ]
}

extension VCSEC_SignatureType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SIGNATURE_TYPE_AES_GCM"),
    1: .same(proto: "SIGNATURE_TYPE_ECDSA"),
    2: .same(proto: "SIGNATURE_TYPE_PRESENT_KEY"),
    3: .same(proto: "SIGNATURE_TYPE_AES_GCM_TOKEN"),
    4: .same(proto: "SIGNATURE_TYPE_UNSIGNED"),
  ]
}

extension VCSEC_SignedMessage_information_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SIGNEDMESSAGE_INFORMATION_NONE"),
    1: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_UNKNOWN"),
    2: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_NOT_ON_WHITELIST"),
    3: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_IV_SMALLER_THAN_EXPECTED"),
    4: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_INVALID_TOKEN"),
    5: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_AND_COUNTER_INVALID"),
    6: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_AES_DECRYPT_AUTH"),
    7: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_INPUT"),
    8: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_SIGNATURE"),
    9: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_START"),
    10: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_RESULT"),
    11: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_KEY"),
    12: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_TOKEN"),
    13: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_SIGNATURE_TOO_SHORT"),
    14: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_IS_INCORRECT_LENGTH"),
    15: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_INCORRECT_EPOCH"),
    16: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_IV_INCORRECT_LENGTH"),
    17: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_TIME_EXPIRED"),
    18: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_NOT_PROVISIONED_WITH_IDENTITY"),
    19: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_HASH_METADATA"),
  ]
}

extension VCSEC_SleepManagerCommand_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SLEEPMANAGER_COMMAND_NONE"),
    1: .same(proto: "SLEEPMANAGER_GET_STATS"),
    2: .same(proto: "SLEEPMANAGER_RESET_STATS"),
  ]
}

extension VCSEC_TPDataRequest_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TP_DATAREQUEST_NONE"),
    1: .same(proto: "TP_DATAREQUEST_PRESSURE_TEMPERATURE"),
    2: .same(proto: "TP_DATAREQUEST_NEW_SENSOR_INFO"),
    3: .same(proto: "TP_DATAREQUEST_WHEEL_ROTATION_DIRECTION"),
    4: .same(proto: "TP_DATAREQUEST_ACCEL"),
    5: .same(proto: "TP_DATAREQUEST_MOTION_DETECTION_START"),
    6: .same(proto: "TP_DATAREQUEST_READ_ALARMS"),
    7: .same(proto: "TP_DATAREQUEST_MOTION_DETECTION_STOP"),
  ]
}

extension VCSEC_TPMSAdvType_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TPMS_ADV_TYPE_SEMI"),
  ]
}

extension VCSEC_TPNotifyReason_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TP_NOTIFY_REASON_UNKNOWN"),
    1: .same(proto: "TP_NOTIFY_REASON_LOW_PRESSURE"),
    2: .same(proto: "TP_NOTIFY_REASON_PT_VALUE_UPDATE"),
    3: .same(proto: "TP_NOTIFY_REASON_WHEEL_MOVING"),
    4: .same(proto: "TP_NOTIFY_REASON_WHEEL_ROTATION_DIRECTION_CALCULATION_READY"),
    5: .same(proto: "TP_NOTIFY_REASON_LF"),
    6: .same(proto: "TP_NOTIFY_REASON_FAULT"),
  ]
}

extension VCSEC_TPNotifyTrackerCommand_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TP_NOTIFYTRACKER_COMMAND_NONE"),
    1: .same(proto: "TP_NOTIFYTRACKER_COMMAND_GET_STATS"),
    2: .same(proto: "TP_NOTIFYTRACKER_COMMAND_CLEAR_STATS"),
  ]
}

extension VCSEC_UpdaterLocation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPDATER_LOCATION_NONE"),
    1: .same(proto: "UPDATER_LOCATION_APPLICATION"),
    2: .same(proto: "UPDATER_LOCATION_BOOTLOADER"),
    3: .same(proto: "UPDATER_LOCATION_SECONDARY_APPLICATION"),
    4: .same(proto: "UPDATER_LOCATION_APPLICATION_IN_EXTERNAL_FLASH"),
  ]
}

extension VCSEC_UpdaterStatusCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPDATER_STATUS_CODE_ERROR"),
    1: .same(proto: "UPDATER_STATUS_CODE_WAIT"),
    2: .same(proto: "UPDATER_STATUS_CODE_BLOCK_STAGED"),
    3: .same(proto: "UPDATER_STATUS_CODE_IMAGE_STAGED"),
    4: .same(proto: "UPDATER_STATUS_CODE_CRC_CHECK_SUCCESS"),
    5: .same(proto: "UPDATER_STATUS_CODE_CRC_CHECK_FAIL"),
    6: .same(proto: "UPDATER_STATUS_CODE_HASH_FAIL"),
    7: .same(proto: "UPDATER_STATUS_CODE_SIGNATURE_FAIL"),
    8: .same(proto: "UPDATER_STATUS_CODE_ERROR_HASH_RESTORE_FAIL"),
    9: .same(proto: "UPDATER_STATUS_CODE_LOCATION_SET"),
  ]
}

extension VCSEC_UWBAvailability: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UWB_AVAILABILITY_UNKNOWN"),
    1: .same(proto: "UWB_AVAILABILITY_AVAILABLE"),
    2: .same(proto: "UWB_AVAILABILITY_UNAVAILABLE_UNSUPPORTED_DEVICE"),
    3: .same(proto: "UWB_AVAILABILITY_UNAVAILABLE_PERMISSION_DENIED"),
    4: .same(proto: "UWB_AVAILABILITY_UNAVAILABLE"),
  ]
}

extension VCSEC_VehicleLockState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VEHICLELOCKSTATE_UNLOCKED"),
    1: .same(proto: "VEHICLELOCKSTATE_LOCKED"),
    2: .same(proto: "VEHICLELOCKSTATE_INTERNAL_LOCKED"),
    3: .same(proto: "VEHICLELOCKSTATE_SELECTIVE_UNLOCKED"),
  ]
}

extension VCSEC_VehicleSleepStatus_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VEHICLE_SLEEP_STATUS_UNKNOWN"),
    1: .same(proto: "VEHICLE_SLEEP_STATUS_AWAKE"),
    2: .same(proto: "VEHICLE_SLEEP_STATUS_ASLEEP"),
  ]
}

extension VCSEC_WhitelistKeyPermission_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WHITELISTKEYPERMISSION_ADD_TO_WHITELIST"),
    1: .same(proto: "WHITELISTKEYPERMISSION_LOCAL_UNLOCK"),
    2: .same(proto: "WHITELISTKEYPERMISSION_LOCAL_DRIVE"),
    3: .same(proto: "WHITELISTKEYPERMISSION_REMOTE_UNLOCK"),
    4: .same(proto: "WHITELISTKEYPERMISSION_REMOTE_DRIVE"),
    5: .same(proto: "WHITELISTKEYPERMISSION_CHANGE_PERMISSIONS"),
    6: .same(proto: "WHITELISTKEYPERMISSION_REMOVE_FROM_WHITELIST"),
    7: .same(proto: "WHITELISTKEYPERMISSION_REMOVE_SELF_FROM_WHITELIST"),
    8: .same(proto: "WHITELISTKEYPERMISSION_MODIFY_FLEET_RESERVED_SLOTS"),
    31: .same(proto: "WHITELISTKEYPERMISSION_UNKNOWN"),
  ]
}

extension VCSEC_WhitelistOperation_information_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WHITELISTOPERATION_INFORMATION_NONE"),
    1: .same(proto: "WHITELISTOPERATION_INFORMATION_UNDOCUMENTED_ERROR"),
    2: .same(proto: "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE_ONESELF"),
    3: .same(proto: "WHITELISTOPERATION_INFORMATION_KEYFOB_SLOTS_FULL"),
    4: .same(proto: "WHITELISTOPERATION_INFORMATION_WHITELIST_FULL"),
    5: .same(proto: "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_ADD"),
    6: .same(proto: "WHITELISTOPERATION_INFORMATION_INVALID_PUBLIC_KEY"),
    7: .same(proto: "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE"),
    8: .same(proto: "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_CHANGE_PERMISSIONS"),
    9: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ELEVATE_OTHER_ABOVE_ONESELF"),
    10: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_DEMOTE_SUPERIOR_TO_ONESELF"),
    11: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_REMOVE_OWN_PERMISSIONS"),
    12: .same(proto: "WHITELISTOPERATION_INFORMATION_PUBLIC_KEY_NOT_ON_WHITELIST"),
    13: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_THAT_IS_ALREADY_ON_THE_WHITELIST"),
    14: .same(proto: "WHITELISTOPERATION_INFORMATION_NOT_ALLOWED_TO_ADD_UNLESS_ON_READER"),
    15: .same(proto: "WHITELISTOPERATION_INFORMATION_FM_MODIFYING_OUTSIDE_OF_F_MODE"),
    16: .same(proto: "WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_ADD_PERMANENT_KEY"),
    17: .same(proto: "WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_REMOVE_PERMANENT_KEY"),
    18: .same(proto: "WHITELISTOPERATION_INFORMATION_KEYCHAIN_WHILE_FS_FULL"),
    19: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITHOUT_ROLE"),
    20: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITH_SERVICE_ROLE"),
    21: .same(proto: "WHITELISTOPERATION_INFORMATION_NON_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH"),
    22: .same(proto: "WHITELISTOPERATION_INFORMATION_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH_OUTSIDE_SERVICE_MODE"),
  ]
}

extension VCSEC_AccelData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccelData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "xAccel_g"),
    2: .standard(proto: "zAccel_g"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.xAccelG) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.zAccelG) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.xAccelG != 0 {
      try visitor.visitSingularInt32Field(value: self.xAccelG, fieldNumber: 1)
    }
    if self.zAccelG != 0 {
      try visitor.visitSingularInt32Field(value: self.zAccelG, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_AccelData, rhs: VCSEC_AccelData) -> Bool {
    if lhs.xAccelG != rhs.xAccelG {return false}
    if lhs.zAccelG != rhs.zAccelG {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_ActiveKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActiveKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "activeKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._activeKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._activeKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_ActiveKey, rhs: VCSEC_ActiveKey) -> Bool {
    if lhs._activeKey != rhs._activeKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_Alert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Alert"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alertHandlePulledWithoutAuth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: VCSEC_AlertHandlePulledWithoutAuth?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .alertHandlePulledWithoutAuth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .alertHandlePulledWithoutAuth(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .alertHandlePulledWithoutAuth(let v)? = self.subMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_Alert, rhs: VCSEC_Alert) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_AlertHandlePulledWithoutAuth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AlertHandlePulledWithoutAuth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timeSinceAlertSet_ms"),
    2: .same(proto: "handlePulled"),
    3: .same(proto: "connectionCount"),
    4: .same(proto: "unknownDevicePresent"),
    5: .same(proto: "authRequested"),
    6: .same(proto: "deviceSpecificPayload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.timeSinceAlertSetMs) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.handlePulled) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.connectionCount) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.unknownDevicePresent) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.authRequested) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.deviceSpecificPayload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeSinceAlertSetMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeSinceAlertSetMs, fieldNumber: 1)
    }
    if self.handlePulled != .handlePulledFrontDriverDoor {
      try visitor.visitSingularEnumField(value: self.handlePulled, fieldNumber: 2)
    }
    if self.connectionCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.connectionCount, fieldNumber: 3)
    }
    if self.unknownDevicePresent != false {
      try visitor.visitSingularBoolField(value: self.unknownDevicePresent, fieldNumber: 4)
    }
    if self.authRequested != false {
      try visitor.visitSingularBoolField(value: self.authRequested, fieldNumber: 5)
    }
    if !self.deviceSpecificPayload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deviceSpecificPayload, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_AlertHandlePulledWithoutAuth, rhs: VCSEC_AlertHandlePulledWithoutAuth) -> Bool {
    if lhs.timeSinceAlertSetMs != rhs.timeSinceAlertSetMs {return false}
    if lhs.handlePulled != rhs.handlePulled {return false}
    if lhs.connectionCount != rhs.connectionCount {return false}
    if lhs.unknownDevicePresent != rhs.unknownDevicePresent {return false}
    if lhs.authRequested != rhs.authRequested {return false}
    if lhs.deviceSpecificPayload != rhs.deviceSpecificPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_AppDeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppDeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hardware_model_sha256"),
    2: .same(proto: "os"),
    3: .same(proto: "UWBAvailable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hardwareModelSha256) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.os) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.uwbavailable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hardwareModelSha256.isEmpty {
      try visitor.visitSingularBytesField(value: self.hardwareModelSha256, fieldNumber: 1)
    }
    if self.os != .unknown {
      try visitor.visitSingularEnumField(value: self.os, fieldNumber: 2)
    }
    if self.uwbavailable != .unknown {
      try visitor.visitSingularEnumField(value: self.uwbavailable, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_AppDeviceInfo, rhs: VCSEC_AppDeviceInfo) -> Bool {
    if lhs.hardwareModelSha256 != rhs.hardwareModelSha256 {return false}
    if lhs.os != rhs.os {return false}
    if lhs.uwbavailable != rhs.uwbavailable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_AuthenticationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "sessionInfo"),
    3: .same(proto: "requestedLevel"),
    4: .same(proto: "reasonsForAuth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sessionInfo) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.requestedLevel) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.reasonsForAuth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sessionInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.requestedLevel != .authenticationLevelNone {
      try visitor.visitSingularEnumField(value: self.requestedLevel, fieldNumber: 3)
    }
    if !self.reasonsForAuth.isEmpty {
      try visitor.visitPackedEnumField(value: self.reasonsForAuth, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_AuthenticationRequest, rhs: VCSEC_AuthenticationRequest) -> Bool {
    if lhs._sessionInfo != rhs._sessionInfo {return false}
    if lhs.requestedLevel != rhs.requestedLevel {return false}
    if lhs.reasonsForAuth != rhs.reasonsForAuth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_AuthenticationRequestToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticationRequestToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularBytesField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_AuthenticationRequestToken, rhs: VCSEC_AuthenticationRequestToken) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_AuthenticationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authenticationLevel"),
    2: .same(proto: "estimatedDistance"),
    3: .same(proto: "authenticationRejection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.authenticationLevel) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.estimatedDistance) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.authenticationRejection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.authenticationLevel != .authenticationLevelNone {
      try visitor.visitSingularEnumField(value: self.authenticationLevel, fieldNumber: 1)
    }
    if self.estimatedDistance != 0 {
      try visitor.visitSingularUInt32Field(value: self.estimatedDistance, fieldNumber: 2)
    }
    if self.authenticationRejection != .authenticationrejectionNone {
      try visitor.visitSingularEnumField(value: self.authenticationRejection, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_AuthenticationResponse, rhs: VCSEC_AuthenticationResponse) -> Bool {
    if lhs.authenticationLevel != rhs.authenticationLevel {return false}
    if lhs.estimatedDistance != rhs.estimatedDistance {return false}
    if lhs.authenticationRejection != rhs.authenticationRejection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_BLEConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BLEConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ADVInterval"),
    2: .same(proto: "sleepClockAccuracy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .advinterval(v)
        }
      }()
      case 2: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .sleepClockAccuracy(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .advinterval?: try {
      guard case .advinterval(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }()
    case .sleepClockAccuracy?: try {
      guard case .sleepClockAccuracy(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_BLEConfig, rhs: VCSEC_BLEConfig) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_BLEConfigAll: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BLEConfigAll"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ADVInterval"),
    2: .same(proto: "sleepClockAccuracy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.advinterval) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sleepClockAccuracy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.advinterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.advinterval, fieldNumber: 1)
    }
    if self.sleepClockAccuracy != 0 {
      try visitor.visitSingularUInt32Field(value: self.sleepClockAccuracy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_BLEConfigAll, rhs: VCSEC_BLEConfigAll) -> Bool {
    if lhs.advinterval != rhs.advinterval {return false}
    if lhs.sleepClockAccuracy != rhs.sleepClockAccuracy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_BLEConfigCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BLEConfigCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BLEConfigCommandType"),
    2: .same(proto: "BLEConfig"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.bleconfigCommandType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._bleconfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.bleconfigCommandType != .bleConfigCommandTypeNone {
      try visitor.visitSingularEnumField(value: self.bleconfigCommandType, fieldNumber: 1)
    }
    try { if let v = self._bleconfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_BLEConfigCommand, rhs: VCSEC_BLEConfigCommand) -> Bool {
    if lhs.bleconfigCommandType != rhs.bleconfigCommandType {return false}
    if lhs._bleconfig != rhs._bleconfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_Capabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Capabilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chargePortOpen"),
    2: .same(proto: "chargePortClose"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.chargePortOpen) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.chargePortClose) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chargePortOpen != false {
      try visitor.visitSingularBoolField(value: self.chargePortOpen, fieldNumber: 1)
    }
    if self.chargePortClose != false {
      try visitor.visitSingularBoolField(value: self.chargePortClose, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_Capabilities, rhs: VCSEC_Capabilities) -> Bool {
    if lhs.chargePortOpen != rhs.chargePortOpen {return false}
    if lhs.chargePortClose != rhs.chargePortClose {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_ClosureMoveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClosureMoveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "frontDriverDoor"),
    2: .same(proto: "frontPassengerDoor"),
    3: .same(proto: "rearDriverDoor"),
    4: .same(proto: "rearPassengerDoor"),
    5: .same(proto: "rearTrunk"),
    6: .same(proto: "frontTrunk"),
    7: .same(proto: "chargePort"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.frontDriverDoor) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.frontPassengerDoor) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.rearDriverDoor) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.rearPassengerDoor) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.rearTrunk) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.frontTrunk) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.chargePort) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frontDriverDoor != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.frontDriverDoor, fieldNumber: 1)
    }
    if self.frontPassengerDoor != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.frontPassengerDoor, fieldNumber: 2)
    }
    if self.rearDriverDoor != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.rearDriverDoor, fieldNumber: 3)
    }
    if self.rearPassengerDoor != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.rearPassengerDoor, fieldNumber: 4)
    }
    if self.rearTrunk != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.rearTrunk, fieldNumber: 5)
    }
    if self.frontTrunk != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.frontTrunk, fieldNumber: 6)
    }
    if self.chargePort != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.chargePort, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_ClosureMoveRequest, rhs: VCSEC_ClosureMoveRequest) -> Bool {
    if lhs.frontDriverDoor != rhs.frontDriverDoor {return false}
    if lhs.frontPassengerDoor != rhs.frontPassengerDoor {return false}
    if lhs.rearDriverDoor != rhs.rearDriverDoor {return false}
    if lhs.rearPassengerDoor != rhs.rearPassengerDoor {return false}
    if lhs.rearTrunk != rhs.rearTrunk {return false}
    if lhs.frontTrunk != rhs.frontTrunk {return false}
    if lhs.chargePort != rhs.chargePort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_ClosureStatuses: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClosureStatuses"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "frontDriverDoor"),
    2: .same(proto: "frontPassengerDoor"),
    3: .same(proto: "rearDriverDoor"),
    4: .same(proto: "rearPassengerDoor"),
    5: .same(proto: "rearTrunk"),
    6: .same(proto: "frontTrunk"),
    7: .same(proto: "chargePort"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.frontDriverDoor) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.frontPassengerDoor) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.rearDriverDoor) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.rearPassengerDoor) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.rearTrunk) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.frontTrunk) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.chargePort) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frontDriverDoor != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.frontDriverDoor, fieldNumber: 1)
    }
    if self.frontPassengerDoor != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.frontPassengerDoor, fieldNumber: 2)
    }
    if self.rearDriverDoor != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.rearDriverDoor, fieldNumber: 3)
    }
    if self.rearPassengerDoor != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.rearPassengerDoor, fieldNumber: 4)
    }
    if self.rearTrunk != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.rearTrunk, fieldNumber: 5)
    }
    if self.frontTrunk != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.frontTrunk, fieldNumber: 6)
    }
    if self.chargePort != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.chargePort, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_ClosureStatuses, rhs: VCSEC_ClosureStatuses) -> Bool {
    if lhs.frontDriverDoor != rhs.frontDriverDoor {return false}
    if lhs.frontPassengerDoor != rhs.frontPassengerDoor {return false}
    if lhs.rearDriverDoor != rhs.rearDriverDoor {return false}
    if lhs.rearPassengerDoor != rhs.rearPassengerDoor {return false}
    if lhs.rearTrunk != rhs.rearTrunk {return false}
    if lhs.frontTrunk != rhs.frontTrunk {return false}
    if lhs.chargePort != rhs.chargePort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_CodeDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CodeDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codeDescriptorLocation"),
    2: .same(proto: "version"),
    3: .same(proto: "codeDescriptorBytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.codeDescriptorLocation) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.codeDescriptorBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.codeDescriptorLocation != .none {
      try visitor.visitSingularEnumField(value: self.codeDescriptorLocation, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 2)
    }
    if !self.codeDescriptorBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.codeDescriptorBytes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_CodeDescriptor, rhs: VCSEC_CodeDescriptor) -> Bool {
    if lhs.codeDescriptorLocation != rhs.codeDescriptorLocation {return false}
    if lhs.version != rhs.version {return false}
    if lhs.codeDescriptorBytes != rhs.codeDescriptorBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_CommandStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operationStatus"),
    2: .same(proto: "signedMessageStatus"),
    3: .same(proto: "whitelistOperationStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operationStatus) }()
      case 2: try {
        var v: VCSEC_SignedMessage_status?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .signedMessageStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .signedMessageStatus(v)
        }
      }()
      case 3: try {
        var v: VCSEC_WhitelistOperation_status?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .whitelistOperationStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .whitelistOperationStatus(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operationStatus != .operationstatusOk {
      try visitor.visitSingularEnumField(value: self.operationStatus, fieldNumber: 1)
    }
    switch self.subMessage {
    case .signedMessageStatus?: try {
      guard case .signedMessageStatus(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .whitelistOperationStatus?: try {
      guard case .whitelistOperationStatus(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_CommandStatus, rhs: VCSEC_CommandStatus) -> Bool {
    if lhs.operationStatus != rhs.operationStatus {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_ConnectionMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectionMetrics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "goodConnEventCount"),
    2: .same(proto: "missedConnEventCount"),
    3: .same(proto: "badCRCConnEventCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.goodConnEventCount) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.missedConnEventCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.badCrcconnEventCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.goodConnEventCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.goodConnEventCount, fieldNumber: 1)
    }
    if self.missedConnEventCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.missedConnEventCount, fieldNumber: 2)
    }
    if self.badCrcconnEventCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.badCrcconnEventCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_ConnectionMetrics, rhs: VCSEC_ConnectionMetrics) -> Bool {
    if lhs.goodConnEventCount != rhs.goodConnEventCount {return false}
    if lhs.missedConnEventCount != rhs.missedConnEventCount {return false}
    if lhs.badCrcconnEventCount != rhs.badCrcconnEventCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_DelaySleepRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DelaySleepRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delayTime_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.delayTimeMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.delayTimeMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.delayTimeMs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_DelaySleepRequest, rhs: VCSEC_DelaySleepRequest) -> Bool {
    if lhs.delayTimeMs != rhs.delayTimeMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_DeviceMotion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceMotion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "states"),
    2: .same(proto: "confidence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.states) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.confidence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.states.isEmpty {
      try visitor.visitPackedEnumField(value: self.states, fieldNumber: 1)
    }
    if self.confidence != .unknown {
      try visitor.visitSingularEnumField(value: self.confidence, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_DeviceMotion, rhs: VCSEC_DeviceMotion) -> Bool {
    if lhs.states != rhs.states {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_FromRCI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FromRCI"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.response) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.response.isEmpty {
      try visitor.visitSingularBytesField(value: self.response, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_FromRCI, rhs: VCSEC_FromRCI) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_FromVCSECMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FromVCSECMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vehicleStatus"),
    2: .same(proto: "sessionInfo"),
    3: .same(proto: "authenticationRequest"),
    4: .same(proto: "commandStatus"),
    5: .same(proto: "personalizationInformation"),
    16: .same(proto: "whitelistInfo"),
    17: .same(proto: "whitelistEntryInfo"),
    18: .same(proto: "vehicleInfo"),
    19: .same(proto: "capabilities"),
    21: .same(proto: "keyStatusInfo"),
    22: .same(proto: "activeKey"),
    23: .same(proto: "unknownKeyInfo"),
    30: .same(proto: "updaterCommand"),
    31: .same(proto: "genealogyRequest"),
    32: .same(proto: "sleepManagerRequest"),
    33: .same(proto: "imuRequest"),
    34: .same(proto: "nfcseRequest"),
    35: .same(proto: "TPDataRequest"),
    36: .same(proto: "resetTrackerCommand"),
    37: .same(proto: "TPNotifyTrackerCommand"),
    38: .same(proto: "setTPConfiguration"),
    39: .same(proto: "unsecureNotification"),
    40: .same(proto: "epochSessionInfo"),
    41: .same(proto: "toRCICommand"),
    42: .same(proto: "rciControl"),
    43: .same(proto: "BLEConfigCommand"),
    44: .same(proto: "appDeviceInfoRequest"),
    45: .same(proto: "alert"),
    46: .same(proto: "nominalError"),
    47: .same(proto: "MISessionRequest"),
    48: .same(proto: "MISessionStop"),
    49: .same(proto: "clearTPMSAlarms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: VCSEC_VehicleStatus?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .vehicleStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .vehicleStatus(v)
        }
      }()
      case 2: try {
        var v: VCSEC_SessionInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .sessionInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .sessionInfo(v)
        }
      }()
      case 3: try {
        var v: VCSEC_AuthenticationRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .authenticationRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .authenticationRequest(v)
        }
      }()
      case 4: try {
        var v: VCSEC_CommandStatus?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .commandStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .commandStatus(v)
        }
      }()
      case 5: try {
        var v: VCSEC_PersonalizationInformation?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .personalizationInformation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .personalizationInformation(v)
        }
      }()
      case 16: try {
        var v: VCSEC_WhitelistInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .whitelistInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .whitelistInfo(v)
        }
      }()
      case 17: try {
        var v: VCSEC_WhitelistEntryInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .whitelistEntryInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .whitelistEntryInfo(v)
        }
      }()
      case 18: try {
        var v: VCSEC_VehicleInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .vehicleInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .vehicleInfo(v)
        }
      }()
      case 19: try {
        var v: VCSEC_Capabilities?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .capabilities(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .capabilities(v)
        }
      }()
      case 21: try {
        var v: VCSEC_KeyStatusInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .keyStatusInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .keyStatusInfo(v)
        }
      }()
      case 22: try {
        var v: VCSEC_ActiveKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .activeKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .activeKey(v)
        }
      }()
      case 23: try {
        var v: VCSEC_UnknownKeyInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .unknownKeyInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .unknownKeyInfo(v)
        }
      }()
      case 30: try {
        var v: VCSEC_UpdaterCommand?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .updaterCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .updaterCommand(v)
        }
      }()
      case 31: try {
        var v: VCSEC_GenealogyRequest_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .genealogyRequest(v)
        }
      }()
      case 32: try {
        var v: VCSEC_SleepManagerRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .sleepManagerRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .sleepManagerRequest(v)
        }
      }()
      case 33: try {
        var v: VCSEC_IMURequest_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .imuRequest(v)
        }
      }()
      case 34: try {
        var v: VCSEC_NFCSERequest_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .nfcseRequest(v)
        }
      }()
      case 35: try {
        var v: VCSEC_TPDataRequest_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpdataRequest(v)
        }
      }()
      case 36: try {
        var v: VCSEC_ResetTrackerCommand_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .resetTrackerCommand(v)
        }
      }()
      case 37: try {
        var v: VCSEC_TPNotifyTrackerCommand_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpnotifyTrackerCommand(v)
        }
      }()
      case 38: try {
        var v: VCSEC_SetTPConfigration?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .setTpconfiguration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .setTpconfiguration(v)
        }
      }()
      case 39: try {
        var v: VCSEC_UnsecureNotification?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .unsecureNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .unsecureNotification(v)
        }
      }()
      case 40: try {
        var v: VCSEC_Signatures.SessionInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .epochSessionInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .epochSessionInfo(v)
        }
      }()
      case 41: try {
        var v: VCSEC_ToRCI?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .toRcicommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .toRcicommand(v)
        }
      }()
      case 42: try {
        var v: VCSEC_RCI_control_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .rciControl(v)
        }
      }()
      case 43: try {
        var v: VCSEC_BLEConfigCommand?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .bleconfigCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .bleconfigCommand(v)
        }
      }()
      case 44: try {
        var v: VCSEC_AppDeviceInfoRequest_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .appDeviceInfoRequest(v)
        }
      }()
      case 45: try {
        var v: VCSEC_Alert?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .alert(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .alert(v)
        }
      }()
      case 46: try {
        var v: VCSEC_NominalError?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .nominalError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .nominalError(v)
        }
      }()
      case 47: try {
        var v: VCSEC_MISessionRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .misessionRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .misessionRequest(v)
        }
      }()
      case 48: try {
        var v: VCSEC_MISessionStop?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .misessionStop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .misessionStop(v)
        }
      }()
      case 49: try {
        var v: VCSEC_TPMSAlarms?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .clearTpmsalarms_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .clearTpmsalarms_p(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .vehicleStatus?: try {
      guard case .vehicleStatus(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sessionInfo?: try {
      guard case .sessionInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .authenticationRequest?: try {
      guard case .authenticationRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .commandStatus?: try {
      guard case .commandStatus(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .personalizationInformation?: try {
      guard case .personalizationInformation(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .whitelistInfo?: try {
      guard case .whitelistInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .whitelistEntryInfo?: try {
      guard case .whitelistEntryInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .vehicleInfo?: try {
      guard case .vehicleInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .capabilities?: try {
      guard case .capabilities(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .keyStatusInfo?: try {
      guard case .keyStatusInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .activeKey?: try {
      guard case .activeKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .unknownKeyInfo?: try {
      guard case .unknownKeyInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .updaterCommand?: try {
      guard case .updaterCommand(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .genealogyRequest?: try {
      guard case .genealogyRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 31)
    }()
    case .sleepManagerRequest?: try {
      guard case .sleepManagerRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .imuRequest?: try {
      guard case .imuRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 33)
    }()
    case .nfcseRequest?: try {
      guard case .nfcseRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 34)
    }()
    case .tpdataRequest?: try {
      guard case .tpdataRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 35)
    }()
    case .resetTrackerCommand?: try {
      guard case .resetTrackerCommand(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 36)
    }()
    case .tpnotifyTrackerCommand?: try {
      guard case .tpnotifyTrackerCommand(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 37)
    }()
    case .setTpconfiguration?: try {
      guard case .setTpconfiguration(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .unsecureNotification?: try {
      guard case .unsecureNotification(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .epochSessionInfo?: try {
      guard case .epochSessionInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .toRcicommand?: try {
      guard case .toRcicommand(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .rciControl?: try {
      guard case .rciControl(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 42)
    }()
    case .bleconfigCommand?: try {
      guard case .bleconfigCommand(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .appDeviceInfoRequest?: try {
      guard case .appDeviceInfoRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 44)
    }()
    case .alert?: try {
      guard case .alert(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .nominalError?: try {
      guard case .nominalError(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .misessionRequest?: try {
      guard case .misessionRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .misessionStop?: try {
      guard case .misessionStop(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .clearTpmsalarms_p?: try {
      guard case .clearTpmsalarms_p(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_FromVCSECMessage, rhs: VCSEC_FromVCSECMessage) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_Genealogy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Genealogy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serialNumber"),
    2: .same(proto: "partNumber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.serialNumber) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.partNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serialNumber.isEmpty {
      try visitor.visitSingularBytesField(value: self.serialNumber, fieldNumber: 1)
    }
    if !self.partNumber.isEmpty {
      try visitor.visitSingularBytesField(value: self.partNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_Genealogy, rhs: VCSEC_Genealogy) -> Bool {
    if lhs.serialNumber != rhs.serialNumber {return false}
    if lhs.partNumber != rhs.partNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_GenealogyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenealogyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currentGenealogy"),
    2: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currentGenealogy) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currentGenealogy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.status != .genealogyStatusNone {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_GenealogyResponse, rhs: VCSEC_GenealogyResponse) -> Bool {
    if lhs._currentGenealogy != rhs._currentGenealogy {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_GetCodeDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetCodeDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.location) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.location != .none {
      try visitor.visitSingularEnumField(value: self.location, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_GetCodeDescriptor, rhs: VCSEC_GetCodeDescriptor) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_GetReaderKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetReaderKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.command != .unknown {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_GetReaderKey, rhs: VCSEC_GetReaderKey) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_GetSessionInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetSessionInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_identity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyIdentity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_GetSessionInfoRequest, rhs: VCSEC_GetSessionInfoRequest) -> Bool {
    if lhs._keyIdentity != rhs._keyIdentity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_HandlePulledWithoutAuthDeviceSpecificPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HandlePulledWithoutAuthDeviceSpecificPayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyChannel"),
    2: .same(proto: "authenticationLevel"),
    3: .same(proto: "present"),
    4: .same(proto: "RSSILeft"),
    5: .same(proto: "RSSIRight"),
    6: .same(proto: "RSSIRear"),
    7: .same(proto: "RSSICenter"),
    8: .same(proto: "RSSIFront"),
    9: .same(proto: "RSSISecondary"),
    10: .same(proto: "RSSINFCCradle"),
    11: .same(proto: "RSSIRearLeft"),
    12: .same(proto: "RSSIRearRight"),
    13: .same(proto: "highThreshLeftPresent"),
    14: .same(proto: "highThreshRightPresent"),
    15: .same(proto: "highThreshCenterPresent"),
    16: .same(proto: "highThreshFrontPresent"),
    17: .same(proto: "highThreshRearPresent"),
    18: .same(proto: "highThreshRearLeftPresent"),
    19: .same(proto: "highThreshRearRightPresent"),
    20: .same(proto: "highThreshSecondaryPresent"),
    21: .same(proto: "highThreshNFCPresent"),
    22: .same(proto: "sortedDeltaBayesLeftPresent"),
    23: .same(proto: "sortedDeltaBayesRightPresent"),
    24: .same(proto: "rawDeltaBayesLeftPresent"),
    25: .same(proto: "rawDeltaBayesRightPresent"),
  ]

  fileprivate class _StorageClass {
    var _keyChannel: UInt32 = 0
    var _authenticationLevel: VCSEC_AuthenticationLevel_E = .authenticationLevelNone
    var _present: Bool = false
    var _rssileft: Int32 = 0
    var _rssiright: Int32 = 0
    var _rssirear: Int32 = 0
    var _rssicenter: Int32 = 0
    var _rssifront: Int32 = 0
    var _rssisecondary: Int32 = 0
    var _rssinfccradle: Int32 = 0
    var _rssirearLeft: Int32 = 0
    var _rssirearRight: Int32 = 0
    var _highThreshLeftPresent: Bool = false
    var _highThreshRightPresent: Bool = false
    var _highThreshCenterPresent: Bool = false
    var _highThreshFrontPresent: Bool = false
    var _highThreshRearPresent: Bool = false
    var _highThreshRearLeftPresent: Bool = false
    var _highThreshRearRightPresent: Bool = false
    var _highThreshSecondaryPresent: Bool = false
    var _highThreshNfcpresent: Bool = false
    var _sortedDeltaBayesLeftPresent: Bool = false
    var _sortedDeltaBayesRightPresent: Bool = false
    var _rawDeltaBayesLeftPresent: Bool = false
    var _rawDeltaBayesRightPresent: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _keyChannel = source._keyChannel
      _authenticationLevel = source._authenticationLevel
      _present = source._present
      _rssileft = source._rssileft
      _rssiright = source._rssiright
      _rssirear = source._rssirear
      _rssicenter = source._rssicenter
      _rssifront = source._rssifront
      _rssisecondary = source._rssisecondary
      _rssinfccradle = source._rssinfccradle
      _rssirearLeft = source._rssirearLeft
      _rssirearRight = source._rssirearRight
      _highThreshLeftPresent = source._highThreshLeftPresent
      _highThreshRightPresent = source._highThreshRightPresent
      _highThreshCenterPresent = source._highThreshCenterPresent
      _highThreshFrontPresent = source._highThreshFrontPresent
      _highThreshRearPresent = source._highThreshRearPresent
      _highThreshRearLeftPresent = source._highThreshRearLeftPresent
      _highThreshRearRightPresent = source._highThreshRearRightPresent
      _highThreshSecondaryPresent = source._highThreshSecondaryPresent
      _highThreshNfcpresent = source._highThreshNfcpresent
      _sortedDeltaBayesLeftPresent = source._sortedDeltaBayesLeftPresent
      _sortedDeltaBayesRightPresent = source._sortedDeltaBayesRightPresent
      _rawDeltaBayesLeftPresent = source._rawDeltaBayesLeftPresent
      _rawDeltaBayesRightPresent = source._rawDeltaBayesRightPresent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._keyChannel) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._authenticationLevel) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._present) }()
        case 4: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssileft) }()
        case 5: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssiright) }()
        case 6: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssirear) }()
        case 7: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssicenter) }()
        case 8: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssifront) }()
        case 9: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssisecondary) }()
        case 10: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssinfccradle) }()
        case 11: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssirearLeft) }()
        case 12: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssirearRight) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshLeftPresent) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshRightPresent) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshCenterPresent) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshFrontPresent) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshRearPresent) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshRearLeftPresent) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshRearRightPresent) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshSecondaryPresent) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshNfcpresent) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._sortedDeltaBayesLeftPresent) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._sortedDeltaBayesRightPresent) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._rawDeltaBayesLeftPresent) }()
        case 25: try { try decoder.decodeSingularBoolField(value: &_storage._rawDeltaBayesRightPresent) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._keyChannel != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._keyChannel, fieldNumber: 1)
      }
      if _storage._authenticationLevel != .authenticationLevelNone {
        try visitor.visitSingularEnumField(value: _storage._authenticationLevel, fieldNumber: 2)
      }
      if _storage._present != false {
        try visitor.visitSingularBoolField(value: _storage._present, fieldNumber: 3)
      }
      if _storage._rssileft != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssileft, fieldNumber: 4)
      }
      if _storage._rssiright != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssiright, fieldNumber: 5)
      }
      if _storage._rssirear != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssirear, fieldNumber: 6)
      }
      if _storage._rssicenter != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssicenter, fieldNumber: 7)
      }
      if _storage._rssifront != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssifront, fieldNumber: 8)
      }
      if _storage._rssisecondary != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssisecondary, fieldNumber: 9)
      }
      if _storage._rssinfccradle != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssinfccradle, fieldNumber: 10)
      }
      if _storage._rssirearLeft != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssirearLeft, fieldNumber: 11)
      }
      if _storage._rssirearRight != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssirearRight, fieldNumber: 12)
      }
      if _storage._highThreshLeftPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshLeftPresent, fieldNumber: 13)
      }
      if _storage._highThreshRightPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshRightPresent, fieldNumber: 14)
      }
      if _storage._highThreshCenterPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshCenterPresent, fieldNumber: 15)
      }
      if _storage._highThreshFrontPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshFrontPresent, fieldNumber: 16)
      }
      if _storage._highThreshRearPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshRearPresent, fieldNumber: 17)
      }
      if _storage._highThreshRearLeftPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshRearLeftPresent, fieldNumber: 18)
      }
      if _storage._highThreshRearRightPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshRearRightPresent, fieldNumber: 19)
      }
      if _storage._highThreshSecondaryPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshSecondaryPresent, fieldNumber: 20)
      }
      if _storage._highThreshNfcpresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshNfcpresent, fieldNumber: 21)
      }
      if _storage._sortedDeltaBayesLeftPresent != false {
        try visitor.visitSingularBoolField(value: _storage._sortedDeltaBayesLeftPresent, fieldNumber: 22)
      }
      if _storage._sortedDeltaBayesRightPresent != false {
        try visitor.visitSingularBoolField(value: _storage._sortedDeltaBayesRightPresent, fieldNumber: 23)
      }
      if _storage._rawDeltaBayesLeftPresent != false {
        try visitor.visitSingularBoolField(value: _storage._rawDeltaBayesLeftPresent, fieldNumber: 24)
      }
      if _storage._rawDeltaBayesRightPresent != false {
        try visitor.visitSingularBoolField(value: _storage._rawDeltaBayesRightPresent, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_HandlePulledWithoutAuthDeviceSpecificPayload, rhs: VCSEC_HandlePulledWithoutAuthDeviceSpecificPayload) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._keyChannel != rhs_storage._keyChannel {return false}
        if _storage._authenticationLevel != rhs_storage._authenticationLevel {return false}
        if _storage._present != rhs_storage._present {return false}
        if _storage._rssileft != rhs_storage._rssileft {return false}
        if _storage._rssiright != rhs_storage._rssiright {return false}
        if _storage._rssirear != rhs_storage._rssirear {return false}
        if _storage._rssicenter != rhs_storage._rssicenter {return false}
        if _storage._rssifront != rhs_storage._rssifront {return false}
        if _storage._rssisecondary != rhs_storage._rssisecondary {return false}
        if _storage._rssinfccradle != rhs_storage._rssinfccradle {return false}
        if _storage._rssirearLeft != rhs_storage._rssirearLeft {return false}
        if _storage._rssirearRight != rhs_storage._rssirearRight {return false}
        if _storage._highThreshLeftPresent != rhs_storage._highThreshLeftPresent {return false}
        if _storage._highThreshRightPresent != rhs_storage._highThreshRightPresent {return false}
        if _storage._highThreshCenterPresent != rhs_storage._highThreshCenterPresent {return false}
        if _storage._highThreshFrontPresent != rhs_storage._highThreshFrontPresent {return false}
        if _storage._highThreshRearPresent != rhs_storage._highThreshRearPresent {return false}
        if _storage._highThreshRearLeftPresent != rhs_storage._highThreshRearLeftPresent {return false}
        if _storage._highThreshRearRightPresent != rhs_storage._highThreshRearRightPresent {return false}
        if _storage._highThreshSecondaryPresent != rhs_storage._highThreshSecondaryPresent {return false}
        if _storage._highThreshNfcpresent != rhs_storage._highThreshNfcpresent {return false}
        if _storage._sortedDeltaBayesLeftPresent != rhs_storage._sortedDeltaBayesLeftPresent {return false}
        if _storage._sortedDeltaBayesRightPresent != rhs_storage._sortedDeltaBayesRightPresent {return false}
        if _storage._rawDeltaBayesLeftPresent != rhs_storage._rawDeltaBayesLeftPresent {return false}
        if _storage._rawDeltaBayesRightPresent != rhs_storage._rawDeltaBayesRightPresent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_InformationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InformationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "informationRequestType"),
    2: .same(proto: "keyId"),
    3: .same(proto: "publicKey"),
    4: .same(proto: "slot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.informationRequestType) }()
      case 2: try {
        var v: VCSEC_KeyIdentifier?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .keyID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .keyID(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .publicKey(v)
        }
      }()
      case 4: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .slot(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.informationRequestType != .getStatus {
      try visitor.visitSingularEnumField(value: self.informationRequestType, fieldNumber: 1)
    }
    switch self.subMessage {
    case .keyID?: try {
      guard case .keyID(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .publicKey?: try {
      guard case .publicKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .slot?: try {
      guard case .slot(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_InformationRequest, rhs: VCSEC_InformationRequest) -> Bool {
    if lhs.informationRequestType != rhs.informationRequestType {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_KeyfobInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyfobInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appCRC"),
    2: .standard(proto: "batteryVoltage_mV"),
    3: .standard(proto: "temperature_degreesC"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.appCrc) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.batteryVoltageMV) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.temperatureDegreesC) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appCrc.isEmpty {
      try visitor.visitSingularBytesField(value: self.appCrc, fieldNumber: 1)
    }
    if self.batteryVoltageMV != 0 {
      try visitor.visitSingularUInt32Field(value: self.batteryVoltageMV, fieldNumber: 2)
    }
    if self.temperatureDegreesC != 0 {
      try visitor.visitSingularInt32Field(value: self.temperatureDegreesC, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_KeyfobInfo, rhs: VCSEC_KeyfobInfo) -> Bool {
    if lhs.appCrc != rhs.appCrc {return false}
    if lhs.batteryVoltageMV != rhs.batteryVoltageMV {return false}
    if lhs.temperatureDegreesC != rhs.temperatureDegreesC {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_KeyIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKeySHA1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKeySha1) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKeySha1.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKeySha1, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_KeyIdentifier, rhs: VCSEC_KeyIdentifier) -> Bool {
    if lhs.publicKeySha1 != rhs.publicKeySha1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_KeyIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyIdentity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "key_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .publicKey(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .keyID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .publicKey?: try {
      guard case .publicKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .keyID?: try {
      guard case .keyID(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_KeyIdentity, rhs: VCSEC_KeyIdentity) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_KeyMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyFormFactor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.keyFormFactor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyFormFactor != .unknown {
      try visitor.visitSingularEnumField(value: self.keyFormFactor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_KeyMetadata, rhs: VCSEC_KeyMetadata) -> Bool {
    if lhs.keyFormFactor != rhs.keyFormFactor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_KeyStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyId"),
    2: .same(proto: "nfcPresence"),
    3: .same(proto: "blePresence"),
    4: .same(proto: "publicKey"),
    5: .same(proto: "keyFormFactor"),
    6: .same(proto: "slot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.nfcPresence) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.blePresence) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.keyFormFactor) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.slot) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.nfcPresence != .notPresent {
      try visitor.visitSingularEnumField(value: self.nfcPresence, fieldNumber: 2)
    }
    if self.blePresence != .notPresent {
      try visitor.visitSingularEnumField(value: self.blePresence, fieldNumber: 3)
    }
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.keyFormFactor != .unknown {
      try visitor.visitSingularEnumField(value: self.keyFormFactor, fieldNumber: 5)
    }
    if self.slot != 0 {
      try visitor.visitSingularUInt32Field(value: self.slot, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_KeyStatus, rhs: VCSEC_KeyStatus) -> Bool {
    if lhs._keyID != rhs._keyID {return false}
    if lhs.nfcPresence != rhs.nfcPresence {return false}
    if lhs.blePresence != rhs.blePresence {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.keyFormFactor != rhs.keyFormFactor {return false}
    if lhs.slot != rhs.slot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_KeyStatusInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyStatusInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyStatuses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keyStatuses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyStatuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyStatuses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_KeyStatusInfo, rhs: VCSEC_KeyStatusInfo) -> Bool {
    if lhs.keyStatuses != rhs.keyStatuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_MIConfigurationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MIConfigurationData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data_) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data_.isEmpty {
      try visitor.visitSingularBytesField(value: self.data_, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_MIConfigurationData, rhs: VCSEC_MIConfigurationData) -> Bool {
    if lhs.data_ != rhs.data_ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_MISessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MISessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessionId"),
    2: .same(proto: "accessoryConfigurationData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.accessoryConfigurationData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sessionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.sessionID, fieldNumber: 1)
    }
    if !self.accessoryConfigurationData.isEmpty {
      try visitor.visitSingularBytesField(value: self.accessoryConfigurationData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_MISessionRequest, rhs: VCSEC_MISessionRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.accessoryConfigurationData != rhs.accessoryConfigurationData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_MISessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MISessionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessionId"),
    2: .same(proto: "MIConfigurationData"),
    3: .same(proto: "errorCode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sessionID) }()
      case 2: try {
        var v: VCSEC_MIConfigurationData?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .miconfigurationData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .miconfigurationData(v)
        }
      }()
      case 3: try {
        var v: VCSEC_MIError_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .errorCode(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.sessionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.sessionID, fieldNumber: 1)
    }
    switch self.subMessage {
    case .miconfigurationData?: try {
      guard case .miconfigurationData(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .errorCode?: try {
      guard case .errorCode(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_MISessionResponse, rhs: VCSEC_MISessionResponse) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_MISessionStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MISessionStop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .sessionID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .sessionID(let v)? = self.subMessage {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_MISessionStop, rhs: VCSEC_MISessionStop) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_MISessionStopped: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MISessionStopped"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .sessionID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .sessionID(let v)? = self.subMessage {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_MISessionStopped, rhs: VCSEC_MISessionStopped) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_NFCSEState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NFCSEState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devicePubKeyState"),
    2: .same(proto: "vehiclePubKeyState"),
    3: .same(proto: "sharedSecretState"),
    4: .same(proto: "insecureCommandState"),
    5: .same(proto: "vehiclePubKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.devicePubKeyState) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.vehiclePubKeyState) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.sharedSecretState) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.insecureCommandState) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._vehiclePubKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.devicePubKeyState != .nfcsecDevicepubkeyStateNone {
      try visitor.visitSingularEnumField(value: self.devicePubKeyState, fieldNumber: 1)
    }
    if self.vehiclePubKeyState != .nfcsecVehiclepubkeyStateNone {
      try visitor.visitSingularEnumField(value: self.vehiclePubKeyState, fieldNumber: 2)
    }
    if self.sharedSecretState != .nfcsecSharedsecretStateNone {
      try visitor.visitSingularEnumField(value: self.sharedSecretState, fieldNumber: 3)
    }
    if self.insecureCommandState != .nfcsecInsecureCommandStateNone {
      try visitor.visitSingularEnumField(value: self.insecureCommandState, fieldNumber: 4)
    }
    try { if let v = self._vehiclePubKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_NFCSEState, rhs: VCSEC_NFCSEState) -> Bool {
    if lhs.devicePubKeyState != rhs.devicePubKeyState {return false}
    if lhs.vehiclePubKeyState != rhs.vehiclePubKeyState {return false}
    if lhs.sharedSecretState != rhs.sharedSecretState {return false}
    if lhs.insecureCommandState != rhs.insecureCommandState {return false}
    if lhs._vehiclePubKey != rhs._vehiclePubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_NominalError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NominalError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "genericError"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.genericError) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.genericError != .genericerrorNone {
      try visitor.visitSingularEnumField(value: self.genericError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_NominalError, rhs: VCSEC_NominalError) -> Bool {
    if lhs.genericError != rhs.genericError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_PermissionChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PermissionChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "permission"),
    3: .same(proto: "secondsToBeActive"),
    4: .same(proto: "keyRole"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.permission) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.secondsToBeActive) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.keyRole) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.permission.isEmpty {
      try visitor.visitPackedEnumField(value: self.permission, fieldNumber: 2)
    }
    if self.secondsToBeActive != 0 {
      try visitor.visitSingularUInt32Field(value: self.secondsToBeActive, fieldNumber: 3)
    }
    if self.keyRole != .none {
      try visitor.visitSingularEnumField(value: self.keyRole, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_PermissionChange, rhs: VCSEC_PermissionChange) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.permission != rhs.permission {return false}
    if lhs.secondsToBeActive != rhs.secondsToBeActive {return false}
    if lhs.keyRole != rhs.keyRole {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_PersonalizationInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PersonalizationInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VIN"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.vin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vin.isEmpty {
      try visitor.visitSingularBytesField(value: self.vin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_PersonalizationInformation, rhs: VCSEC_PersonalizationInformation) -> Bool {
    if lhs.vin != rhs.vin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_PublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PublicKeyRaw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKeyRaw) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKeyRaw.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKeyRaw, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_PublicKey, rhs: VCSEC_PublicKey) -> Bool {
    if lhs.publicKeyRaw != rhs.publicKeyRaw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_RCISignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RCISignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .same(proto: "tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.tag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 1)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularBytesField(value: self.tag, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_RCISignature, rhs: VCSEC_RCISignature) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_ReplaceKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReplaceKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "keyToAdd"),
    4: .same(proto: "keyRole"),
    5: .same(proto: "impermanent"),
    1: .same(proto: "publicKeyToReplace"),
    2: .same(proto: "slotToReplace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: VCSEC_PublicKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .publicKeyToReplace(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .publicKeyToReplace(v)
        }
      }()
      case 2: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .slotToReplace(v)
        }
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._keyToAdd) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.keyRole) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.impermanent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .publicKeyToReplace?: try {
      guard case .publicKeyToReplace(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .slotToReplace?: try {
      guard case .slotToReplace(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._keyToAdd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.keyRole != .none {
      try visitor.visitSingularEnumField(value: self.keyRole, fieldNumber: 4)
    }
    if self.impermanent != false {
      try visitor.visitSingularBoolField(value: self.impermanent, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_ReplaceKey, rhs: VCSEC_ReplaceKey) -> Bool {
    if lhs._keyToAdd != rhs._keyToAdd {return false}
    if lhs.keyRole != rhs.keyRole {return false}
    if lhs.impermanent != rhs.impermanent {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_ResetTrackerStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetTrackerStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "totalResetsDueToPowerOn"),
    2: .same(proto: "totalResetsDueToPinReset"),
    3: .same(proto: "totalResetsDueToVDDSLoss"),
    4: .same(proto: "totalResetsDueToVDDLoss"),
    5: .same(proto: "totalResetsDueToVDDRLoss"),
    6: .same(proto: "totalResetsDueToClockLoss"),
    7: .same(proto: "totalResetsDueToSystemReset"),
    8: .same(proto: "totalResetsDueToWarmReset"),
    9: .same(proto: "totalResetsDueToWakeupFromShutdown"),
    10: .same(proto: "totalResetsDueToWakeupFromTCKNoise"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToPowerOn) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToPinReset) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToVddsloss) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToVddloss) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToVddrloss) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToClockLoss) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToSystemReset) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToWarmReset) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToWakeupFromShutdown) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToWakeupFromTcknoise) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalResetsDueToPowerOn != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToPowerOn, fieldNumber: 1)
    }
    if self.totalResetsDueToPinReset != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToPinReset, fieldNumber: 2)
    }
    if self.totalResetsDueToVddsloss != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToVddsloss, fieldNumber: 3)
    }
    if self.totalResetsDueToVddloss != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToVddloss, fieldNumber: 4)
    }
    if self.totalResetsDueToVddrloss != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToVddrloss, fieldNumber: 5)
    }
    if self.totalResetsDueToClockLoss != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToClockLoss, fieldNumber: 6)
    }
    if self.totalResetsDueToSystemReset != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToSystemReset, fieldNumber: 7)
    }
    if self.totalResetsDueToWarmReset != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToWarmReset, fieldNumber: 8)
    }
    if self.totalResetsDueToWakeupFromShutdown != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToWakeupFromShutdown, fieldNumber: 9)
    }
    if self.totalResetsDueToWakeupFromTcknoise != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToWakeupFromTcknoise, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_ResetTrackerStats, rhs: VCSEC_ResetTrackerStats) -> Bool {
    if lhs.totalResetsDueToPowerOn != rhs.totalResetsDueToPowerOn {return false}
    if lhs.totalResetsDueToPinReset != rhs.totalResetsDueToPinReset {return false}
    if lhs.totalResetsDueToVddsloss != rhs.totalResetsDueToVddsloss {return false}
    if lhs.totalResetsDueToVddloss != rhs.totalResetsDueToVddloss {return false}
    if lhs.totalResetsDueToVddrloss != rhs.totalResetsDueToVddrloss {return false}
    if lhs.totalResetsDueToClockLoss != rhs.totalResetsDueToClockLoss {return false}
    if lhs.totalResetsDueToSystemReset != rhs.totalResetsDueToSystemReset {return false}
    if lhs.totalResetsDueToWarmReset != rhs.totalResetsDueToWarmReset {return false}
    if lhs.totalResetsDueToWakeupFromShutdown != rhs.totalResetsDueToWakeupFromShutdown {return false}
    if lhs.totalResetsDueToWakeupFromTcknoise != rhs.totalResetsDueToWakeupFromTcknoise {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_SessionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "counter"),
    3: .same(proto: "publicKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.counter) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularBytesField(value: self.token, fieldNumber: 1)
    }
    if self.counter != 0 {
      try visitor.visitSingularUInt32Field(value: self.counter, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_SessionInfo, rhs: VCSEC_SessionInfo) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.counter != rhs.counter {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_SetTPConfigration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetTPConfigration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stationaryConfig"),
    2: .same(proto: "motionConfig"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stationaryConfig) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._motionConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stationaryConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._motionConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_SetTPConfigration, rhs: VCSEC_SetTPConfigration) -> Bool {
    if lhs._stationaryConfig != rhs._stationaryConfig {return false}
    if lhs._motionConfig != rhs._motionConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_SetUpdaterLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetUpdaterLocation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterLocation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.updaterLocation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.updaterLocation != .none {
      try visitor.visitSingularEnumField(value: self.updaterLocation, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_SetUpdaterLocation, rhs: VCSEC_SetUpdaterLocation) -> Bool {
    if lhs.updaterLocation != rhs.updaterLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_Signatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Signatures"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_Signatures, rhs: VCSEC_Signatures) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_Signatures.SessionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = VCSEC_Signatures.protoMessageName + ".SessionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "counter"),
    2: .same(proto: "publicKey"),
    3: .same(proto: "epoch"),
    4: .standard(proto: "clock_time"),
    5: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.counter) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.epoch) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self.clockTime) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.counter != 0 {
      try visitor.visitSingularUInt32Field(value: self.counter, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 2)
    }
    if !self.epoch.isEmpty {
      try visitor.visitSingularBytesField(value: self.epoch, fieldNumber: 3)
    }
    if self.clockTime != 0 {
      try visitor.visitSingularFixed32Field(value: self.clockTime, fieldNumber: 4)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_Signatures.SessionInfo, rhs: VCSEC_Signatures.SessionInfo) -> Bool {
    if lhs.counter != rhs.counter {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.clockTime != rhs.clockTime {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_SignedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "protobufMessageAsBytes"),
    3: .same(proto: "signatureType"),
    4: .same(proto: "signature"),
    5: .same(proto: "keyId"),
    6: .same(proto: "counter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.protobufMessageAsBytes) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.signatureType) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.keyID) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.counter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularBytesField(value: self.token, fieldNumber: 1)
    }
    if !self.protobufMessageAsBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.protobufMessageAsBytes, fieldNumber: 2)
    }
    if self.signatureType != .aesGcm {
      try visitor.visitSingularEnumField(value: self.signatureType, fieldNumber: 3)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 4)
    }
    if !self.keyID.isEmpty {
      try visitor.visitSingularBytesField(value: self.keyID, fieldNumber: 5)
    }
    if self.counter != 0 {
      try visitor.visitSingularUInt32Field(value: self.counter, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_SignedMessage, rhs: VCSEC_SignedMessage) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.protobufMessageAsBytes != rhs.protobufMessageAsBytes {return false}
    if lhs.signatureType != rhs.signatureType {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.counter != rhs.counter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_SignedMessage_status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedMessage_status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "counter"),
    2: .same(proto: "signedMessageInformation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.counter) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.signedMessageInformation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.counter != 0 {
      try visitor.visitSingularUInt32Field(value: self.counter, fieldNumber: 1)
    }
    if self.signedMessageInformation != .signedmessageInformationNone {
      try visitor.visitSingularEnumField(value: self.signedMessageInformation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_SignedMessage_status, rhs: VCSEC_SignedMessage_status) -> Bool {
    if lhs.counter != rhs.counter {return false}
    if lhs.signedMessageInformation != rhs.signedMessageInformation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_SleepManagerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SleepManagerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delaySleepRequest"),
    2: .same(proto: "sleepManagerCommand"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: VCSEC_DelaySleepRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .delaySleepRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .delaySleepRequest(v)
        }
      }()
      case 2: try {
        var v: VCSEC_SleepManagerCommand_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .sleepManagerCommand(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .delaySleepRequest?: try {
      guard case .delaySleepRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sleepManagerCommand?: try {
      guard case .sleepManagerCommand(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_SleepManagerRequest, rhs: VCSEC_SleepManagerRequest) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_SleepManagerStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SleepManagerStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "totalCPUTime"),
    2: .same(proto: "totalAwakeTime"),
    3: .same(proto: "isBLETrimApplied"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.totalCputime) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.totalAwakeTime) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.isBletrimApplied) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalCputime != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalCputime, fieldNumber: 1)
    }
    if self.totalAwakeTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalAwakeTime, fieldNumber: 2)
    }
    if self.isBletrimApplied != .bleAdditionalTrimAppliedNone {
      try visitor.visitSingularEnumField(value: self.isBletrimApplied, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_SleepManagerStats, rhs: VCSEC_SleepManagerStats) -> Bool {
    if lhs.totalCputime != rhs.totalCputime {return false}
    if lhs.totalAwakeTime != rhs.totalAwakeTime {return false}
    if lhs.isBletrimApplied != rhs.isBletrimApplied {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_StageBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StageBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockAddress"),
    2: .same(proto: "blockToStage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.blockAddress) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.blockToStage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.blockAddress != 0 {
      try visitor.visitSingularUInt32Field(value: self.blockAddress, fieldNumber: 1)
    }
    if !self.blockToStage.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockToStage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_StageBlock, rhs: VCSEC_StageBlock) -> Bool {
    if lhs.blockAddress != rhs.blockAddress {return false}
    if lhs.blockToStage != rhs.blockToStage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_ToRCI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ToRCI"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .standard(proto: "HMAC_signature"),
    3: .standard(proto: "rci_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.command) }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .hmacSignature(v)
        }
      }()
      case 3: try {
        var v: VCSEC_RCISignature?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .rciSignature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .rciSignature(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.command.isEmpty {
      try visitor.visitSingularBytesField(value: self.command, fieldNumber: 1)
    }
    switch self.subMessage {
    case .hmacSignature?: try {
      guard case .hmacSignature(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .rciSignature?: try {
      guard case .rciSignature(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_ToRCI, rhs: VCSEC_ToRCI) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_ToVCSECMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ToVCSECMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signedMessage"),
    2: .same(proto: "unsignedMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: VCSEC_SignedMessage?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .signedMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .signedMessage(v)
        }
      }()
      case 2: try {
        var v: VCSEC_UnsignedMessage?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .unsignedMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .unsignedMessage(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .signedMessage?: try {
      guard case .signedMessage(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .unsignedMessage?: try {
      guard case .unsignedMessage(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_ToVCSECMessage, rhs: VCSEC_ToVCSECMessage) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_TPAdv: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TPAdv"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pressure"),
    2: .same(proto: "temperature"),
    3: .same(proto: "TPNotifyReason"),
    4: .standard(proto: "batteryVoltage_mV"),
    5: .same(proto: "advertismentCount"),
    6: .same(proto: "TPMSAdvType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pressure) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self.temperature) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.tpnotifyReason) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.batteryVoltageMV) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.advertismentCount) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.tpmsadvType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pressure != 0 {
      try visitor.visitSingularInt32Field(value: self.pressure, fieldNumber: 1)
    }
    if self.temperature != 0 {
      try visitor.visitSingularSInt32Field(value: self.temperature, fieldNumber: 2)
    }
    if self.tpnotifyReason != .tpNotifyReasonUnknown {
      try visitor.visitSingularEnumField(value: self.tpnotifyReason, fieldNumber: 3)
    }
    if self.batteryVoltageMV != 0 {
      try visitor.visitSingularUInt32Field(value: self.batteryVoltageMV, fieldNumber: 4)
    }
    if self.advertismentCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.advertismentCount, fieldNumber: 5)
    }
    if self.tpmsadvType != .tpmsAdvTypeSemi {
      try visitor.visitSingularEnumField(value: self.tpmsadvType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_TPAdv, rhs: VCSEC_TPAdv) -> Bool {
    if lhs.pressure != rhs.pressure {return false}
    if lhs.temperature != rhs.temperature {return false}
    if lhs.tpnotifyReason != rhs.tpnotifyReason {return false}
    if lhs.batteryVoltageMV != rhs.batteryVoltageMV {return false}
    if lhs.advertismentCount != rhs.advertismentCount {return false}
    if lhs.tpmsadvType != rhs.tpmsadvType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_TPData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TPData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pressure"),
    2: .same(proto: "temperature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pressure) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self.temperature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pressure != 0 {
      try visitor.visitSingularInt32Field(value: self.pressure, fieldNumber: 1)
    }
    if self.temperature != 0 {
      try visitor.visitSingularSInt32Field(value: self.temperature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_TPData, rhs: VCSEC_TPData) -> Bool {
    if lhs.pressure != rhs.pressure {return false}
    if lhs.temperature != rhs.temperature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_TPLRDetection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TPLRDetection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "LRDetectionResult"),
    2: .standard(proto: "totalPeriod_ms"),
    3: .same(proto: "x90degCnt"),
    4: .same(proto: "x270degCnt"),
    5: .standard(proto: "zAcceleration_dg"),
    6: .same(proto: "zAccelDiffCnt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.lrdetectionResult) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.totalPeriodMs) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.x90DegCnt) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.x270DegCnt) }()
      case 5: try { try decoder.decodeSingularSInt32Field(value: &self.zAccelerationDg) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.zAccelDiffCnt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lrdetectionResult != .rrorMaxcnt {
      try visitor.visitSingularEnumField(value: self.lrdetectionResult, fieldNumber: 1)
    }
    if self.totalPeriodMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalPeriodMs, fieldNumber: 2)
    }
    if self.x90DegCnt != 0 {
      try visitor.visitSingularUInt32Field(value: self.x90DegCnt, fieldNumber: 3)
    }
    if self.x270DegCnt != 0 {
      try visitor.visitSingularUInt32Field(value: self.x270DegCnt, fieldNumber: 4)
    }
    if self.zAccelerationDg != 0 {
      try visitor.visitSingularSInt32Field(value: self.zAccelerationDg, fieldNumber: 5)
    }
    if self.zAccelDiffCnt != 0 {
      try visitor.visitSingularUInt32Field(value: self.zAccelDiffCnt, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_TPLRDetection, rhs: VCSEC_TPLRDetection) -> Bool {
    if lhs.lrdetectionResult != rhs.lrdetectionResult {return false}
    if lhs.totalPeriodMs != rhs.totalPeriodMs {return false}
    if lhs.x90DegCnt != rhs.x90DegCnt {return false}
    if lhs.x270DegCnt != rhs.x270DegCnt {return false}
    if lhs.zAccelerationDg != rhs.zAccelerationDg {return false}
    if lhs.zAccelDiffCnt != rhs.zAccelDiffCnt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_TPMotionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TPMotionConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pressureDelta"),
    2: .same(proto: "temperatureDelta"),
    3: .same(proto: "PTMeasurePeriod"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.pressureDelta) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.temperatureDelta) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.ptmeasurePeriod) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pressureDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.pressureDelta, fieldNumber: 1)
    }
    if self.temperatureDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.temperatureDelta, fieldNumber: 2)
    }
    if self.ptmeasurePeriod != .mlxwakeperiod2Ms {
      try visitor.visitSingularEnumField(value: self.ptmeasurePeriod, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_TPMotionConfig, rhs: VCSEC_TPMotionConfig) -> Bool {
    if lhs.pressureDelta != rhs.pressureDelta {return false}
    if lhs.temperatureDelta != rhs.temperatureDelta {return false}
    if lhs.ptmeasurePeriod != rhs.ptmeasurePeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_TPMSAlarms: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TPMSAlarms"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pressure"),
    2: .same(proto: "temperature"),
    3: .same(proto: "acceleration"),
    4: .same(proto: "voltage"),
    5: .same(proto: "LFDetect"),
    6: .same(proto: "wheelMotion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.pressure) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.temperature) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.acceleration) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.voltage) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.lfdetect) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.wheelMotion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pressure != false {
      try visitor.visitSingularBoolField(value: self.pressure, fieldNumber: 1)
    }
    if self.temperature != false {
      try visitor.visitSingularBoolField(value: self.temperature, fieldNumber: 2)
    }
    if self.acceleration != false {
      try visitor.visitSingularBoolField(value: self.acceleration, fieldNumber: 3)
    }
    if self.voltage != false {
      try visitor.visitSingularBoolField(value: self.voltage, fieldNumber: 4)
    }
    if self.lfdetect != false {
      try visitor.visitSingularBoolField(value: self.lfdetect, fieldNumber: 5)
    }
    if self.wheelMotion != false {
      try visitor.visitSingularBoolField(value: self.wheelMotion, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_TPMSAlarms, rhs: VCSEC_TPMSAlarms) -> Bool {
    if lhs.pressure != rhs.pressure {return false}
    if lhs.temperature != rhs.temperature {return false}
    if lhs.acceleration != rhs.acceleration {return false}
    if lhs.voltage != rhs.voltage {return false}
    if lhs.lfdetect != rhs.lfdetect {return false}
    if lhs.wheelMotion != rhs.wheelMotion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_TPNewSensorData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TPNewSensorData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sensorPublicKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sensorPublicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sensorPublicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_TPNewSensorData, rhs: VCSEC_TPNewSensorData) -> Bool {
    if lhs._sensorPublicKey != rhs._sensorPublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_TPNotifyTrackerStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TPNotifyTrackerStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notifyReasonUnknownCount"),
    2: .same(proto: "notifyReasonLowPressureCount"),
    3: .same(proto: "notifyReasonPTValueUpdateCount"),
    4: .same(proto: "notifyReasonWheelMovingCount"),
    5: .same(proto: "notifyReasonWheelRotationDirectionReadyCount"),
    6: .same(proto: "notifyReasonLFCount"),
    7: .same(proto: "notifyReasonFaultCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.notifyReasonUnknownCount) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.notifyReasonLowPressureCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.notifyReasonPtvalueUpdateCount) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.notifyReasonWheelMovingCount) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.notifyReasonWheelRotationDirectionReadyCount) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.notifyReasonLfcount) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.notifyReasonFaultCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.notifyReasonUnknownCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifyReasonUnknownCount, fieldNumber: 1)
    }
    if self.notifyReasonLowPressureCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifyReasonLowPressureCount, fieldNumber: 2)
    }
    if self.notifyReasonPtvalueUpdateCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifyReasonPtvalueUpdateCount, fieldNumber: 3)
    }
    if self.notifyReasonWheelMovingCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifyReasonWheelMovingCount, fieldNumber: 4)
    }
    if self.notifyReasonWheelRotationDirectionReadyCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifyReasonWheelRotationDirectionReadyCount, fieldNumber: 5)
    }
    if self.notifyReasonLfcount != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifyReasonLfcount, fieldNumber: 6)
    }
    if self.notifyReasonFaultCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifyReasonFaultCount, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_TPNotifyTrackerStats, rhs: VCSEC_TPNotifyTrackerStats) -> Bool {
    if lhs.notifyReasonUnknownCount != rhs.notifyReasonUnknownCount {return false}
    if lhs.notifyReasonLowPressureCount != rhs.notifyReasonLowPressureCount {return false}
    if lhs.notifyReasonPtvalueUpdateCount != rhs.notifyReasonPtvalueUpdateCount {return false}
    if lhs.notifyReasonWheelMovingCount != rhs.notifyReasonWheelMovingCount {return false}
    if lhs.notifyReasonWheelRotationDirectionReadyCount != rhs.notifyReasonWheelRotationDirectionReadyCount {return false}
    if lhs.notifyReasonLfcount != rhs.notifyReasonLfcount {return false}
    if lhs.notifyReasonFaultCount != rhs.notifyReasonFaultCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_TPStationaryConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TPStationaryConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lowPressureThreshold"),
    2: .same(proto: "pressureDelta"),
    3: .same(proto: "accelMeasurePeriod"),
    4: .same(proto: "absoluteAccelWakeThreshold"),
    5: .same(proto: "PTMeasureMod"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.lowPressureThreshold) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pressureDelta) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.accelMeasurePeriod) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.absoluteAccelWakeThreshold) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.ptmeasureMod) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lowPressureThreshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.lowPressureThreshold, fieldNumber: 1)
    }
    if self.pressureDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.pressureDelta, fieldNumber: 2)
    }
    if self.accelMeasurePeriod != .mlxwakeperiod2Ms {
      try visitor.visitSingularEnumField(value: self.accelMeasurePeriod, fieldNumber: 3)
    }
    if self.absoluteAccelWakeThreshold != 0 {
      try visitor.visitSingularInt32Field(value: self.absoluteAccelWakeThreshold, fieldNumber: 4)
    }
    if self.ptmeasureMod != 0 {
      try visitor.visitSingularUInt32Field(value: self.ptmeasureMod, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_TPStationaryConfig, rhs: VCSEC_TPStationaryConfig) -> Bool {
    if lhs.lowPressureThreshold != rhs.lowPressureThreshold {return false}
    if lhs.pressureDelta != rhs.pressureDelta {return false}
    if lhs.accelMeasurePeriod != rhs.accelMeasurePeriod {return false}
    if lhs.absoluteAccelWakeThreshold != rhs.absoluteAccelWakeThreshold {return false}
    if lhs.ptmeasureMod != rhs.ptmeasureMod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_TPWheelUnitInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TPWheelUnitInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TIAppCRC"),
    2: .same(proto: "MLXAppCRC"),
    3: .standard(proto: "batteryVoltage_mV"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tiappCrc) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.mlxappCrc) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.batteryVoltageMV) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tiappCrc.isEmpty {
      try visitor.visitSingularBytesField(value: self.tiappCrc, fieldNumber: 1)
    }
    if !self.mlxappCrc.isEmpty {
      try visitor.visitSingularBytesField(value: self.mlxappCrc, fieldNumber: 2)
    }
    if self.batteryVoltageMV != 0 {
      try visitor.visitSingularUInt32Field(value: self.batteryVoltageMV, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_TPWheelUnitInfo, rhs: VCSEC_TPWheelUnitInfo) -> Bool {
    if lhs.tiappCrc != rhs.tiappCrc {return false}
    if lhs.mlxappCrc != rhs.mlxappCrc {return false}
    if lhs.batteryVoltageMV != rhs.batteryVoltageMV {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_UnknownKeyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnknownKeyInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyStatus"),
    2: .same(proto: "publicKey"),
    3: .same(proto: "keyFormFactor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyStatus) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.keyFormFactor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.keyFormFactor != .unknown {
      try visitor.visitSingularEnumField(value: self.keyFormFactor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_UnknownKeyInfo, rhs: VCSEC_UnknownKeyInfo) -> Bool {
    if lhs._keyStatus != rhs._keyStatus {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.keyFormFactor != rhs.keyFormFactor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_UnsecureNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnsecureNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notifyUser"),
    2: .same(proto: "closureStatuses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.notifyUser) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._closureStatuses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.notifyUser != false {
      try visitor.visitSingularBoolField(value: self.notifyUser, fieldNumber: 1)
    }
    try { if let v = self._closureStatuses {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_UnsecureNotification, rhs: VCSEC_UnsecureNotification) -> Bool {
    if lhs.notifyUser != rhs.notifyUser {return false}
    if lhs._closureStatuses != rhs._closureStatuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_UnsignedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnsignedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    25: .same(proto: "personalizationInformation"),
    1: .same(proto: "InformationRequest"),
    2: .same(proto: "RKEAction"),
    3: .same(proto: "authenticationResponse"),
    4: .same(proto: "closureMoveRequest"),
    5: .same(proto: "TPAdv"),
    16: .same(proto: "WhitelistOperation"),
    20: .same(proto: "updaterResponse"),
    21: .same(proto: "genealogyResponse"),
    22: .same(proto: "setMetaDataForKey"),
    23: .same(proto: "keyfobInfo"),
    24: .same(proto: "IMUState"),
    26: .same(proto: "nfcseState"),
    27: .same(proto: "lowPowerDeviceSleepManagerStats"),
    28: .same(proto: "TPData"),
    29: .same(proto: "TPWheelUnitInfo"),
    30: .same(proto: "resetTrackerStats"),
    31: .same(proto: "TPNotifyTrackerStats"),
    32: .same(proto: "TPNewSensorData"),
    33: .same(proto: "TPLRDetection"),
    34: .same(proto: "connectionMetrics"),
    35: .same(proto: "deviceActivity"),
    36: .same(proto: "getEpochSessionInfo"),
    37: .same(proto: "fromRCIResponse"),
    38: .same(proto: "BLEConfigAll"),
    39: .same(proto: "deviceMotion"),
    40: .same(proto: "appDeviceInfo"),
    41: .same(proto: "getReaderKey"),
    42: .same(proto: "MISessionResponse"),
    43: .same(proto: "MISessionStopped"),
    44: .same(proto: "accelData"),
    45: .same(proto: "TPMSAlarms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: VCSEC_InformationRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .informationRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .informationRequest(v)
        }
      }()
      case 2: try {
        var v: VCSEC_RKEAction_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .rkeaction(v)
        }
      }()
      case 3: try {
        var v: VCSEC_AuthenticationResponse?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .authenticationResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .authenticationResponse(v)
        }
      }()
      case 4: try {
        var v: VCSEC_ClosureMoveRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .closureMoveRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .closureMoveRequest(v)
        }
      }()
      case 5: try {
        var v: VCSEC_TPAdv?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tpadv(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpadv(v)
        }
      }()
      case 16: try {
        var v: VCSEC_WhitelistOperation?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .whitelistOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .whitelistOperation(v)
        }
      }()
      case 20: try {
        var v: VCSEC_UpdaterResponse?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .updaterResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .updaterResponse(v)
        }
      }()
      case 21: try {
        var v: VCSEC_GenealogyResponse?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .genealogyResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .genealogyResponse(v)
        }
      }()
      case 22: try {
        var v: VCSEC_KeyMetadata?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .setMetaDataForKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .setMetaDataForKey(v)
        }
      }()
      case 23: try {
        var v: VCSEC_KeyfobInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .keyfobInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .keyfobInfo(v)
        }
      }()
      case 24: try {
        var v: VCSEC_IMUState_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .imustate(v)
        }
      }()
      case 25: try { try decoder.decodeSingularMessageField(value: &self._personalizationInformation) }()
      case 26: try {
        var v: VCSEC_NFCSEState?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .nfcseState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .nfcseState(v)
        }
      }()
      case 27: try {
        var v: VCSEC_SleepManagerStats?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .lowPowerDeviceSleepManagerStats(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .lowPowerDeviceSleepManagerStats(v)
        }
      }()
      case 28: try {
        var v: VCSEC_TPData?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tpdata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpdata(v)
        }
      }()
      case 29: try {
        var v: VCSEC_TPWheelUnitInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tpwheelUnitInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpwheelUnitInfo(v)
        }
      }()
      case 30: try {
        var v: VCSEC_ResetTrackerStats?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .resetTrackerStats(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .resetTrackerStats(v)
        }
      }()
      case 31: try {
        var v: VCSEC_TPNotifyTrackerStats?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tpnotifyTrackerStats(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpnotifyTrackerStats(v)
        }
      }()
      case 32: try {
        var v: VCSEC_TPNewSensorData?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tpnewSensorData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpnewSensorData(v)
        }
      }()
      case 33: try {
        var v: VCSEC_TPLRDetection?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tplrdetection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tplrdetection(v)
        }
      }()
      case 34: try {
        var v: VCSEC_ConnectionMetrics?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .connectionMetrics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .connectionMetrics(v)
        }
      }()
      case 35: try {
        var v: VCSEC_Activity_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .deviceActivity(v)
        }
      }()
      case 36: try {
        var v: VCSEC_GetSessionInfoRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .getEpochSessionInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .getEpochSessionInfo(v)
        }
      }()
      case 37: try {
        var v: VCSEC_FromRCI?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .fromRciresponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .fromRciresponse(v)
        }
      }()
      case 38: try {
        var v: VCSEC_BLEConfigAll?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .bleconfigAll(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .bleconfigAll(v)
        }
      }()
      case 39: try {
        var v: VCSEC_DeviceMotion?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .deviceMotion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .deviceMotion(v)
        }
      }()
      case 40: try {
        var v: VCSEC_AppDeviceInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .appDeviceInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .appDeviceInfo(v)
        }
      }()
      case 41: try {
        var v: VCSEC_GetReaderKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .getReaderKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .getReaderKey(v)
        }
      }()
      case 42: try {
        var v: VCSEC_MISessionResponse?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .misessionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .misessionResponse(v)
        }
      }()
      case 43: try {
        var v: VCSEC_MISessionStopped?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .misessionStopped(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .misessionStopped(v)
        }
      }()
      case 44: try {
        var v: VCSEC_AccelData?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .accelData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .accelData(v)
        }
      }()
      case 45: try {
        var v: VCSEC_TPMSAlarms?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tpmsalarms(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpmsalarms(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .informationRequest?: try {
      guard case .informationRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .rkeaction?: try {
      guard case .rkeaction(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .authenticationResponse?: try {
      guard case .authenticationResponse(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .closureMoveRequest?: try {
      guard case .closureMoveRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .tpadv?: try {
      guard case .tpadv(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .whitelistOperation?: try {
      guard case .whitelistOperation(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .updaterResponse?: try {
      guard case .updaterResponse(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .genealogyResponse?: try {
      guard case .genealogyResponse(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .setMetaDataForKey?: try {
      guard case .setMetaDataForKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .keyfobInfo?: try {
      guard case .keyfobInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .imustate?: try {
      guard case .imustate(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 24)
    }()
    default: break
    }
    try { if let v = self._personalizationInformation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    } }()
    switch self.subMessage {
    case .nfcseState?: try {
      guard case .nfcseState(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .lowPowerDeviceSleepManagerStats?: try {
      guard case .lowPowerDeviceSleepManagerStats(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .tpdata?: try {
      guard case .tpdata(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .tpwheelUnitInfo?: try {
      guard case .tpwheelUnitInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .resetTrackerStats?: try {
      guard case .resetTrackerStats(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .tpnotifyTrackerStats?: try {
      guard case .tpnotifyTrackerStats(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .tpnewSensorData?: try {
      guard case .tpnewSensorData(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .tplrdetection?: try {
      guard case .tplrdetection(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .connectionMetrics?: try {
      guard case .connectionMetrics(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .deviceActivity?: try {
      guard case .deviceActivity(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 35)
    }()
    case .getEpochSessionInfo?: try {
      guard case .getEpochSessionInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .fromRciresponse?: try {
      guard case .fromRciresponse(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .bleconfigAll?: try {
      guard case .bleconfigAll(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .deviceMotion?: try {
      guard case .deviceMotion(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .appDeviceInfo?: try {
      guard case .appDeviceInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .getReaderKey?: try {
      guard case .getReaderKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .misessionResponse?: try {
      guard case .misessionResponse(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .misessionStopped?: try {
      guard case .misessionStopped(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .accelData?: try {
      guard case .accelData(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .tpmsalarms?: try {
      guard case .tpmsalarms(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_UnsignedMessage, rhs: VCSEC_UnsignedMessage) -> Bool {
    if lhs._personalizationInformation != rhs._personalizationInformation {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_UpdaterCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdaterCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "getCodeDescriptor"),
    2: .same(proto: "setUpdaterLocation"),
    3: .same(proto: "stageBlock"),
    4: .same(proto: "verifyAndInstallApp"),
    5: .same(proto: "firmwareInfo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: VCSEC_GetCodeDescriptor?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .getCodeDescriptor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .getCodeDescriptor(v)
        }
      }()
      case 2: try {
        var v: VCSEC_SetUpdaterLocation?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .setUpdaterLocation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .setUpdaterLocation(v)
        }
      }()
      case 3: try {
        var v: VCSEC_StageBlock?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .stageBlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .stageBlock(v)
        }
      }()
      case 4: try {
        var v: VCSEC_VerifyAndInstallApp?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .verifyAndInstallApp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .verifyAndInstallApp(v)
        }
      }()
      case 5: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .firmwareInfo(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .getCodeDescriptor?: try {
      guard case .getCodeDescriptor(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .setUpdaterLocation?: try {
      guard case .setUpdaterLocation(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .stageBlock?: try {
      guard case .stageBlock(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .verifyAndInstallApp?: try {
      guard case .verifyAndInstallApp(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .firmwareInfo?: try {
      guard case .firmwareInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_UpdaterCommand, rhs: VCSEC_UpdaterCommand) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_UpdaterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdaterResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codeDescriptorMessage"),
    2: .same(proto: "updaterStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: VCSEC_CodeDescriptor?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .codeDescriptorMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .codeDescriptorMessage(v)
        }
      }()
      case 2: try {
        var v: VCSEC_UpdaterStatus?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .updaterStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .updaterStatus(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .codeDescriptorMessage?: try {
      guard case .codeDescriptorMessage(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .updaterStatus?: try {
      guard case .updaterStatus(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_UpdaterResponse, rhs: VCSEC_UpdaterResponse) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_UpdaterStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdaterStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "statusCode"),
    2: .same(proto: "location"),
    3: .same(proto: "nextAddressNumber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.statusCode) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.location) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.nextAddressNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.statusCode != .error {
      try visitor.visitSingularEnumField(value: self.statusCode, fieldNumber: 1)
    }
    if self.location != .none {
      try visitor.visitSingularEnumField(value: self.location, fieldNumber: 2)
    }
    if self.nextAddressNumber != 0 {
      try visitor.visitSingularUInt32Field(value: self.nextAddressNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_UpdaterStatus, rhs: VCSEC_UpdaterStatus) -> Bool {
    if lhs.statusCode != rhs.statusCode {return false}
    if lhs.location != rhs.location {return false}
    if lhs.nextAddressNumber != rhs.nextAddressNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_VehicleInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VIN"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vin.isEmpty {
      try visitor.visitSingularStringField(value: self.vin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_VehicleInfo, rhs: VCSEC_VehicleInfo) -> Bool {
    if lhs.vin != rhs.vin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_VehicleStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "closureStatuses"),
    2: .same(proto: "vehicleLockState"),
    3: .same(proto: "vehicleSleepStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._closureStatuses) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.vehicleLockState) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.vehicleSleepStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._closureStatuses {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.vehicleLockState != .vehiclelockstateUnlocked {
      try visitor.visitSingularEnumField(value: self.vehicleLockState, fieldNumber: 2)
    }
    if self.vehicleSleepStatus != .vehicleSleepStatusUnknown {
      try visitor.visitSingularEnumField(value: self.vehicleSleepStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_VehicleStatus, rhs: VCSEC_VehicleStatus) -> Bool {
    if lhs._closureStatuses != rhs._closureStatuses {return false}
    if lhs.vehicleLockState != rhs.vehicleLockState {return false}
    if lhs.vehicleSleepStatus != rhs.vehicleSleepStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_VerifyAndInstallApp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyAndInstallApp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sha256"),
    2: .same(proto: "rValue"),
    3: .same(proto: "sValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sha256) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rValue) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.sValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sha256.isEmpty {
      try visitor.visitSingularBytesField(value: self.sha256, fieldNumber: 1)
    }
    if !self.rValue.isEmpty {
      try visitor.visitSingularBytesField(value: self.rValue, fieldNumber: 2)
    }
    if !self.sValue.isEmpty {
      try visitor.visitSingularBytesField(value: self.sValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_VerifyAndInstallApp, rhs: VCSEC_VerifyAndInstallApp) -> Bool {
    if lhs.sha256 != rhs.sha256 {return false}
    if lhs.rValue != rhs.rValue {return false}
    if lhs.sValue != rhs.sValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_WhitelistEntryInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WhitelistEntryInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyId"),
    2: .same(proto: "publicKey"),
    3: .same(proto: "permissions"),
    4: .same(proto: "metadataForKey"),
    5: .same(proto: "secondsEntryRemainsActive"),
    6: .same(proto: "slot"),
    7: .same(proto: "keyRole"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.permissions) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadataForKey) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.secondsEntryRemainsActive) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.slot) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.keyRole) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.permissions.isEmpty {
      try visitor.visitPackedEnumField(value: self.permissions, fieldNumber: 3)
    }
    try { if let v = self._metadataForKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.secondsEntryRemainsActive != 0 {
      try visitor.visitSingularUInt32Field(value: self.secondsEntryRemainsActive, fieldNumber: 5)
    }
    if self.slot != 0 {
      try visitor.visitSingularUInt32Field(value: self.slot, fieldNumber: 6)
    }
    if self.keyRole != .none {
      try visitor.visitSingularEnumField(value: self.keyRole, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_WhitelistEntryInfo, rhs: VCSEC_WhitelistEntryInfo) -> Bool {
    if lhs._keyID != rhs._keyID {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs._metadataForKey != rhs._metadataForKey {return false}
    if lhs.secondsEntryRemainsActive != rhs.secondsEntryRemainsActive {return false}
    if lhs.slot != rhs.slot {return false}
    if lhs.keyRole != rhs.keyRole {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_WhitelistInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WhitelistInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numberOfEntries"),
    2: .same(proto: "whitelistEntries"),
    3: .same(proto: "slotMask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.numberOfEntries) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.whitelistEntries) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.slotMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numberOfEntries != 0 {
      try visitor.visitSingularUInt32Field(value: self.numberOfEntries, fieldNumber: 1)
    }
    if !self.whitelistEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.whitelistEntries, fieldNumber: 2)
    }
    if self.slotMask != 0 {
      try visitor.visitSingularUInt32Field(value: self.slotMask, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_WhitelistInfo, rhs: VCSEC_WhitelistInfo) -> Bool {
    if lhs.numberOfEntries != rhs.numberOfEntries {return false}
    if lhs.whitelistEntries != rhs.whitelistEntries {return false}
    if lhs.slotMask != rhs.slotMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_WhitelistOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WhitelistOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "metadataForKey"),
    1: .same(proto: "addPublicKeyToWhitelist"),
    2: .same(proto: "removePublicKeyFromWhitelist"),
    3: .same(proto: "addPermissionsToPublicKey"),
    4: .same(proto: "removePermissionsFromPublicKey"),
    5: .same(proto: "addKeyToWhitelistAndAddPermissions"),
    7: .same(proto: "updateKeyAndPermissions"),
    8: .same(proto: "addImpermanentKey"),
    9: .same(proto: "addImpermanentKeyAndRemoveExisting"),
    16: .same(proto: "removeAllImpermanentKeys"),
    17: .same(proto: "replaceKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: VCSEC_PublicKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addPublicKeyToWhitelist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addPublicKeyToWhitelist(v)
        }
      }()
      case 2: try {
        var v: VCSEC_PublicKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .removePublicKeyFromWhitelist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .removePublicKeyFromWhitelist(v)
        }
      }()
      case 3: try {
        var v: VCSEC_PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addPermissionsToPublicKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addPermissionsToPublicKey(v)
        }
      }()
      case 4: try {
        var v: VCSEC_PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .removePermissionsFromPublicKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .removePermissionsFromPublicKey(v)
        }
      }()
      case 5: try {
        var v: VCSEC_PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addKeyToWhitelistAndAddPermissions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addKeyToWhitelistAndAddPermissions(v)
        }
      }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._metadataForKey) }()
      case 7: try {
        var v: VCSEC_PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .updateKeyAndPermissions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .updateKeyAndPermissions(v)
        }
      }()
      case 8: try {
        var v: VCSEC_PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addImpermanentKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addImpermanentKey(v)
        }
      }()
      case 9: try {
        var v: VCSEC_PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addImpermanentKeyAndRemoveExisting(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addImpermanentKeyAndRemoveExisting(v)
        }
      }()
      case 16: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .removeAllImpermanentKeys(v)
        }
      }()
      case 17: try {
        var v: VCSEC_ReplaceKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .replaceKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .replaceKey(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .addPublicKeyToWhitelist?: try {
      guard case .addPublicKeyToWhitelist(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .removePublicKeyFromWhitelist?: try {
      guard case .removePublicKeyFromWhitelist(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .addPermissionsToPublicKey?: try {
      guard case .addPermissionsToPublicKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .removePermissionsFromPublicKey?: try {
      guard case .removePermissionsFromPublicKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .addKeyToWhitelistAndAddPermissions?: try {
      guard case .addKeyToWhitelistAndAddPermissions(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    default: break
    }
    try { if let v = self._metadataForKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    switch self.subMessage {
    case .updateKeyAndPermissions?: try {
      guard case .updateKeyAndPermissions(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .addImpermanentKey?: try {
      guard case .addImpermanentKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .addImpermanentKeyAndRemoveExisting?: try {
      guard case .addImpermanentKeyAndRemoveExisting(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .removeAllImpermanentKeys?: try {
      guard case .removeAllImpermanentKeys(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
    }()
    case .replaceKey?: try {
      guard case .replaceKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_WhitelistOperation, rhs: VCSEC_WhitelistOperation) -> Bool {
    if lhs._metadataForKey != rhs._metadataForKey {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VCSEC_WhitelistOperation_status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WhitelistOperation_status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "whitelistOperationInformation"),
    2: .same(proto: "signerOfOperation"),
    3: .same(proto: "operationStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.whitelistOperationInformation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signerOfOperation) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.operationStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.whitelistOperationInformation != .whitelistoperationInformationNone {
      try visitor.visitSingularEnumField(value: self.whitelistOperationInformation, fieldNumber: 1)
    }
    try { if let v = self._signerOfOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.operationStatus != .operationstatusOk {
      try visitor.visitSingularEnumField(value: self.operationStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VCSEC_WhitelistOperation_status, rhs: VCSEC_WhitelistOperation_status) -> Bool {
    if lhs.whitelistOperationInformation != rhs.whitelistOperationInformation {return false}
    if lhs._signerOfOperation != rhs._signerOfOperation {return false}
    if lhs.operationStatus != rhs.operationStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
