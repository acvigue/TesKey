// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: car_server.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.
//
// Adapted from https://github.com/teslamotors/vehicle-command

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum HvacSeatCoolerActions_HvacSeatCoolerLevel_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case hvacSeatCoolerLevelUnknown // = 0
  case hvacSeatCoolerLevelOff // = 1
  case hvacSeatCoolerLevelLow // = 2
  case hvacSeatCoolerLevelMed // = 3
  case hvacSeatCoolerLevelHigh // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .hvacSeatCoolerLevelUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .hvacSeatCoolerLevelUnknown
    case 1: self = .hvacSeatCoolerLevelOff
    case 2: self = .hvacSeatCoolerLevelLow
    case 3: self = .hvacSeatCoolerLevelMed
    case 4: self = .hvacSeatCoolerLevelHigh
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .hvacSeatCoolerLevelUnknown: return 0
    case .hvacSeatCoolerLevelOff: return 1
    case .hvacSeatCoolerLevelLow: return 2
    case .hvacSeatCoolerLevelMed: return 3
    case .hvacSeatCoolerLevelHigh: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension HvacSeatCoolerActions_HvacSeatCoolerLevel_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [HvacSeatCoolerActions_HvacSeatCoolerLevel_E] = [
    .hvacSeatCoolerLevelUnknown,
    .hvacSeatCoolerLevelOff,
    .hvacSeatCoolerLevelLow,
    .hvacSeatCoolerLevelMed,
    .hvacSeatCoolerLevelHigh,
  ]
}

#endif  // swift(>=4.2)

enum HvacSeatCoolerActions_HvacSeatCoolerPosition_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case hvacSeatCoolerPositionUnknown // = 0
  case hvacSeatCoolerPositionFrontLeft // = 1
  case hvacSeatCoolerPositionFrontRight // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .hvacSeatCoolerPositionUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .hvacSeatCoolerPositionUnknown
    case 1: self = .hvacSeatCoolerPositionFrontLeft
    case 2: self = .hvacSeatCoolerPositionFrontRight
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .hvacSeatCoolerPositionUnknown: return 0
    case .hvacSeatCoolerPositionFrontLeft: return 1
    case .hvacSeatCoolerPositionFrontRight: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension HvacSeatCoolerActions_HvacSeatCoolerPosition_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [HvacSeatCoolerActions_HvacSeatCoolerPosition_E] = [
    .hvacSeatCoolerPositionUnknown,
    .hvacSeatCoolerPositionFrontLeft,
    .hvacSeatCoolerPositionFrontRight,
  ]
}

#endif  // swift(>=4.2)

enum HvacSetPreconditioningMaxAction_ManualOverrideMode_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case hvacSetPreconditioningMaxActionDogMode // = 0
  case hvacSetPreconditioningMaxActionSoc // = 1
  case hvacSetPreconditioningMaxActionDoors // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .hvacSetPreconditioningMaxActionDogMode
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .hvacSetPreconditioningMaxActionDogMode
    case 1: self = .hvacSetPreconditioningMaxActionSoc
    case 2: self = .hvacSetPreconditioningMaxActionDoors
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .hvacSetPreconditioningMaxActionDogMode: return 0
    case .hvacSetPreconditioningMaxActionSoc: return 1
    case .hvacSetPreconditioningMaxActionDoors: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension HvacSetPreconditioningMaxAction_ManualOverrideMode_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [HvacSetPreconditioningMaxAction_ManualOverrideMode_E] = [
    .hvacSetPreconditioningMaxActionDogMode,
    .hvacSetPreconditioningMaxActionSoc,
    .hvacSetPreconditioningMaxActionDoors,
  ]
}

#endif  // swift(>=4.2)

enum AutoSeatClimateAction_AutoSeatPosition_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case autoSeatPositionUnknown // = 0
  case autoSeatPositionFrontLeft // = 1
  case autoSeatPositionFrontRight // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .autoSeatPositionUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .autoSeatPositionUnknown
    case 1: self = .autoSeatPositionFrontLeft
    case 2: self = .autoSeatPositionFrontRight
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .autoSeatPositionUnknown: return 0
    case .autoSeatPositionFrontLeft: return 1
    case .autoSeatPositionFrontRight: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension AutoSeatClimateAction_AutoSeatPosition_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AutoSeatClimateAction_AutoSeatPosition_E] = [
    .autoSeatPositionUnknown,
    .autoSeatPositionFrontLeft,
    .autoSeatPositionFrontRight,
  ]
}

#endif  // swift(>=4.2)

enum HvacClimateKeeperAction_ClimateKeeperAction_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case climateKeeperActionOff // = 0
  case climateKeeperActionOn // = 1
  case climateKeeperActionDog // = 2
  case climateKeeperActionCamp // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .climateKeeperActionOff
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .climateKeeperActionOff
    case 1: self = .climateKeeperActionOn
    case 2: self = .climateKeeperActionDog
    case 3: self = .climateKeeperActionCamp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .climateKeeperActionOff: return 0
    case .climateKeeperActionOn: return 1
    case .climateKeeperActionDog: return 2
    case .climateKeeperActionCamp: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension HvacClimateKeeperAction_ClimateKeeperAction_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [HvacClimateKeeperAction_ClimateKeeperAction_E] = [
    .climateKeeperActionOff,
    .climateKeeperActionOn,
    .climateKeeperActionDog,
    .climateKeeperActionCamp,
  ]
}

#endif  // swift(>=4.2)

struct Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionMsg: Action.OneOf_ActionMsg? = nil

  var vehicleAction: VehicleAction {
    get {
      if case .vehicleAction(let v)? = actionMsg {return v}
      return VehicleAction()
    }
    set {actionMsg = .vehicleAction(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ActionMsg: Equatable {
    case vehicleAction(VehicleAction)

  #if !swift(>=4.1)
    static func ==(lhs: Action.OneOf_ActionMsg, rhs: Action.OneOf_ActionMsg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.vehicleAction, .vehicleAction): return {
        guard case .vehicleAction(let l) = lhs, case .vehicleAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

struct VehicleAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vehicleActionMsg: VehicleAction.OneOf_VehicleActionMsg? = nil

  var chargingSetLimitAction: VehicleAction_ChargingSetLimitAction {
    get {
      if case .chargingSetLimitAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_ChargingSetLimitAction()
    }
    set {vehicleActionMsg = .chargingSetLimitAction(newValue)}
  }

  var chargingStartStopAction: VehicleAction_ChargingStartStopAction {
    get {
      if case .chargingStartStopAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_ChargingStartStopAction()
    }
    set {vehicleActionMsg = .chargingStartStopAction(newValue)}
  }

  var drivingClearSpeedLimitPinAction: VehicleAction_DrivingClearSpeedLimitPinAction {
    get {
      if case .drivingClearSpeedLimitPinAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_DrivingClearSpeedLimitPinAction()
    }
    set {vehicleActionMsg = .drivingClearSpeedLimitPinAction(newValue)}
  }

  var drivingSetSpeedLimitAction: VehicleAction_DrivingSetSpeedLimitAction {
    get {
      if case .drivingSetSpeedLimitAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_DrivingSetSpeedLimitAction()
    }
    set {vehicleActionMsg = .drivingSetSpeedLimitAction(newValue)}
  }

  var drivingSpeedLimitAction: VehicleAction_DrivingSpeedLimitAction {
    get {
      if case .drivingSpeedLimitAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_DrivingSpeedLimitAction()
    }
    set {vehicleActionMsg = .drivingSpeedLimitAction(newValue)}
  }

  var hvacAutoAction: VehicleAction_HvacAutoAction {
    get {
      if case .hvacAutoAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_HvacAutoAction()
    }
    set {vehicleActionMsg = .hvacAutoAction(newValue)}
  }

  var hvacSetPreconditioningMaxAction: VehicleAction_HvacSetPreconditioningMaxAction {
    get {
      if case .hvacSetPreconditioningMaxAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_HvacSetPreconditioningMaxAction()
    }
    set {vehicleActionMsg = .hvacSetPreconditioningMaxAction(newValue)}
  }

  var hvacSteeringWheelHeaterAction: VehicleAction_HvacSteeringWheelHeaterAction {
    get {
      if case .hvacSteeringWheelHeaterAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_HvacSteeringWheelHeaterAction()
    }
    set {vehicleActionMsg = .hvacSteeringWheelHeaterAction(newValue)}
  }

  var hvacTemperatureAdjustmentAction: VehicleAction_HvacTemperatureAdjustmentAction {
    get {
      if case .hvacTemperatureAdjustmentAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_HvacTemperatureAdjustmentAction()
    }
    set {vehicleActionMsg = .hvacTemperatureAdjustmentAction(newValue)}
  }

  var mediaUpdateVolume: VehicleAction_MediaUpdateVolume {
    get {
      if case .mediaUpdateVolume(let v)? = vehicleActionMsg {return v}
      return VehicleAction_MediaUpdateVolume()
    }
    set {vehicleActionMsg = .mediaUpdateVolume(newValue)}
  }

  var mediaNextFavorite: VehicleAction_MediaNextFavorite {
    get {
      if case .mediaNextFavorite(let v)? = vehicleActionMsg {return v}
      return VehicleAction_MediaNextFavorite()
    }
    set {vehicleActionMsg = .mediaNextFavorite(newValue)}
  }

  var mediaPreviousFavorite: VehicleAction_MediaPreviousFavorite {
    get {
      if case .mediaPreviousFavorite(let v)? = vehicleActionMsg {return v}
      return VehicleAction_MediaPreviousFavorite()
    }
    set {vehicleActionMsg = .mediaPreviousFavorite(newValue)}
  }

  var mediaNextTrack: VehicleAction_MediaNextTrack {
    get {
      if case .mediaNextTrack(let v)? = vehicleActionMsg {return v}
      return VehicleAction_MediaNextTrack()
    }
    set {vehicleActionMsg = .mediaNextTrack(newValue)}
  }

  var mediaPreviousTrack: VehicleAction_MediaPreviousTrack {
    get {
      if case .mediaPreviousTrack(let v)? = vehicleActionMsg {return v}
      return VehicleAction_MediaPreviousTrack()
    }
    set {vehicleActionMsg = .mediaPreviousTrack(newValue)}
  }

  var getNearbyChargingSites: VehicleAction_GetNearbyChargingSites {
    get {
      if case .getNearbyChargingSites(let v)? = vehicleActionMsg {return v}
      return VehicleAction_GetNearbyChargingSites()
    }
    set {vehicleActionMsg = .getNearbyChargingSites(newValue)}
  }

  var vehicleControlCancelSoftwareUpdateAction: VehicleAction_VehicleControlCancelSoftwareUpdateAction {
    get {
      if case .vehicleControlCancelSoftwareUpdateAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_VehicleControlCancelSoftwareUpdateAction()
    }
    set {vehicleActionMsg = .vehicleControlCancelSoftwareUpdateAction(newValue)}
  }

  var vehicleControlFlashLightsAction: VehicleAction_VehicleControlFlashLightsAction {
    get {
      if case .vehicleControlFlashLightsAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_VehicleControlFlashLightsAction()
    }
    set {vehicleActionMsg = .vehicleControlFlashLightsAction(newValue)}
  }

  var vehicleControlHonkHornAction: VehicleAction_VehicleControlHonkHornAction {
    get {
      if case .vehicleControlHonkHornAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_VehicleControlHonkHornAction()
    }
    set {vehicleActionMsg = .vehicleControlHonkHornAction(newValue)}
  }

  var vehicleControlResetValetPinAction: VehicleAction_VehicleControlResetValetPinAction {
    get {
      if case .vehicleControlResetValetPinAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_VehicleControlResetValetPinAction()
    }
    set {vehicleActionMsg = .vehicleControlResetValetPinAction(newValue)}
  }

  var vehicleControlScheduleSoftwareUpdateAction: VehicleAction_VehicleControlScheduleSoftwareUpdateAction {
    get {
      if case .vehicleControlScheduleSoftwareUpdateAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_VehicleControlScheduleSoftwareUpdateAction()
    }
    set {vehicleActionMsg = .vehicleControlScheduleSoftwareUpdateAction(newValue)}
  }

  var vehicleControlSetSentryModeAction: VehicleAction_VehicleControlSetSentryModeAction {
    get {
      if case .vehicleControlSetSentryModeAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_VehicleControlSetSentryModeAction()
    }
    set {vehicleActionMsg = .vehicleControlSetSentryModeAction(newValue)}
  }

  var vehicleControlSetValetModeAction: VehicleAction_VehicleControlSetValetModeAction {
    get {
      if case .vehicleControlSetValetModeAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_VehicleControlSetValetModeAction()
    }
    set {vehicleActionMsg = .vehicleControlSetValetModeAction(newValue)}
  }

  var vehicleControlSunroofOpenCloseAction: VehicleAction_VehicleControlSunroofOpenCloseAction {
    get {
      if case .vehicleControlSunroofOpenCloseAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_VehicleControlSunroofOpenCloseAction()
    }
    set {vehicleActionMsg = .vehicleControlSunroofOpenCloseAction(newValue)}
  }

  var vehicleControlTriggerHomelinkAction: VehicleAction_VehicleControlTriggerHomelinkAction {
    get {
      if case .vehicleControlTriggerHomelinkAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_VehicleControlTriggerHomelinkAction()
    }
    set {vehicleActionMsg = .vehicleControlTriggerHomelinkAction(newValue)}
  }

  var vehicleControlWindowAction: VehicleAction_VehicleControlWindowAction {
    get {
      if case .vehicleControlWindowAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_VehicleControlWindowAction()
    }
    set {vehicleActionMsg = .vehicleControlWindowAction(newValue)}
  }

  var hvacBioweaponModeAction: VehicleAction_HvacBioweaponModeAction {
    get {
      if case .hvacBioweaponModeAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_HvacBioweaponModeAction()
    }
    set {vehicleActionMsg = .hvacBioweaponModeAction(newValue)}
  }

  var hvacSeatHeaterActions: VehicleAction_HvacSeatHeaterActions {
    get {
      if case .hvacSeatHeaterActions(let v)? = vehicleActionMsg {return v}
      return VehicleAction_HvacSeatHeaterActions()
    }
    set {vehicleActionMsg = .hvacSeatHeaterActions(newValue)}
  }

  var scheduledChargingAction: VehicleAction_ScheduledChargingAction {
    get {
      if case .scheduledChargingAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_ScheduledChargingAction()
    }
    set {vehicleActionMsg = .scheduledChargingAction(newValue)}
  }

  var scheduledDepartureAction: VehicleAction_ScheduledDepartureAction {
    get {
      if case .scheduledDepartureAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_ScheduledDepartureAction()
    }
    set {vehicleActionMsg = .scheduledDepartureAction(newValue)}
  }

  var setChargingAmpsAction: VehicleAction_SetChargingAmpsAction {
    get {
      if case .setChargingAmpsAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_SetChargingAmpsAction()
    }
    set {vehicleActionMsg = .setChargingAmpsAction(newValue)}
  }

  var hvacClimateKeeperAction: VehicleAction_HvacClimateKeeperAction {
    get {
      if case .hvacClimateKeeperAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_HvacClimateKeeperAction()
    }
    set {vehicleActionMsg = .hvacClimateKeeperAction(newValue)}
  }

  var ping: Ping {
    get {
      if case .ping(let v)? = vehicleActionMsg {return v}
      return Ping()
    }
    set {vehicleActionMsg = .ping(newValue)}
  }

  var autoSeatClimateAction: VehicleAction_AutoSeatClimateAction {
    get {
      if case .autoSeatClimateAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_AutoSeatClimateAction()
    }
    set {vehicleActionMsg = .autoSeatClimateAction(newValue)}
  }

  var hvacSeatCoolerActions: VehicleAction_HvacSeatCoolerActions {
    get {
      if case .hvacSeatCoolerActions(let v)? = vehicleActionMsg {return v}
      return VehicleAction_HvacSeatCoolerActions()
    }
    set {vehicleActionMsg = .hvacSeatCoolerActions(newValue)}
  }

  var setCabinOverheatProtectionAction: VehicleAction_SetCabinOverheatProtectionAction {
    get {
      if case .setCabinOverheatProtectionAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_SetCabinOverheatProtectionAction()
    }
    set {vehicleActionMsg = .setCabinOverheatProtectionAction(newValue)}
  }

  var setVehicleNameAction: VehicleAction_SetVehicleNameAction {
    get {
      if case .setVehicleNameAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_SetVehicleNameAction()
    }
    set {vehicleActionMsg = .setVehicleNameAction(newValue)}
  }

  var chargePortDoorClose: VehicleAction_ChargePortDoorClose {
    get {
      if case .chargePortDoorClose(let v)? = vehicleActionMsg {return v}
      return VehicleAction_ChargePortDoorClose()
    }
    set {vehicleActionMsg = .chargePortDoorClose(newValue)}
  }

  var chargePortDoorOpen: VehicleAction_ChargePortDoorOpen {
    get {
      if case .chargePortDoorOpen(let v)? = vehicleActionMsg {return v}
      return VehicleAction_ChargePortDoorOpen()
    }
    set {vehicleActionMsg = .chargePortDoorOpen(newValue)}
  }

  var guestModeAction: VehicleState_GuestMode {
    get {
      if case .guestModeAction(let v)? = vehicleActionMsg {return v}
      return VehicleState_GuestMode()
    }
    set {vehicleActionMsg = .guestModeAction(newValue)}
  }

  var setCopTempAction: VehicleAction_SetCopTempAction {
    get {
      if case .setCopTempAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_SetCopTempAction()
    }
    set {vehicleActionMsg = .setCopTempAction(newValue)}
  }

  var eraseUserDataAction: VehicleAction_EraseUserDataAction {
    get {
      if case .eraseUserDataAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_EraseUserDataAction()
    }
    set {vehicleActionMsg = .eraseUserDataAction(newValue)}
  }

  var vehicleControlSetPinToDriveAction: VehicleAction_VehicleControlSetPinToDriveAction {
    get {
      if case .vehicleControlSetPinToDriveAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_VehicleControlSetPinToDriveAction()
    }
    set {vehicleActionMsg = .vehicleControlSetPinToDriveAction(newValue)}
  }

  var vehicleControlResetPinToDriveAction: VehicleAction_VehicleControlResetPinToDriveAction {
    get {
      if case .vehicleControlResetPinToDriveAction(let v)? = vehicleActionMsg {return v}
      return VehicleAction_VehicleControlResetPinToDriveAction()
    }
    set {vehicleActionMsg = .vehicleControlResetPinToDriveAction(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_VehicleActionMsg: Equatable {
    case chargingSetLimitAction(VehicleAction_ChargingSetLimitAction)
    case chargingStartStopAction(VehicleAction_ChargingStartStopAction)
    case drivingClearSpeedLimitPinAction(VehicleAction_DrivingClearSpeedLimitPinAction)
    case drivingSetSpeedLimitAction(VehicleAction_DrivingSetSpeedLimitAction)
    case drivingSpeedLimitAction(VehicleAction_DrivingSpeedLimitAction)
    case hvacAutoAction(VehicleAction_HvacAutoAction)
    case hvacSetPreconditioningMaxAction(VehicleAction_HvacSetPreconditioningMaxAction)
    case hvacSteeringWheelHeaterAction(VehicleAction_HvacSteeringWheelHeaterAction)
    case hvacTemperatureAdjustmentAction(VehicleAction_HvacTemperatureAdjustmentAction)
    case mediaUpdateVolume(VehicleAction_MediaUpdateVolume)
    case mediaNextFavorite(VehicleAction_MediaNextFavorite)
    case mediaPreviousFavorite(VehicleAction_MediaPreviousFavorite)
    case mediaNextTrack(VehicleAction_MediaNextTrack)
    case mediaPreviousTrack(VehicleAction_MediaPreviousTrack)
    case getNearbyChargingSites(VehicleAction_GetNearbyChargingSites)
    case vehicleControlCancelSoftwareUpdateAction(VehicleAction_VehicleControlCancelSoftwareUpdateAction)
    case vehicleControlFlashLightsAction(VehicleAction_VehicleControlFlashLightsAction)
    case vehicleControlHonkHornAction(VehicleAction_VehicleControlHonkHornAction)
    case vehicleControlResetValetPinAction(VehicleAction_VehicleControlResetValetPinAction)
    case vehicleControlScheduleSoftwareUpdateAction(VehicleAction_VehicleControlScheduleSoftwareUpdateAction)
    case vehicleControlSetSentryModeAction(VehicleAction_VehicleControlSetSentryModeAction)
    case vehicleControlSetValetModeAction(VehicleAction_VehicleControlSetValetModeAction)
    case vehicleControlSunroofOpenCloseAction(VehicleAction_VehicleControlSunroofOpenCloseAction)
    case vehicleControlTriggerHomelinkAction(VehicleAction_VehicleControlTriggerHomelinkAction)
    case vehicleControlWindowAction(VehicleAction_VehicleControlWindowAction)
    case hvacBioweaponModeAction(VehicleAction_HvacBioweaponModeAction)
    case hvacSeatHeaterActions(VehicleAction_HvacSeatHeaterActions)
    case scheduledChargingAction(VehicleAction_ScheduledChargingAction)
    case scheduledDepartureAction(VehicleAction_ScheduledDepartureAction)
    case setChargingAmpsAction(VehicleAction_SetChargingAmpsAction)
    case hvacClimateKeeperAction(VehicleAction_HvacClimateKeeperAction)
    case ping(Ping)
    case autoSeatClimateAction(VehicleAction_AutoSeatClimateAction)
    case hvacSeatCoolerActions(VehicleAction_HvacSeatCoolerActions)
    case setCabinOverheatProtectionAction(VehicleAction_SetCabinOverheatProtectionAction)
    case setVehicleNameAction(VehicleAction_SetVehicleNameAction)
    case chargePortDoorClose(VehicleAction_ChargePortDoorClose)
    case chargePortDoorOpen(VehicleAction_ChargePortDoorOpen)
    case guestModeAction(VehicleState_GuestMode)
    case setCopTempAction(VehicleAction_SetCopTempAction)
    case eraseUserDataAction(VehicleAction_EraseUserDataAction)
    case vehicleControlSetPinToDriveAction(VehicleAction_VehicleControlSetPinToDriveAction)
    case vehicleControlResetPinToDriveAction(VehicleAction_VehicleControlResetPinToDriveAction)

  #if !swift(>=4.1)
    static func ==(lhs: VehicleAction.OneOf_VehicleActionMsg, rhs: VehicleAction.OneOf_VehicleActionMsg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.chargingSetLimitAction, .chargingSetLimitAction): return {
        guard case .chargingSetLimitAction(let l) = lhs, case .chargingSetLimitAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargingStartStopAction, .chargingStartStopAction): return {
        guard case .chargingStartStopAction(let l) = lhs, case .chargingStartStopAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.drivingClearSpeedLimitPinAction, .drivingClearSpeedLimitPinAction): return {
        guard case .drivingClearSpeedLimitPinAction(let l) = lhs, case .drivingClearSpeedLimitPinAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.drivingSetSpeedLimitAction, .drivingSetSpeedLimitAction): return {
        guard case .drivingSetSpeedLimitAction(let l) = lhs, case .drivingSetSpeedLimitAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.drivingSpeedLimitAction, .drivingSpeedLimitAction): return {
        guard case .drivingSpeedLimitAction(let l) = lhs, case .drivingSpeedLimitAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hvacAutoAction, .hvacAutoAction): return {
        guard case .hvacAutoAction(let l) = lhs, case .hvacAutoAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hvacSetPreconditioningMaxAction, .hvacSetPreconditioningMaxAction): return {
        guard case .hvacSetPreconditioningMaxAction(let l) = lhs, case .hvacSetPreconditioningMaxAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hvacSteeringWheelHeaterAction, .hvacSteeringWheelHeaterAction): return {
        guard case .hvacSteeringWheelHeaterAction(let l) = lhs, case .hvacSteeringWheelHeaterAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hvacTemperatureAdjustmentAction, .hvacTemperatureAdjustmentAction): return {
        guard case .hvacTemperatureAdjustmentAction(let l) = lhs, case .hvacTemperatureAdjustmentAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaUpdateVolume, .mediaUpdateVolume): return {
        guard case .mediaUpdateVolume(let l) = lhs, case .mediaUpdateVolume(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaNextFavorite, .mediaNextFavorite): return {
        guard case .mediaNextFavorite(let l) = lhs, case .mediaNextFavorite(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaPreviousFavorite, .mediaPreviousFavorite): return {
        guard case .mediaPreviousFavorite(let l) = lhs, case .mediaPreviousFavorite(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaNextTrack, .mediaNextTrack): return {
        guard case .mediaNextTrack(let l) = lhs, case .mediaNextTrack(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaPreviousTrack, .mediaPreviousTrack): return {
        guard case .mediaPreviousTrack(let l) = lhs, case .mediaPreviousTrack(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getNearbyChargingSites, .getNearbyChargingSites): return {
        guard case .getNearbyChargingSites(let l) = lhs, case .getNearbyChargingSites(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleControlCancelSoftwareUpdateAction, .vehicleControlCancelSoftwareUpdateAction): return {
        guard case .vehicleControlCancelSoftwareUpdateAction(let l) = lhs, case .vehicleControlCancelSoftwareUpdateAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleControlFlashLightsAction, .vehicleControlFlashLightsAction): return {
        guard case .vehicleControlFlashLightsAction(let l) = lhs, case .vehicleControlFlashLightsAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleControlHonkHornAction, .vehicleControlHonkHornAction): return {
        guard case .vehicleControlHonkHornAction(let l) = lhs, case .vehicleControlHonkHornAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleControlResetValetPinAction, .vehicleControlResetValetPinAction): return {
        guard case .vehicleControlResetValetPinAction(let l) = lhs, case .vehicleControlResetValetPinAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleControlScheduleSoftwareUpdateAction, .vehicleControlScheduleSoftwareUpdateAction): return {
        guard case .vehicleControlScheduleSoftwareUpdateAction(let l) = lhs, case .vehicleControlScheduleSoftwareUpdateAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleControlSetSentryModeAction, .vehicleControlSetSentryModeAction): return {
        guard case .vehicleControlSetSentryModeAction(let l) = lhs, case .vehicleControlSetSentryModeAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleControlSetValetModeAction, .vehicleControlSetValetModeAction): return {
        guard case .vehicleControlSetValetModeAction(let l) = lhs, case .vehicleControlSetValetModeAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleControlSunroofOpenCloseAction, .vehicleControlSunroofOpenCloseAction): return {
        guard case .vehicleControlSunroofOpenCloseAction(let l) = lhs, case .vehicleControlSunroofOpenCloseAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleControlTriggerHomelinkAction, .vehicleControlTriggerHomelinkAction): return {
        guard case .vehicleControlTriggerHomelinkAction(let l) = lhs, case .vehicleControlTriggerHomelinkAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleControlWindowAction, .vehicleControlWindowAction): return {
        guard case .vehicleControlWindowAction(let l) = lhs, case .vehicleControlWindowAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hvacBioweaponModeAction, .hvacBioweaponModeAction): return {
        guard case .hvacBioweaponModeAction(let l) = lhs, case .hvacBioweaponModeAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hvacSeatHeaterActions, .hvacSeatHeaterActions): return {
        guard case .hvacSeatHeaterActions(let l) = lhs, case .hvacSeatHeaterActions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scheduledChargingAction, .scheduledChargingAction): return {
        guard case .scheduledChargingAction(let l) = lhs, case .scheduledChargingAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.scheduledDepartureAction, .scheduledDepartureAction): return {
        guard case .scheduledDepartureAction(let l) = lhs, case .scheduledDepartureAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setChargingAmpsAction, .setChargingAmpsAction): return {
        guard case .setChargingAmpsAction(let l) = lhs, case .setChargingAmpsAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hvacClimateKeeperAction, .hvacClimateKeeperAction): return {
        guard case .hvacClimateKeeperAction(let l) = lhs, case .hvacClimateKeeperAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.autoSeatClimateAction, .autoSeatClimateAction): return {
        guard case .autoSeatClimateAction(let l) = lhs, case .autoSeatClimateAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hvacSeatCoolerActions, .hvacSeatCoolerActions): return {
        guard case .hvacSeatCoolerActions(let l) = lhs, case .hvacSeatCoolerActions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setCabinOverheatProtectionAction, .setCabinOverheatProtectionAction): return {
        guard case .setCabinOverheatProtectionAction(let l) = lhs, case .setCabinOverheatProtectionAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setVehicleNameAction, .setVehicleNameAction): return {
        guard case .setVehicleNameAction(let l) = lhs, case .setVehicleNameAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargePortDoorClose, .chargePortDoorClose): return {
        guard case .chargePortDoorClose(let l) = lhs, case .chargePortDoorClose(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargePortDoorOpen, .chargePortDoorOpen): return {
        guard case .chargePortDoorOpen(let l) = lhs, case .chargePortDoorOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guestModeAction, .guestModeAction): return {
        guard case .guestModeAction(let l) = lhs, case .guestModeAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setCopTempAction, .setCopTempAction): return {
        guard case .setCopTempAction(let l) = lhs, case .setCopTempAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.eraseUserDataAction, .eraseUserDataAction): return {
        guard case .eraseUserDataAction(let l) = lhs, case .eraseUserDataAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleControlSetPinToDriveAction, .vehicleControlSetPinToDriveAction): return {
        guard case .vehicleControlSetPinToDriveAction(let l) = lhs, case .vehicleControlSetPinToDriveAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleControlResetPinToDriveAction, .vehicleControlResetPinToDriveAction): return {
        guard case .vehicleControlResetPinToDriveAction(let l) = lhs, case .vehicleControlResetPinToDriveAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VehicleAction_EraseUserDataAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionStatus: ActionStatus {
    get {return _actionStatus ?? ActionStatus()}
    set {_actionStatus = newValue}
  }
  /// Returns true if `actionStatus` has been explicitly set.
  var hasActionStatus: Bool {return self._actionStatus != nil}
  /// Clears the value of `actionStatus`. Subsequent reads from it will return its default value.
  mutating func clearActionStatus() {self._actionStatus = nil}

  var responseMsg: Response.OneOf_ResponseMsg? = nil

  var getSessionInfoResponse: Response_GetSessionInfoResponse {
    get {
      if case .getSessionInfoResponse(let v)? = responseMsg {return v}
      return Response_GetSessionInfoResponse()
    }
    set {responseMsg = .getSessionInfoResponse(newValue)}
  }

  var getNearbyChargingSites: Response_GetNearbyChargingSites {
    get {
      if case .getNearbyChargingSites(let v)? = responseMsg {return v}
      return Response_GetNearbyChargingSites()
    }
    set {responseMsg = .getNearbyChargingSites(newValue)}
  }

  var ping: Response_Ping {
    get {
      if case .ping(let v)? = responseMsg {return v}
      return Response_Ping()
    }
    set {responseMsg = .ping(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ResponseMsg: Equatable {
    case getSessionInfoResponse(Response_GetSessionInfoResponse)
    case getNearbyChargingSites(Response_GetNearbyChargingSites)
    case ping(Response_Ping)

  #if !swift(>=4.1)
    static func ==(lhs: Response.OneOf_ResponseMsg, rhs: Response.OneOf_ResponseMsg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getSessionInfoResponse, .getSessionInfoResponse): return {
        guard case .getSessionInfoResponse(let l) = lhs, case .getSessionInfoResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getNearbyChargingSites, .getNearbyChargingSites): return {
        guard case .getNearbyChargingSites(let l) = lhs, case .getNearbyChargingSites(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _actionStatus: ActionStatus? = nil
}

struct Response_GetSessionInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var getSessionInfoResponse: SessionInfo {
    get {return _getSessionInfoResponse ?? SessionInfo()}
    set {_getSessionInfoResponse = newValue}
  }
  /// Returns true if `getSessionInfoResponse` has been explicitly set.
  var hasGetSessionInfoResponse: Bool {return self._getSessionInfoResponse != nil}
  /// Clears the value of `getSessionInfoResponse`. Subsequent reads from it will return its default value.
  mutating func clearGetSessionInfoResponse() {self._getSessionInfoResponse = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _getSessionInfoResponse: SessionInfo? = nil
}

struct Response_GetNearbyChargingSites {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var getNearbyChargingSites: NearbyChargingSites {
    get {return _getNearbyChargingSites ?? NearbyChargingSites()}
    set {_getNearbyChargingSites = newValue}
  }
  /// Returns true if `getNearbyChargingSites` has been explicitly set.
  var hasGetNearbyChargingSites: Bool {return self._getNearbyChargingSites != nil}
  /// Clears the value of `getNearbyChargingSites`. Subsequent reads from it will return its default value.
  mutating func clearGetNearbyChargingSites() {self._getNearbyChargingSites = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _getNearbyChargingSites: NearbyChargingSites? = nil
}

struct Response_Ping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ping: Ping {
    get {return _ping ?? Ping()}
    set {_ping = newValue}
  }
  /// Returns true if `ping` has been explicitly set.
  var hasPing: Bool {return self._ping != nil}
  /// Clears the value of `ping`. Subsequent reads from it will return its default value.
  mutating func clearPing() {self._ping = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ping: Ping? = nil
}

struct ActionStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: OperationStatus_E = .operationstatusOk

  var resultReason: ResultReason {
    get {return _resultReason ?? ResultReason()}
    set {_resultReason = newValue}
  }
  /// Returns true if `resultReason` has been explicitly set.
  var hasResultReason: Bool {return self._resultReason != nil}
  /// Clears the value of `resultReason`. Subsequent reads from it will return its default value.
  mutating func clearResultReason() {self._resultReason = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _resultReason: ResultReason? = nil
}

struct ResultReason {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: ResultReason.OneOf_Reason? = nil

  var plainText: String {
    get {
      if case .plainText(let v)? = reason {return v}
      return String()
    }
    set {reason = .plainText(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Reason: Equatable {
    case plainText(String)

  #if !swift(>=4.1)
    static func ==(lhs: ResultReason.OneOf_Reason, rhs: ResultReason.OneOf_Reason) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.plainText, .plainText): return {
        guard case .plainText(let l) = lhs, case .plainText(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

struct EncryptedData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fieldNumber: Int32 = 0

  var ciphertext: Data = Data()

  var tag: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_ChargingSetLimitAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var percent: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_ChargingStartStopAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargingAction: VehicleAction_ChargingStartStopAction.OneOf_ChargingAction? = nil

  var unknown: Void {
    get {
      if case .unknown(let v)? = chargingAction {return v}
      return Void()
    }
    set {chargingAction = .unknown(newValue)}
  }

  var start: Void {
    get {
      if case .start(let v)? = chargingAction {return v}
      return Void()
    }
    set {chargingAction = .start(newValue)}
  }

  var startStandard: Void {
    get {
      if case .startStandard(let v)? = chargingAction {return v}
      return Void()
    }
    set {chargingAction = .startStandard(newValue)}
  }

  var startMaxRange: Void {
    get {
      if case .startMaxRange(let v)? = chargingAction {return v}
      return Void()
    }
    set {chargingAction = .startMaxRange(newValue)}
  }

  var stop: Void {
    get {
      if case .stop(let v)? = chargingAction {return v}
      return Void()
    }
    set {chargingAction = .stop(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ChargingAction: Equatable {
    case unknown(Void)
    case start(Void)
    case startStandard(Void)
    case startMaxRange(Void)
    case stop(Void)

  #if !swift(>=4.1)
    static func ==(lhs: VehicleAction_ChargingStartStopAction.OneOf_ChargingAction, rhs: VehicleAction_ChargingStartStopAction.OneOf_ChargingAction) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.unknown, .unknown): return {
        guard case .unknown(let l) = lhs, case .unknown(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.start, .start): return {
        guard case .start(let l) = lhs, case .start(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startStandard, .startStandard): return {
        guard case .startStandard(let l) = lhs, case .startStandard(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startMaxRange, .startMaxRange): return {
        guard case .startMaxRange(let l) = lhs, case .startMaxRange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stop, .stop): return {
        guard case .stop(let l) = lhs, case .stop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VehicleAction_DrivingClearSpeedLimitPinAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_DrivingSetSpeedLimitAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var limitMph: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_DrivingSpeedLimitAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var activate: Bool = false

  var pin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_HvacAutoAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var powerOn: Bool = false

  var manualOverride: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_HvacSeatHeaterActions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hvacSeatHeaterAction: [HvacSeatHeaterActions_HvacSeatHeaterAction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_HvacSeatCoolerActions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hvacSeatCoolerAction: [HvacSeatCoolerActions_HvacSeatCoolerAction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HvacSeatCoolerActions_HvacSeatCoolerAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var seatCoolerLevel: HvacSeatCoolerActions_HvacSeatCoolerLevel_E = .hvacSeatCoolerLevelUnknown

  var seatPosition: HvacSeatCoolerActions_HvacSeatCoolerPosition_E = .hvacSeatCoolerPositionUnknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_HvacSetPreconditioningMaxAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var on: Bool = false

  var manualOverride: Bool = false

  var manualOverrideMode: [HvacSetPreconditioningMaxAction_ManualOverrideMode_E] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_HvacSteeringWheelHeaterAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var powerOn: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_HvacTemperatureAdjustmentAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deltaCelsius: Float = 0

  var deltaPercent: Int32 = 0

  var absoluteCelsius: Float = 0

  var level: HvacTemperatureAdjustmentAction_Temperature {
    get {return _level ?? HvacTemperatureAdjustmentAction_Temperature()}
    set {_level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  var hasLevel: Bool {return self._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  mutating func clearLevel() {self._level = nil}

  var hvacTemperatureZone: [HvacTemperatureAdjustmentAction_HvacTemperatureZone] = []

  var driverTempCelsius: Float = 0

  var passengerTempCelsius: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _level: HvacTemperatureAdjustmentAction_Temperature? = nil
}

struct VehicleAction_GetNearbyChargingSites {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var includeMetaData: Bool = false

  var radius: Int32 = 0

  var count: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct NearbyChargingSites {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: Timestamp {
    get {return _timestamp ?? Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var superchargers: [Superchargers] = []

  var congestionSyncTimeUtcSecs: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timestamp: Timestamp? = nil
}

struct Superchargers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var amenities: String {
    get {return _storage._amenities}
    set {_uniqueStorage()._amenities = newValue}
  }

  var availableStalls: Int32 {
    get {return _storage._availableStalls}
    set {_uniqueStorage()._availableStalls = newValue}
  }

  var billingInfo: String {
    get {return _storage._billingInfo}
    set {_uniqueStorage()._billingInfo = newValue}
  }

  var billingTime: String {
    get {return _storage._billingTime}
    set {_uniqueStorage()._billingTime = newValue}
  }

  var city: String {
    get {return _storage._city}
    set {_uniqueStorage()._city = newValue}
  }

  var country: String {
    get {return _storage._country}
    set {_uniqueStorage()._country = newValue}
  }

  var distanceMiles: Float {
    get {return _storage._distanceMiles}
    set {_uniqueStorage()._distanceMiles = newValue}
  }

  var district: String {
    get {return _storage._district}
    set {_uniqueStorage()._district = newValue}
  }

  var location: LatLong {
    get {return _storage._location ?? LatLong()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {_uniqueStorage()._location = nil}

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var postalCode: String {
    get {return _storage._postalCode}
    set {_uniqueStorage()._postalCode = newValue}
  }

  var siteClosed: Bool {
    get {return _storage._siteClosed}
    set {_uniqueStorage()._siteClosed = newValue}
  }

  var state: String {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var streetAddress: String {
    get {return _storage._streetAddress}
    set {_uniqueStorage()._streetAddress = newValue}
  }

  var totalStalls: Int32 {
    get {return _storage._totalStalls}
    set {_uniqueStorage()._totalStalls = newValue}
  }

  var withinRange: Bool {
    get {return _storage._withinRange}
    set {_uniqueStorage()._withinRange = newValue}
  }

  var maxPowerKw: Int32 {
    get {return _storage._maxPowerKw}
    set {_uniqueStorage()._maxPowerKw = newValue}
  }

  var outOfOrderStallsNumber: Int32 {
    get {return _storage._outOfOrderStallsNumber}
    set {_uniqueStorage()._outOfOrderStallsNumber = newValue}
  }

  var outOfOrderStallsNames: String {
    get {return _storage._outOfOrderStallsNames}
    set {_uniqueStorage()._outOfOrderStallsNames = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct VehicleAction_MediaUpdateVolume {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mediaVolume: VehicleAction_MediaUpdateVolume.OneOf_MediaVolume? = nil

  var volumeDelta: Int32 {
    get {
      if case .volumeDelta(let v)? = mediaVolume {return v}
      return 0
    }
    set {mediaVolume = .volumeDelta(newValue)}
  }

  var volumeAbsoluteFloat: Float {
    get {
      if case .volumeAbsoluteFloat(let v)? = mediaVolume {return v}
      return 0
    }
    set {mediaVolume = .volumeAbsoluteFloat(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_MediaVolume: Equatable {
    case volumeDelta(Int32)
    case volumeAbsoluteFloat(Float)

  #if !swift(>=4.1)
    static func ==(lhs: VehicleAction_MediaUpdateVolume.OneOf_MediaVolume, rhs: VehicleAction_MediaUpdateVolume.OneOf_MediaVolume) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.volumeDelta, .volumeDelta): return {
        guard case .volumeDelta(let l) = lhs, case .volumeDelta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.volumeAbsoluteFloat, .volumeAbsoluteFloat): return {
        guard case .volumeAbsoluteFloat(let l) = lhs, case .volumeAbsoluteFloat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VehicleAction_MediaNextFavorite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_MediaPreviousFavorite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_MediaNextTrack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_MediaPreviousTrack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_VehicleControlCancelSoftwareUpdateAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_VehicleControlFlashLightsAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_VehicleControlHonkHornAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_VehicleControlResetValetPinAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_VehicleControlScheduleSoftwareUpdateAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offsetSec: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_VehicleControlSetSentryModeAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var on: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_VehicleControlSetValetModeAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var on: Bool = false

  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_VehicleControlSunroofOpenCloseAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sunroofLevel: VehicleAction_VehicleControlSunroofOpenCloseAction.OneOf_SunroofLevel? = nil

  var absoluteLevel: Int32 {
    get {
      if case .absoluteLevel(let v)? = sunroofLevel {return v}
      return 0
    }
    set {sunroofLevel = .absoluteLevel(newValue)}
  }

  var deltaLevel: Int32 {
    get {
      if case .deltaLevel(let v)? = sunroofLevel {return v}
      return 0
    }
    set {sunroofLevel = .deltaLevel(newValue)}
  }

  var action: VehicleAction_VehicleControlSunroofOpenCloseAction.OneOf_Action? = nil

  var vent: Void {
    get {
      if case .vent(let v)? = action {return v}
      return Void()
    }
    set {action = .vent(newValue)}
  }

  var close: Void {
    get {
      if case .close(let v)? = action {return v}
      return Void()
    }
    set {action = .close(newValue)}
  }

  var `open`: Void {
    get {
      if case .open(let v)? = action {return v}
      return Void()
    }
    set {action = .open(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SunroofLevel: Equatable {
    case absoluteLevel(Int32)
    case deltaLevel(Int32)

  #if !swift(>=4.1)
    static func ==(lhs: VehicleAction_VehicleControlSunroofOpenCloseAction.OneOf_SunroofLevel, rhs: VehicleAction_VehicleControlSunroofOpenCloseAction.OneOf_SunroofLevel) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.absoluteLevel, .absoluteLevel): return {
        guard case .absoluteLevel(let l) = lhs, case .absoluteLevel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deltaLevel, .deltaLevel): return {
        guard case .deltaLevel(let l) = lhs, case .deltaLevel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum OneOf_Action: Equatable {
    case vent(Void)
    case close(Void)
    case `open`(Void)

  #if !swift(>=4.1)
    static func ==(lhs: VehicleAction_VehicleControlSunroofOpenCloseAction.OneOf_Action, rhs: VehicleAction_VehicleControlSunroofOpenCloseAction.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.vent, .vent): return {
        guard case .vent(let l) = lhs, case .vent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.close, .close): return {
        guard case .close(let l) = lhs, case .close(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.open, .open): return {
        guard case .open(let l) = lhs, case .open(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct VehicleAction_VehicleControlTriggerHomelinkAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var location: LatLong {
    get {return _location ?? LatLong()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {self._location = nil}

  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _location: LatLong? = nil
}

struct VehicleAction_VehicleControlWindowAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var location: LatLong {
    get {return _location ?? LatLong()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {self._location = nil}

  var action: VehicleAction_VehicleControlWindowAction.OneOf_Action? = nil

  var unknown: Void {
    get {
      if case .unknown(let v)? = action {return v}
      return Void()
    }
    set {action = .unknown(newValue)}
  }

  var vent: Void {
    get {
      if case .vent(let v)? = action {return v}
      return Void()
    }
    set {action = .vent(newValue)}
  }

  var close: Void {
    get {
      if case .close(let v)? = action {return v}
      return Void()
    }
    set {action = .close(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Action: Equatable {
    case unknown(Void)
    case vent(Void)
    case close(Void)

  #if !swift(>=4.1)
    static func ==(lhs: VehicleAction_VehicleControlWindowAction.OneOf_Action, rhs: VehicleAction_VehicleControlWindowAction.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.unknown, .unknown): return {
        guard case .unknown(let l) = lhs, case .unknown(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vent, .vent): return {
        guard case .vent(let l) = lhs, case .vent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.close, .close): return {
        guard case .close(let l) = lhs, case .close(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _location: LatLong? = nil
}

struct VehicleAction_HvacBioweaponModeAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var on: Bool = false

  var manualOverride: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_AutoSeatClimateAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var carseat: [AutoSeatClimateAction_CarSeat] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Ping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pingID: Int32 = 0

  var localTimestamp: Timestamp {
    get {return _localTimestamp ?? Timestamp()}
    set {_localTimestamp = newValue}
  }
  /// Returns true if `localTimestamp` has been explicitly set.
  var hasLocalTimestamp: Bool {return self._localTimestamp != nil}
  /// Clears the value of `localTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearLocalTimestamp() {self._localTimestamp = nil}

  var lastRemoteTimestamp: Timestamp {
    get {return _lastRemoteTimestamp ?? Timestamp()}
    set {_lastRemoteTimestamp = newValue}
  }
  /// Returns true if `lastRemoteTimestamp` has been explicitly set.
  var hasLastRemoteTimestamp: Bool {return self._lastRemoteTimestamp != nil}
  /// Clears the value of `lastRemoteTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearLastRemoteTimestamp() {self._lastRemoteTimestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _localTimestamp: Timestamp? = nil
  fileprivate var _lastRemoteTimestamp: Timestamp? = nil
}

struct VehicleAction_ScheduledChargingAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var chargingTime: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_ScheduledDepartureAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var departureTime: Int32 = 0

  var preconditioningTimes: PreconditioningTimes {
    get {return _preconditioningTimes ?? PreconditioningTimes()}
    set {_preconditioningTimes = newValue}
  }
  /// Returns true if `preconditioningTimes` has been explicitly set.
  var hasPreconditioningTimes: Bool {return self._preconditioningTimes != nil}
  /// Clears the value of `preconditioningTimes`. Subsequent reads from it will return its default value.
  mutating func clearPreconditioningTimes() {self._preconditioningTimes = nil}

  var offPeakChargingTimes: OffPeakChargingTimes {
    get {return _offPeakChargingTimes ?? OffPeakChargingTimes()}
    set {_offPeakChargingTimes = newValue}
  }
  /// Returns true if `offPeakChargingTimes` has been explicitly set.
  var hasOffPeakChargingTimes: Bool {return self._offPeakChargingTimes != nil}
  /// Clears the value of `offPeakChargingTimes`. Subsequent reads from it will return its default value.
  mutating func clearOffPeakChargingTimes() {self._offPeakChargingTimes = nil}

  var offPeakHoursEndTime: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _preconditioningTimes: PreconditioningTimes? = nil
  fileprivate var _offPeakChargingTimes: OffPeakChargingTimes? = nil
}

struct VehicleAction_HvacClimateKeeperAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var climateKeeperAction: HvacClimateKeeperAction_ClimateKeeperAction_E = .climateKeeperActionOff

  var manualOverride: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_SetChargingAmpsAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargingAmps: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_SetCabinOverheatProtectionAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var on: Bool = false

  var fanOnly: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_SetVehicleNameAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vehicleName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_ChargePortDoorClose {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_ChargePortDoorOpen {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_SetCopTempAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var copActivationTemp: ClimateState_CopActivationTemp = .copActivationTempUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_VehicleControlSetPinToDriveAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var on: Bool = false

  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleAction_VehicleControlResetPinToDriveAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HvacSeatHeaterActions_HvacSeatHeaterAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var seatHeaterLevel: HvacSeatHeaterActions_HvacSeatHeaterAction.OneOf_SeatHeaterLevel? = nil

  var seatHeaterUnknown: Void {
    get {
      if case .seatHeaterUnknown(let v)? = seatHeaterLevel {return v}
      return Void()
    }
    set {seatHeaterLevel = .seatHeaterUnknown(newValue)}
  }

  var seatHeaterOff: Void {
    get {
      if case .seatHeaterOff(let v)? = seatHeaterLevel {return v}
      return Void()
    }
    set {seatHeaterLevel = .seatHeaterOff(newValue)}
  }

  var seatHeaterLow: Void {
    get {
      if case .seatHeaterLow(let v)? = seatHeaterLevel {return v}
      return Void()
    }
    set {seatHeaterLevel = .seatHeaterLow(newValue)}
  }

  var seatHeaterMed: Void {
    get {
      if case .seatHeaterMed(let v)? = seatHeaterLevel {return v}
      return Void()
    }
    set {seatHeaterLevel = .seatHeaterMed(newValue)}
  }

  var seatHeaterHigh: Void {
    get {
      if case .seatHeaterHigh(let v)? = seatHeaterLevel {return v}
      return Void()
    }
    set {seatHeaterLevel = .seatHeaterHigh(newValue)}
  }

  var seatPosition: HvacSeatHeaterActions_HvacSeatHeaterAction.OneOf_SeatPosition? = nil

  var carSeatUnknown: Void {
    get {
      if case .carSeatUnknown(let v)? = seatPosition {return v}
      return Void()
    }
    set {seatPosition = .carSeatUnknown(newValue)}
  }

  var carSeatFrontLeft: Void {
    get {
      if case .carSeatFrontLeft(let v)? = seatPosition {return v}
      return Void()
    }
    set {seatPosition = .carSeatFrontLeft(newValue)}
  }

  var carSeatFrontRight: Void {
    get {
      if case .carSeatFrontRight(let v)? = seatPosition {return v}
      return Void()
    }
    set {seatPosition = .carSeatFrontRight(newValue)}
  }

  var carSeatRearLeft: Void {
    get {
      if case .carSeatRearLeft(let v)? = seatPosition {return v}
      return Void()
    }
    set {seatPosition = .carSeatRearLeft(newValue)}
  }

  var carSeatRearLeftBack: Void {
    get {
      if case .carSeatRearLeftBack(let v)? = seatPosition {return v}
      return Void()
    }
    set {seatPosition = .carSeatRearLeftBack(newValue)}
  }

  var carSeatRearCenter: Void {
    get {
      if case .carSeatRearCenter(let v)? = seatPosition {return v}
      return Void()
    }
    set {seatPosition = .carSeatRearCenter(newValue)}
  }

  var carSeatRearRight: Void {
    get {
      if case .carSeatRearRight(let v)? = seatPosition {return v}
      return Void()
    }
    set {seatPosition = .carSeatRearRight(newValue)}
  }

  var carSeatRearRightBack: Void {
    get {
      if case .carSeatRearRightBack(let v)? = seatPosition {return v}
      return Void()
    }
    set {seatPosition = .carSeatRearRightBack(newValue)}
  }

  var carSeatThirdRowLeft: Void {
    get {
      if case .carSeatThirdRowLeft(let v)? = seatPosition {return v}
      return Void()
    }
    set {seatPosition = .carSeatThirdRowLeft(newValue)}
  }

  var carSeatThirdRowRight: Void {
    get {
      if case .carSeatThirdRowRight(let v)? = seatPosition {return v}
      return Void()
    }
    set {seatPosition = .carSeatThirdRowRight(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SeatHeaterLevel: Equatable {
    case seatHeaterUnknown(Void)
    case seatHeaterOff(Void)
    case seatHeaterLow(Void)
    case seatHeaterMed(Void)
    case seatHeaterHigh(Void)

  #if !swift(>=4.1)
    static func ==(lhs: HvacSeatHeaterActions_HvacSeatHeaterAction.OneOf_SeatHeaterLevel, rhs: HvacSeatHeaterActions_HvacSeatHeaterAction.OneOf_SeatHeaterLevel) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.seatHeaterUnknown, .seatHeaterUnknown): return {
        guard case .seatHeaterUnknown(let l) = lhs, case .seatHeaterUnknown(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.seatHeaterOff, .seatHeaterOff): return {
        guard case .seatHeaterOff(let l) = lhs, case .seatHeaterOff(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.seatHeaterLow, .seatHeaterLow): return {
        guard case .seatHeaterLow(let l) = lhs, case .seatHeaterLow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.seatHeaterMed, .seatHeaterMed): return {
        guard case .seatHeaterMed(let l) = lhs, case .seatHeaterMed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.seatHeaterHigh, .seatHeaterHigh): return {
        guard case .seatHeaterHigh(let l) = lhs, case .seatHeaterHigh(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum OneOf_SeatPosition: Equatable {
    case carSeatUnknown(Void)
    case carSeatFrontLeft(Void)
    case carSeatFrontRight(Void)
    case carSeatRearLeft(Void)
    case carSeatRearLeftBack(Void)
    case carSeatRearCenter(Void)
    case carSeatRearRight(Void)
    case carSeatRearRightBack(Void)
    case carSeatThirdRowLeft(Void)
    case carSeatThirdRowRight(Void)

  #if !swift(>=4.1)
    static func ==(lhs: HvacSeatHeaterActions_HvacSeatHeaterAction.OneOf_SeatPosition, rhs: HvacSeatHeaterActions_HvacSeatHeaterAction.OneOf_SeatPosition) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.carSeatUnknown, .carSeatUnknown): return {
        guard case .carSeatUnknown(let l) = lhs, case .carSeatUnknown(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.carSeatFrontLeft, .carSeatFrontLeft): return {
        guard case .carSeatFrontLeft(let l) = lhs, case .carSeatFrontLeft(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.carSeatFrontRight, .carSeatFrontRight): return {
        guard case .carSeatFrontRight(let l) = lhs, case .carSeatFrontRight(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.carSeatRearLeft, .carSeatRearLeft): return {
        guard case .carSeatRearLeft(let l) = lhs, case .carSeatRearLeft(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.carSeatRearLeftBack, .carSeatRearLeftBack): return {
        guard case .carSeatRearLeftBack(let l) = lhs, case .carSeatRearLeftBack(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.carSeatRearCenter, .carSeatRearCenter): return {
        guard case .carSeatRearCenter(let l) = lhs, case .carSeatRearCenter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.carSeatRearRight, .carSeatRearRight): return {
        guard case .carSeatRearRight(let l) = lhs, case .carSeatRearRight(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.carSeatRearRightBack, .carSeatRearRightBack): return {
        guard case .carSeatRearRightBack(let l) = lhs, case .carSeatRearRightBack(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.carSeatThirdRowLeft, .carSeatThirdRowLeft): return {
        guard case .carSeatThirdRowLeft(let l) = lhs, case .carSeatThirdRowLeft(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.carSeatThirdRowRight, .carSeatThirdRowRight): return {
        guard case .carSeatThirdRowRight(let l) = lhs, case .carSeatThirdRowRight(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct HvacTemperatureAdjustmentAction_Temperature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: HvacTemperatureAdjustmentAction_Temperature.OneOf_Type? = nil

  var tempUnknown: Void {
    get {
      if case .tempUnknown(let v)? = type {return v}
      return Void()
    }
    set {type = .tempUnknown(newValue)}
  }

  var tempMin: Void {
    get {
      if case .tempMin(let v)? = type {return v}
      return Void()
    }
    set {type = .tempMin(newValue)}
  }

  var tempMax: Void {
    get {
      if case .tempMax(let v)? = type {return v}
      return Void()
    }
    set {type = .tempMax(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case tempUnknown(Void)
    case tempMin(Void)
    case tempMax(Void)

  #if !swift(>=4.1)
    static func ==(lhs: HvacTemperatureAdjustmentAction_Temperature.OneOf_Type, rhs: HvacTemperatureAdjustmentAction_Temperature.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tempUnknown, .tempUnknown): return {
        guard case .tempUnknown(let l) = lhs, case .tempUnknown(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tempMin, .tempMin): return {
        guard case .tempMin(let l) = lhs, case .tempMin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tempMax, .tempMax): return {
        guard case .tempMax(let l) = lhs, case .tempMax(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct HvacTemperatureAdjustmentAction_HvacTemperatureZone {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: HvacTemperatureAdjustmentAction_HvacTemperatureZone.OneOf_Type? = nil

  var tempZoneUnknown: Void {
    get {
      if case .tempZoneUnknown(let v)? = type {return v}
      return Void()
    }
    set {type = .tempZoneUnknown(newValue)}
  }

  var tempZoneFrontLeft: Void {
    get {
      if case .tempZoneFrontLeft(let v)? = type {return v}
      return Void()
    }
    set {type = .tempZoneFrontLeft(newValue)}
  }

  var tempZoneFrontRight: Void {
    get {
      if case .tempZoneFrontRight(let v)? = type {return v}
      return Void()
    }
    set {type = .tempZoneFrontRight(newValue)}
  }

  var tempZoneRear: Void {
    get {
      if case .tempZoneRear(let v)? = type {return v}
      return Void()
    }
    set {type = .tempZoneRear(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case tempZoneUnknown(Void)
    case tempZoneFrontLeft(Void)
    case tempZoneFrontRight(Void)
    case tempZoneRear(Void)

  #if !swift(>=4.1)
    static func ==(lhs: HvacTemperatureAdjustmentAction_HvacTemperatureZone.OneOf_Type, rhs: HvacTemperatureAdjustmentAction_HvacTemperatureZone.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tempZoneUnknown, .tempZoneUnknown): return {
        guard case .tempZoneUnknown(let l) = lhs, case .tempZoneUnknown(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tempZoneFrontLeft, .tempZoneFrontLeft): return {
        guard case .tempZoneFrontLeft(let l) = lhs, case .tempZoneFrontLeft(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tempZoneFrontRight, .tempZoneFrontRight): return {
        guard case .tempZoneFrontRight(let l) = lhs, case .tempZoneFrontRight(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tempZoneRear, .tempZoneRear): return {
        guard case .tempZoneRear(let l) = lhs, case .tempZoneRear(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct AutoSeatClimateAction_CarSeat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var on: Bool = false

  var seatPosition: AutoSeatClimateAction_AutoSeatPosition_E = .autoSeatPositionUnknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension HvacSeatCoolerActions_HvacSeatCoolerLevel_E: @unchecked Sendable {}
extension HvacSeatCoolerActions_HvacSeatCoolerPosition_E: @unchecked Sendable {}
extension HvacSetPreconditioningMaxAction_ManualOverrideMode_E: @unchecked Sendable {}
extension AutoSeatClimateAction_AutoSeatPosition_E: @unchecked Sendable {}
extension HvacClimateKeeperAction_ClimateKeeperAction_E: @unchecked Sendable {}
extension Action: @unchecked Sendable {}
extension Action.OneOf_ActionMsg: @unchecked Sendable {}
extension VehicleAction: @unchecked Sendable {}
extension VehicleAction.OneOf_VehicleActionMsg: @unchecked Sendable {}
extension VehicleAction_EraseUserDataAction: @unchecked Sendable {}
extension Response: @unchecked Sendable {}
extension Response.OneOf_ResponseMsg: @unchecked Sendable {}
extension Response_GetSessionInfoResponse: @unchecked Sendable {}
extension Response_GetNearbyChargingSites: @unchecked Sendable {}
extension Response_Ping: @unchecked Sendable {}
extension ActionStatus: @unchecked Sendable {}
extension ResultReason: @unchecked Sendable {}
extension ResultReason.OneOf_Reason: @unchecked Sendable {}
extension EncryptedData: @unchecked Sendable {}
extension VehicleAction_ChargingSetLimitAction: @unchecked Sendable {}
extension VehicleAction_ChargingStartStopAction: @unchecked Sendable {}
extension VehicleAction_ChargingStartStopAction.OneOf_ChargingAction: @unchecked Sendable {}
extension VehicleAction_DrivingClearSpeedLimitPinAction: @unchecked Sendable {}
extension VehicleAction_DrivingSetSpeedLimitAction: @unchecked Sendable {}
extension VehicleAction_DrivingSpeedLimitAction: @unchecked Sendable {}
extension VehicleAction_HvacAutoAction: @unchecked Sendable {}
extension VehicleAction_HvacSeatHeaterActions: @unchecked Sendable {}
extension VehicleAction_HvacSeatCoolerActions: @unchecked Sendable {}
extension HvacSeatCoolerActions_HvacSeatCoolerAction: @unchecked Sendable {}
extension VehicleAction_HvacSetPreconditioningMaxAction: @unchecked Sendable {}
extension VehicleAction_HvacSteeringWheelHeaterAction: @unchecked Sendable {}
extension VehicleAction_HvacTemperatureAdjustmentAction: @unchecked Sendable {}
extension VehicleAction_GetNearbyChargingSites: @unchecked Sendable {}
extension NearbyChargingSites: @unchecked Sendable {}
extension Superchargers: @unchecked Sendable {}
extension VehicleAction_MediaUpdateVolume: @unchecked Sendable {}
extension VehicleAction_MediaUpdateVolume.OneOf_MediaVolume: @unchecked Sendable {}
extension VehicleAction_MediaNextFavorite: @unchecked Sendable {}
extension VehicleAction_MediaPreviousFavorite: @unchecked Sendable {}
extension VehicleAction_MediaNextTrack: @unchecked Sendable {}
extension VehicleAction_MediaPreviousTrack: @unchecked Sendable {}
extension VehicleAction_VehicleControlCancelSoftwareUpdateAction: @unchecked Sendable {}
extension VehicleAction_VehicleControlFlashLightsAction: @unchecked Sendable {}
extension VehicleAction_VehicleControlHonkHornAction: @unchecked Sendable {}
extension VehicleAction_VehicleControlResetValetPinAction: @unchecked Sendable {}
extension VehicleAction_VehicleControlScheduleSoftwareUpdateAction: @unchecked Sendable {}
extension VehicleAction_VehicleControlSetSentryModeAction: @unchecked Sendable {}
extension VehicleAction_VehicleControlSetValetModeAction: @unchecked Sendable {}
extension VehicleAction_VehicleControlSunroofOpenCloseAction: @unchecked Sendable {}
extension VehicleAction_VehicleControlSunroofOpenCloseAction.OneOf_SunroofLevel: @unchecked Sendable {}
extension VehicleAction_VehicleControlSunroofOpenCloseAction.OneOf_Action: @unchecked Sendable {}
extension VehicleAction_VehicleControlTriggerHomelinkAction: @unchecked Sendable {}
extension VehicleAction_VehicleControlWindowAction: @unchecked Sendable {}
extension VehicleAction_VehicleControlWindowAction.OneOf_Action: @unchecked Sendable {}
extension VehicleAction_HvacBioweaponModeAction: @unchecked Sendable {}
extension VehicleAction_AutoSeatClimateAction: @unchecked Sendable {}
extension Ping: @unchecked Sendable {}
extension VehicleAction_ScheduledChargingAction: @unchecked Sendable {}
extension VehicleAction_ScheduledDepartureAction: @unchecked Sendable {}
extension VehicleAction_HvacClimateKeeperAction: @unchecked Sendable {}
extension VehicleAction_SetChargingAmpsAction: @unchecked Sendable {}
extension VehicleAction_SetCabinOverheatProtectionAction: @unchecked Sendable {}
extension VehicleAction_SetVehicleNameAction: @unchecked Sendable {}
extension VehicleAction_ChargePortDoorClose: @unchecked Sendable {}
extension VehicleAction_ChargePortDoorOpen: @unchecked Sendable {}
extension VehicleAction_SetCopTempAction: @unchecked Sendable {}
extension VehicleAction_VehicleControlSetPinToDriveAction: @unchecked Sendable {}
extension VehicleAction_VehicleControlResetPinToDriveAction: @unchecked Sendable {}
extension HvacSeatHeaterActions_HvacSeatHeaterAction: @unchecked Sendable {}
extension HvacSeatHeaterActions_HvacSeatHeaterAction.OneOf_SeatHeaterLevel: @unchecked Sendable {}
extension HvacSeatHeaterActions_HvacSeatHeaterAction.OneOf_SeatPosition: @unchecked Sendable {}
extension HvacTemperatureAdjustmentAction_Temperature: @unchecked Sendable {}
extension HvacTemperatureAdjustmentAction_Temperature.OneOf_Type: @unchecked Sendable {}
extension HvacTemperatureAdjustmentAction_HvacTemperatureZone: @unchecked Sendable {}
extension HvacTemperatureAdjustmentAction_HvacTemperatureZone.OneOf_Type: @unchecked Sendable {}
extension AutoSeatClimateAction_CarSeat: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension HvacSeatCoolerActions_HvacSeatCoolerLevel_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HvacSeatCoolerLevel_Unknown"),
    1: .same(proto: "HvacSeatCoolerLevel_Off"),
    2: .same(proto: "HvacSeatCoolerLevel_Low"),
    3: .same(proto: "HvacSeatCoolerLevel_Med"),
    4: .same(proto: "HvacSeatCoolerLevel_High"),
  ]
}

extension HvacSeatCoolerActions_HvacSeatCoolerPosition_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HvacSeatCoolerPosition_Unknown"),
    1: .same(proto: "HvacSeatCoolerPosition_FrontLeft"),
    2: .same(proto: "HvacSeatCoolerPosition_FrontRight"),
  ]
}

extension HvacSetPreconditioningMaxAction_ManualOverrideMode_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HvacSetPreconditioningMaxAction_DogMode"),
    1: .same(proto: "HvacSetPreconditioningMaxAction_Soc"),
    2: .same(proto: "HvacSetPreconditioningMaxAction_Doors"),
  ]
}

extension AutoSeatClimateAction_AutoSeatPosition_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AutoSeatPosition_Unknown"),
    1: .same(proto: "AutoSeatPosition_FrontLeft"),
    2: .same(proto: "AutoSeatPosition_FrontRight"),
  ]
}

extension HvacClimateKeeperAction_ClimateKeeperAction_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ClimateKeeperAction_Off"),
    1: .same(proto: "ClimateKeeperAction_On"),
    2: .same(proto: "ClimateKeeperAction_Dog"),
    3: .same(proto: "ClimateKeeperAction_Camp"),
  ]
}

extension Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Action"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "vehicleAction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: VehicleAction?
        var hadOneofValue = false
        if let current = self.actionMsg {
          hadOneofValue = true
          if case .vehicleAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.actionMsg = .vehicleAction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .vehicleAction(let v)? = self.actionMsg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Action, rhs: Action) -> Bool {
    if lhs.actionMsg != rhs.actionMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "chargingSetLimitAction"),
    6: .same(proto: "chargingStartStopAction"),
    7: .same(proto: "drivingClearSpeedLimitPinAction"),
    8: .same(proto: "drivingSetSpeedLimitAction"),
    9: .same(proto: "drivingSpeedLimitAction"),
    10: .same(proto: "hvacAutoAction"),
    12: .same(proto: "hvacSetPreconditioningMaxAction"),
    13: .same(proto: "hvacSteeringWheelHeaterAction"),
    14: .same(proto: "hvacTemperatureAdjustmentAction"),
    16: .same(proto: "mediaUpdateVolume"),
    17: .same(proto: "mediaNextFavorite"),
    18: .same(proto: "mediaPreviousFavorite"),
    19: .same(proto: "mediaNextTrack"),
    20: .same(proto: "mediaPreviousTrack"),
    23: .same(proto: "getNearbyChargingSites"),
    25: .same(proto: "vehicleControlCancelSoftwareUpdateAction"),
    26: .same(proto: "vehicleControlFlashLightsAction"),
    27: .same(proto: "vehicleControlHonkHornAction"),
    28: .same(proto: "vehicleControlResetValetPinAction"),
    29: .same(proto: "vehicleControlScheduleSoftwareUpdateAction"),
    30: .same(proto: "vehicleControlSetSentryModeAction"),
    31: .same(proto: "vehicleControlSetValetModeAction"),
    32: .same(proto: "vehicleControlSunroofOpenCloseAction"),
    33: .same(proto: "vehicleControlTriggerHomelinkAction"),
    34: .same(proto: "vehicleControlWindowAction"),
    35: .same(proto: "hvacBioweaponModeAction"),
    36: .same(proto: "hvacSeatHeaterActions"),
    41: .same(proto: "scheduledChargingAction"),
    42: .same(proto: "scheduledDepartureAction"),
    43: .same(proto: "setChargingAmpsAction"),
    44: .same(proto: "hvacClimateKeeperAction"),
    46: .same(proto: "ping"),
    48: .same(proto: "autoSeatClimateAction"),
    49: .same(proto: "hvacSeatCoolerActions"),
    50: .same(proto: "setCabinOverheatProtectionAction"),
    54: .same(proto: "setVehicleNameAction"),
    61: .same(proto: "chargePortDoorClose"),
    62: .same(proto: "chargePortDoorOpen"),
    65: .same(proto: "guestModeAction"),
    66: .same(proto: "setCopTempAction"),
    72: .same(proto: "eraseUserDataAction"),
    77: .same(proto: "vehicleControlSetPinToDriveAction"),
    78: .same(proto: "vehicleControlResetPinToDriveAction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 5: try {
        var v: VehicleAction_ChargingSetLimitAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .chargingSetLimitAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .chargingSetLimitAction(v)
        }
      }()
      case 6: try {
        var v: VehicleAction_ChargingStartStopAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .chargingStartStopAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .chargingStartStopAction(v)
        }
      }()
      case 7: try {
        var v: VehicleAction_DrivingClearSpeedLimitPinAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .drivingClearSpeedLimitPinAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .drivingClearSpeedLimitPinAction(v)
        }
      }()
      case 8: try {
        var v: VehicleAction_DrivingSetSpeedLimitAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .drivingSetSpeedLimitAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .drivingSetSpeedLimitAction(v)
        }
      }()
      case 9: try {
        var v: VehicleAction_DrivingSpeedLimitAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .drivingSpeedLimitAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .drivingSpeedLimitAction(v)
        }
      }()
      case 10: try {
        var v: VehicleAction_HvacAutoAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacAutoAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacAutoAction(v)
        }
      }()
      case 12: try {
        var v: VehicleAction_HvacSetPreconditioningMaxAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacSetPreconditioningMaxAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacSetPreconditioningMaxAction(v)
        }
      }()
      case 13: try {
        var v: VehicleAction_HvacSteeringWheelHeaterAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacSteeringWheelHeaterAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacSteeringWheelHeaterAction(v)
        }
      }()
      case 14: try {
        var v: VehicleAction_HvacTemperatureAdjustmentAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacTemperatureAdjustmentAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacTemperatureAdjustmentAction(v)
        }
      }()
      case 16: try {
        var v: VehicleAction_MediaUpdateVolume?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .mediaUpdateVolume(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .mediaUpdateVolume(v)
        }
      }()
      case 17: try {
        var v: VehicleAction_MediaNextFavorite?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .mediaNextFavorite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .mediaNextFavorite(v)
        }
      }()
      case 18: try {
        var v: VehicleAction_MediaPreviousFavorite?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .mediaPreviousFavorite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .mediaPreviousFavorite(v)
        }
      }()
      case 19: try {
        var v: VehicleAction_MediaNextTrack?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .mediaNextTrack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .mediaNextTrack(v)
        }
      }()
      case 20: try {
        var v: VehicleAction_MediaPreviousTrack?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .mediaPreviousTrack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .mediaPreviousTrack(v)
        }
      }()
      case 23: try {
        var v: VehicleAction_GetNearbyChargingSites?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .getNearbyChargingSites(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .getNearbyChargingSites(v)
        }
      }()
      case 25: try {
        var v: VehicleAction_VehicleControlCancelSoftwareUpdateAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlCancelSoftwareUpdateAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlCancelSoftwareUpdateAction(v)
        }
      }()
      case 26: try {
        var v: VehicleAction_VehicleControlFlashLightsAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlFlashLightsAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlFlashLightsAction(v)
        }
      }()
      case 27: try {
        var v: VehicleAction_VehicleControlHonkHornAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlHonkHornAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlHonkHornAction(v)
        }
      }()
      case 28: try {
        var v: VehicleAction_VehicleControlResetValetPinAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlResetValetPinAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlResetValetPinAction(v)
        }
      }()
      case 29: try {
        var v: VehicleAction_VehicleControlScheduleSoftwareUpdateAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlScheduleSoftwareUpdateAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlScheduleSoftwareUpdateAction(v)
        }
      }()
      case 30: try {
        var v: VehicleAction_VehicleControlSetSentryModeAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlSetSentryModeAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlSetSentryModeAction(v)
        }
      }()
      case 31: try {
        var v: VehicleAction_VehicleControlSetValetModeAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlSetValetModeAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlSetValetModeAction(v)
        }
      }()
      case 32: try {
        var v: VehicleAction_VehicleControlSunroofOpenCloseAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlSunroofOpenCloseAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlSunroofOpenCloseAction(v)
        }
      }()
      case 33: try {
        var v: VehicleAction_VehicleControlTriggerHomelinkAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlTriggerHomelinkAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlTriggerHomelinkAction(v)
        }
      }()
      case 34: try {
        var v: VehicleAction_VehicleControlWindowAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlWindowAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlWindowAction(v)
        }
      }()
      case 35: try {
        var v: VehicleAction_HvacBioweaponModeAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacBioweaponModeAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacBioweaponModeAction(v)
        }
      }()
      case 36: try {
        var v: VehicleAction_HvacSeatHeaterActions?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacSeatHeaterActions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacSeatHeaterActions(v)
        }
      }()
      case 41: try {
        var v: VehicleAction_ScheduledChargingAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .scheduledChargingAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .scheduledChargingAction(v)
        }
      }()
      case 42: try {
        var v: VehicleAction_ScheduledDepartureAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .scheduledDepartureAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .scheduledDepartureAction(v)
        }
      }()
      case 43: try {
        var v: VehicleAction_SetChargingAmpsAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .setChargingAmpsAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .setChargingAmpsAction(v)
        }
      }()
      case 44: try {
        var v: VehicleAction_HvacClimateKeeperAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacClimateKeeperAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacClimateKeeperAction(v)
        }
      }()
      case 46: try {
        var v: Ping?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .ping(v)
        }
      }()
      case 48: try {
        var v: VehicleAction_AutoSeatClimateAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .autoSeatClimateAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .autoSeatClimateAction(v)
        }
      }()
      case 49: try {
        var v: VehicleAction_HvacSeatCoolerActions?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .hvacSeatCoolerActions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .hvacSeatCoolerActions(v)
        }
      }()
      case 50: try {
        var v: VehicleAction_SetCabinOverheatProtectionAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .setCabinOverheatProtectionAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .setCabinOverheatProtectionAction(v)
        }
      }()
      case 54: try {
        var v: VehicleAction_SetVehicleNameAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .setVehicleNameAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .setVehicleNameAction(v)
        }
      }()
      case 61: try {
        var v: VehicleAction_ChargePortDoorClose?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .chargePortDoorClose(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .chargePortDoorClose(v)
        }
      }()
      case 62: try {
        var v: VehicleAction_ChargePortDoorOpen?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .chargePortDoorOpen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .chargePortDoorOpen(v)
        }
      }()
      case 65: try {
        var v: VehicleState_GuestMode?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .guestModeAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .guestModeAction(v)
        }
      }()
      case 66: try {
        var v: VehicleAction_SetCopTempAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .setCopTempAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .setCopTempAction(v)
        }
      }()
      case 72: try {
        var v: VehicleAction_EraseUserDataAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .eraseUserDataAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .eraseUserDataAction(v)
        }
      }()
      case 77: try {
        var v: VehicleAction_VehicleControlSetPinToDriveAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlSetPinToDriveAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlSetPinToDriveAction(v)
        }
      }()
      case 78: try {
        var v: VehicleAction_VehicleControlResetPinToDriveAction?
        var hadOneofValue = false
        if let current = self.vehicleActionMsg {
          hadOneofValue = true
          if case .vehicleControlResetPinToDriveAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vehicleActionMsg = .vehicleControlResetPinToDriveAction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.vehicleActionMsg {
    case .chargingSetLimitAction?: try {
      guard case .chargingSetLimitAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .chargingStartStopAction?: try {
      guard case .chargingStartStopAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .drivingClearSpeedLimitPinAction?: try {
      guard case .drivingClearSpeedLimitPinAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .drivingSetSpeedLimitAction?: try {
      guard case .drivingSetSpeedLimitAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .drivingSpeedLimitAction?: try {
      guard case .drivingSpeedLimitAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .hvacAutoAction?: try {
      guard case .hvacAutoAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .hvacSetPreconditioningMaxAction?: try {
      guard case .hvacSetPreconditioningMaxAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .hvacSteeringWheelHeaterAction?: try {
      guard case .hvacSteeringWheelHeaterAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .hvacTemperatureAdjustmentAction?: try {
      guard case .hvacTemperatureAdjustmentAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .mediaUpdateVolume?: try {
      guard case .mediaUpdateVolume(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .mediaNextFavorite?: try {
      guard case .mediaNextFavorite(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .mediaPreviousFavorite?: try {
      guard case .mediaPreviousFavorite(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .mediaNextTrack?: try {
      guard case .mediaNextTrack(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .mediaPreviousTrack?: try {
      guard case .mediaPreviousTrack(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .getNearbyChargingSites?: try {
      guard case .getNearbyChargingSites(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .vehicleControlCancelSoftwareUpdateAction?: try {
      guard case .vehicleControlCancelSoftwareUpdateAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .vehicleControlFlashLightsAction?: try {
      guard case .vehicleControlFlashLightsAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .vehicleControlHonkHornAction?: try {
      guard case .vehicleControlHonkHornAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .vehicleControlResetValetPinAction?: try {
      guard case .vehicleControlResetValetPinAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .vehicleControlScheduleSoftwareUpdateAction?: try {
      guard case .vehicleControlScheduleSoftwareUpdateAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .vehicleControlSetSentryModeAction?: try {
      guard case .vehicleControlSetSentryModeAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .vehicleControlSetValetModeAction?: try {
      guard case .vehicleControlSetValetModeAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .vehicleControlSunroofOpenCloseAction?: try {
      guard case .vehicleControlSunroofOpenCloseAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .vehicleControlTriggerHomelinkAction?: try {
      guard case .vehicleControlTriggerHomelinkAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .vehicleControlWindowAction?: try {
      guard case .vehicleControlWindowAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .hvacBioweaponModeAction?: try {
      guard case .hvacBioweaponModeAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .hvacSeatHeaterActions?: try {
      guard case .hvacSeatHeaterActions(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .scheduledChargingAction?: try {
      guard case .scheduledChargingAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .scheduledDepartureAction?: try {
      guard case .scheduledDepartureAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .setChargingAmpsAction?: try {
      guard case .setChargingAmpsAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .hvacClimateKeeperAction?: try {
      guard case .hvacClimateKeeperAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .autoSeatClimateAction?: try {
      guard case .autoSeatClimateAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .hvacSeatCoolerActions?: try {
      guard case .hvacSeatCoolerActions(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .setCabinOverheatProtectionAction?: try {
      guard case .setCabinOverheatProtectionAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .setVehicleNameAction?: try {
      guard case .setVehicleNameAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    case .chargePortDoorClose?: try {
      guard case .chargePortDoorClose(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
    }()
    case .chargePortDoorOpen?: try {
      guard case .chargePortDoorOpen(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
    }()
    case .guestModeAction?: try {
      guard case .guestModeAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
    }()
    case .setCopTempAction?: try {
      guard case .setCopTempAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
    }()
    case .eraseUserDataAction?: try {
      guard case .eraseUserDataAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
    }()
    case .vehicleControlSetPinToDriveAction?: try {
      guard case .vehicleControlSetPinToDriveAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 77)
    }()
    case .vehicleControlResetPinToDriveAction?: try {
      guard case .vehicleControlResetPinToDriveAction(let v)? = self.vehicleActionMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 78)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction, rhs: VehicleAction) -> Bool {
    if lhs.vehicleActionMsg != rhs.vehicleActionMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_EraseUserDataAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_EraseUserDataAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_EraseUserDataAction, rhs: VehicleAction_EraseUserDataAction) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actionStatus"),
    3: .same(proto: "getSessionInfoResponse"),
    5: .same(proto: "getNearbyChargingSites"),
    9: .same(proto: "ping"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionStatus) }()
      case 3: try {
        var v: Response_GetSessionInfoResponse?
        var hadOneofValue = false
        if let current = self.responseMsg {
          hadOneofValue = true
          if case .getSessionInfoResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseMsg = .getSessionInfoResponse(v)
        }
      }()
      case 5: try {
        var v: Response_GetNearbyChargingSites?
        var hadOneofValue = false
        if let current = self.responseMsg {
          hadOneofValue = true
          if case .getNearbyChargingSites(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseMsg = .getNearbyChargingSites(v)
        }
      }()
      case 9: try {
        var v: Response_Ping?
        var hadOneofValue = false
        if let current = self.responseMsg {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseMsg = .ping(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.responseMsg {
    case .getSessionInfoResponse?: try {
      guard case .getSessionInfoResponse(let v)? = self.responseMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .getNearbyChargingSites?: try {
      guard case .getNearbyChargingSites(let v)? = self.responseMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.responseMsg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Response, rhs: Response) -> Bool {
    if lhs._actionStatus != rhs._actionStatus {return false}
    if lhs.responseMsg != rhs.responseMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Response_GetSessionInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Response_GetSessionInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "getSessionInfoResponse"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._getSessionInfoResponse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._getSessionInfoResponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Response_GetSessionInfoResponse, rhs: Response_GetSessionInfoResponse) -> Bool {
    if lhs._getSessionInfoResponse != rhs._getSessionInfoResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Response_GetNearbyChargingSites: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Response_GetNearbyChargingSites"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "getNearbyChargingSites"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 5: try { try decoder.decodeSingularMessageField(value: &self._getNearbyChargingSites) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._getNearbyChargingSites {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Response_GetNearbyChargingSites, rhs: Response_GetNearbyChargingSites) -> Bool {
    if lhs._getNearbyChargingSites != rhs._getNearbyChargingSites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Response_Ping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Response_Ping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    9: .same(proto: "ping"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 9: try { try decoder.decodeSingularMessageField(value: &self._ping) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ping {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Response_Ping, rhs: Response_Ping) -> Bool {
    if lhs._ping != rhs._ping {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActionStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ActionStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "result_reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resultReason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .operationstatusOk {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._resultReason {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ActionStatus, rhs: ActionStatus) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._resultReason != rhs._resultReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ResultReason: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ResultReason"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "plain_text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.reason != nil {try decoder.handleConflictingOneOf()}
          self.reason = .plainText(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .plainText(let v)? = self.reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ResultReason, rhs: ResultReason) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EncryptedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EncryptedData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_number"),
    2: .same(proto: "ciphertext"),
    3: .same(proto: "tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.fieldNumber) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.ciphertext) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.tag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fieldNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.fieldNumber, fieldNumber: 1)
    }
    if !self.ciphertext.isEmpty {
      try visitor.visitSingularBytesField(value: self.ciphertext, fieldNumber: 2)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularBytesField(value: self.tag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EncryptedData, rhs: EncryptedData) -> Bool {
    if lhs.fieldNumber != rhs.fieldNumber {return false}
    if lhs.ciphertext != rhs.ciphertext {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_ChargingSetLimitAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_ChargingSetLimitAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "percent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.percent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.percent != 0 {
      try visitor.visitSingularInt32Field(value: self.percent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_ChargingSetLimitAction, rhs: VehicleAction_ChargingSetLimitAction) -> Bool {
    if lhs.percent != rhs.percent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_ChargingStartStopAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_ChargingStartStopAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unknown"),
    2: .same(proto: "start"),
    3: .standard(proto: "start_standard"),
    4: .standard(proto: "start_max_range"),
    5: .same(proto: "stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.chargingAction {
          hadOneofValue = true
          if case .unknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.chargingAction = .unknown(v)
        }
      }()
      case 2: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.chargingAction {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.chargingAction = .start(v)
        }
      }()
      case 3: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.chargingAction {
          hadOneofValue = true
          if case .startStandard(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.chargingAction = .startStandard(v)
        }
      }()
      case 4: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.chargingAction {
          hadOneofValue = true
          if case .startMaxRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.chargingAction = .startMaxRange(v)
        }
      }()
      case 5: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.chargingAction {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.chargingAction = .stop(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.chargingAction {
    case .unknown?: try {
      guard case .unknown(let v)? = self.chargingAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .start?: try {
      guard case .start(let v)? = self.chargingAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .startStandard?: try {
      guard case .startStandard(let v)? = self.chargingAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .startMaxRange?: try {
      guard case .startMaxRange(let v)? = self.chargingAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.chargingAction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_ChargingStartStopAction, rhs: VehicleAction_ChargingStartStopAction) -> Bool {
    if lhs.chargingAction != rhs.chargingAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_DrivingClearSpeedLimitPinAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_DrivingClearSpeedLimitPinAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_DrivingClearSpeedLimitPinAction, rhs: VehicleAction_DrivingClearSpeedLimitPinAction) -> Bool {
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_DrivingSetSpeedLimitAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_DrivingSetSpeedLimitAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "limit_mph"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.limitMph) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.limitMph != 0 {
      try visitor.visitSingularFloatField(value: self.limitMph, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_DrivingSetSpeedLimitAction, rhs: VehicleAction_DrivingSetSpeedLimitAction) -> Bool {
    if lhs.limitMph != rhs.limitMph {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_DrivingSpeedLimitAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_DrivingSpeedLimitAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "activate"),
    2: .same(proto: "pin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.activate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.activate != false {
      try visitor.visitSingularBoolField(value: self.activate, fieldNumber: 1)
    }
    if !self.pin.isEmpty {
      try visitor.visitSingularStringField(value: self.pin, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_DrivingSpeedLimitAction, rhs: VehicleAction_DrivingSpeedLimitAction) -> Bool {
    if lhs.activate != rhs.activate {return false}
    if lhs.pin != rhs.pin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_HvacAutoAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_HvacAutoAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "power_on"),
    2: .standard(proto: "manual_override"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.powerOn) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.manualOverride) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.powerOn != false {
      try visitor.visitSingularBoolField(value: self.powerOn, fieldNumber: 1)
    }
    if self.manualOverride != false {
      try visitor.visitSingularBoolField(value: self.manualOverride, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_HvacAutoAction, rhs: VehicleAction_HvacAutoAction) -> Bool {
    if lhs.powerOn != rhs.powerOn {return false}
    if lhs.manualOverride != rhs.manualOverride {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_HvacSeatHeaterActions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_HvacSeatHeaterActions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hvacSeatHeaterAction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hvacSeatHeaterAction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hvacSeatHeaterAction.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hvacSeatHeaterAction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_HvacSeatHeaterActions, rhs: VehicleAction_HvacSeatHeaterActions) -> Bool {
    if lhs.hvacSeatHeaterAction != rhs.hvacSeatHeaterAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_HvacSeatCoolerActions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_HvacSeatCoolerActions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hvacSeatCoolerAction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hvacSeatCoolerAction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hvacSeatCoolerAction.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hvacSeatCoolerAction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_HvacSeatCoolerActions, rhs: VehicleAction_HvacSeatCoolerActions) -> Bool {
    if lhs.hvacSeatCoolerAction != rhs.hvacSeatCoolerAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HvacSeatCoolerActions_HvacSeatCoolerAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HvacSeatCoolerActions_HvacSeatCoolerAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "seat_cooler_level"),
    2: .same(proto: "seatPosition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.seatCoolerLevel) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.seatPosition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seatCoolerLevel != .hvacSeatCoolerLevelUnknown {
      try visitor.visitSingularEnumField(value: self.seatCoolerLevel, fieldNumber: 1)
    }
    if self.seatPosition != .hvacSeatCoolerPositionUnknown {
      try visitor.visitSingularEnumField(value: self.seatPosition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HvacSeatCoolerActions_HvacSeatCoolerAction, rhs: HvacSeatCoolerActions_HvacSeatCoolerAction) -> Bool {
    if lhs.seatCoolerLevel != rhs.seatCoolerLevel {return false}
    if lhs.seatPosition != rhs.seatPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_HvacSetPreconditioningMaxAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_HvacSetPreconditioningMaxAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .standard(proto: "manual_override"),
    3: .standard(proto: "manual_override_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.manualOverride) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.manualOverrideMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    if self.manualOverride != false {
      try visitor.visitSingularBoolField(value: self.manualOverride, fieldNumber: 2)
    }
    if !self.manualOverrideMode.isEmpty {
      try visitor.visitPackedEnumField(value: self.manualOverrideMode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_HvacSetPreconditioningMaxAction, rhs: VehicleAction_HvacSetPreconditioningMaxAction) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.manualOverride != rhs.manualOverride {return false}
    if lhs.manualOverrideMode != rhs.manualOverrideMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_HvacSteeringWheelHeaterAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_HvacSteeringWheelHeaterAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "power_on"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.powerOn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.powerOn != false {
      try visitor.visitSingularBoolField(value: self.powerOn, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_HvacSteeringWheelHeaterAction, rhs: VehicleAction_HvacSteeringWheelHeaterAction) -> Bool {
    if lhs.powerOn != rhs.powerOn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_HvacTemperatureAdjustmentAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_HvacTemperatureAdjustmentAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delta_celsius"),
    2: .standard(proto: "delta_percent"),
    3: .standard(proto: "absolute_celsius"),
    5: .same(proto: "level"),
    4: .standard(proto: "hvac_temperature_zone"),
    6: .standard(proto: "driver_temp_celsius"),
    7: .standard(proto: "passenger_temp_celsius"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.deltaCelsius) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self.deltaPercent) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.absoluteCelsius) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.hvacTemperatureZone) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._level) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.driverTempCelsius) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.passengerTempCelsius) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.deltaCelsius != 0 {
      try visitor.visitSingularFloatField(value: self.deltaCelsius, fieldNumber: 1)
    }
    if self.deltaPercent != 0 {
      try visitor.visitSingularSInt32Field(value: self.deltaPercent, fieldNumber: 2)
    }
    if self.absoluteCelsius != 0 {
      try visitor.visitSingularFloatField(value: self.absoluteCelsius, fieldNumber: 3)
    }
    if !self.hvacTemperatureZone.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hvacTemperatureZone, fieldNumber: 4)
    }
    try { if let v = self._level {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.driverTempCelsius != 0 {
      try visitor.visitSingularFloatField(value: self.driverTempCelsius, fieldNumber: 6)
    }
    if self.passengerTempCelsius != 0 {
      try visitor.visitSingularFloatField(value: self.passengerTempCelsius, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_HvacTemperatureAdjustmentAction, rhs: VehicleAction_HvacTemperatureAdjustmentAction) -> Bool {
    if lhs.deltaCelsius != rhs.deltaCelsius {return false}
    if lhs.deltaPercent != rhs.deltaPercent {return false}
    if lhs.absoluteCelsius != rhs.absoluteCelsius {return false}
    if lhs._level != rhs._level {return false}
    if lhs.hvacTemperatureZone != rhs.hvacTemperatureZone {return false}
    if lhs.driverTempCelsius != rhs.driverTempCelsius {return false}
    if lhs.passengerTempCelsius != rhs.passengerTempCelsius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_GetNearbyChargingSites: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_GetNearbyChargingSites"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "include_meta_data"),
    2: .same(proto: "radius"),
    3: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.includeMetaData) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.radius) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.includeMetaData != false {
      try visitor.visitSingularBoolField(value: self.includeMetaData, fieldNumber: 1)
    }
    if self.radius != 0 {
      try visitor.visitSingularInt32Field(value: self.radius, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_GetNearbyChargingSites, rhs: VehicleAction_GetNearbyChargingSites) -> Bool {
    if lhs.includeMetaData != rhs.includeMetaData {return false}
    if lhs.radius != rhs.radius {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NearbyChargingSites: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NearbyChargingSites"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    3: .same(proto: "superchargers"),
    4: .standard(proto: "congestion_sync_time_utc_secs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.superchargers) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.congestionSyncTimeUtcSecs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.superchargers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.superchargers, fieldNumber: 3)
    }
    if self.congestionSyncTimeUtcSecs != 0 {
      try visitor.visitSingularInt64Field(value: self.congestionSyncTimeUtcSecs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NearbyChargingSites, rhs: NearbyChargingSites) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.superchargers != rhs.superchargers {return false}
    if lhs.congestionSyncTimeUtcSecs != rhs.congestionSyncTimeUtcSecs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Superchargers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Superchargers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "amenities"),
    3: .standard(proto: "available_stalls"),
    4: .standard(proto: "billing_info"),
    5: .standard(proto: "billing_time"),
    6: .same(proto: "city"),
    7: .same(proto: "country"),
    8: .standard(proto: "distance_miles"),
    9: .same(proto: "district"),
    10: .same(proto: "location"),
    11: .same(proto: "name"),
    12: .standard(proto: "postal_code"),
    13: .standard(proto: "site_closed"),
    14: .same(proto: "state"),
    15: .standard(proto: "street_address"),
    16: .standard(proto: "total_stalls"),
    17: .standard(proto: "within_range"),
    18: .standard(proto: "max_power_kw"),
    19: .standard(proto: "out_of_order_stalls_number"),
    20: .standard(proto: "out_of_order_stalls_names"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _amenities: String = String()
    var _availableStalls: Int32 = 0
    var _billingInfo: String = String()
    var _billingTime: String = String()
    var _city: String = String()
    var _country: String = String()
    var _distanceMiles: Float = 0
    var _district: String = String()
    var _location: LatLong? = nil
    var _name: String = String()
    var _postalCode: String = String()
    var _siteClosed: Bool = false
    var _state: String = String()
    var _streetAddress: String = String()
    var _totalStalls: Int32 = 0
    var _withinRange: Bool = false
    var _maxPowerKw: Int32 = 0
    var _outOfOrderStallsNumber: Int32 = 0
    var _outOfOrderStallsNames: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _amenities = source._amenities
      _availableStalls = source._availableStalls
      _billingInfo = source._billingInfo
      _billingTime = source._billingTime
      _city = source._city
      _country = source._country
      _distanceMiles = source._distanceMiles
      _district = source._district
      _location = source._location
      _name = source._name
      _postalCode = source._postalCode
      _siteClosed = source._siteClosed
      _state = source._state
      _streetAddress = source._streetAddress
      _totalStalls = source._totalStalls
      _withinRange = source._withinRange
      _maxPowerKw = source._maxPowerKw
      _outOfOrderStallsNumber = source._outOfOrderStallsNumber
      _outOfOrderStallsNames = source._outOfOrderStallsNames
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._amenities) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._availableStalls) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._billingInfo) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._billingTime) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._city) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._country) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._distanceMiles) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._district) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._postalCode) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._siteClosed) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._state) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._streetAddress) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._totalStalls) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._withinRange) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._maxPowerKw) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._outOfOrderStallsNumber) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._outOfOrderStallsNames) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._amenities.isEmpty {
        try visitor.visitSingularStringField(value: _storage._amenities, fieldNumber: 2)
      }
      if _storage._availableStalls != 0 {
        try visitor.visitSingularInt32Field(value: _storage._availableStalls, fieldNumber: 3)
      }
      if !_storage._billingInfo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._billingInfo, fieldNumber: 4)
      }
      if !_storage._billingTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._billingTime, fieldNumber: 5)
      }
      if !_storage._city.isEmpty {
        try visitor.visitSingularStringField(value: _storage._city, fieldNumber: 6)
      }
      if !_storage._country.isEmpty {
        try visitor.visitSingularStringField(value: _storage._country, fieldNumber: 7)
      }
      if _storage._distanceMiles != 0 {
        try visitor.visitSingularFloatField(value: _storage._distanceMiles, fieldNumber: 8)
      }
      if !_storage._district.isEmpty {
        try visitor.visitSingularStringField(value: _storage._district, fieldNumber: 9)
      }
      try { if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 11)
      }
      if !_storage._postalCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._postalCode, fieldNumber: 12)
      }
      if _storage._siteClosed != false {
        try visitor.visitSingularBoolField(value: _storage._siteClosed, fieldNumber: 13)
      }
      if !_storage._state.isEmpty {
        try visitor.visitSingularStringField(value: _storage._state, fieldNumber: 14)
      }
      if !_storage._streetAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._streetAddress, fieldNumber: 15)
      }
      if _storage._totalStalls != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalStalls, fieldNumber: 16)
      }
      if _storage._withinRange != false {
        try visitor.visitSingularBoolField(value: _storage._withinRange, fieldNumber: 17)
      }
      if _storage._maxPowerKw != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxPowerKw, fieldNumber: 18)
      }
      if _storage._outOfOrderStallsNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._outOfOrderStallsNumber, fieldNumber: 19)
      }
      if !_storage._outOfOrderStallsNames.isEmpty {
        try visitor.visitSingularStringField(value: _storage._outOfOrderStallsNames, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Superchargers, rhs: Superchargers) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._amenities != rhs_storage._amenities {return false}
        if _storage._availableStalls != rhs_storage._availableStalls {return false}
        if _storage._billingInfo != rhs_storage._billingInfo {return false}
        if _storage._billingTime != rhs_storage._billingTime {return false}
        if _storage._city != rhs_storage._city {return false}
        if _storage._country != rhs_storage._country {return false}
        if _storage._distanceMiles != rhs_storage._distanceMiles {return false}
        if _storage._district != rhs_storage._district {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._postalCode != rhs_storage._postalCode {return false}
        if _storage._siteClosed != rhs_storage._siteClosed {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._streetAddress != rhs_storage._streetAddress {return false}
        if _storage._totalStalls != rhs_storage._totalStalls {return false}
        if _storage._withinRange != rhs_storage._withinRange {return false}
        if _storage._maxPowerKw != rhs_storage._maxPowerKw {return false}
        if _storage._outOfOrderStallsNumber != rhs_storage._outOfOrderStallsNumber {return false}
        if _storage._outOfOrderStallsNames != rhs_storage._outOfOrderStallsNames {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_MediaUpdateVolume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_MediaUpdateVolume"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "volume_delta"),
    3: .standard(proto: "volume_absolute_float"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int32?
        try decoder.decodeSingularSInt32Field(value: &v)
        if let v = v {
          if self.mediaVolume != nil {try decoder.handleConflictingOneOf()}
          self.mediaVolume = .volumeDelta(v)
        }
      }()
      case 3: try {
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {
          if self.mediaVolume != nil {try decoder.handleConflictingOneOf()}
          self.mediaVolume = .volumeAbsoluteFloat(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.mediaVolume {
    case .volumeDelta?: try {
      guard case .volumeDelta(let v)? = self.mediaVolume else { preconditionFailure() }
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 1)
    }()
    case .volumeAbsoluteFloat?: try {
      guard case .volumeAbsoluteFloat(let v)? = self.mediaVolume else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_MediaUpdateVolume, rhs: VehicleAction_MediaUpdateVolume) -> Bool {
    if lhs.mediaVolume != rhs.mediaVolume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_MediaNextFavorite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_MediaNextFavorite"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_MediaNextFavorite, rhs: VehicleAction_MediaNextFavorite) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_MediaPreviousFavorite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_MediaPreviousFavorite"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_MediaPreviousFavorite, rhs: VehicleAction_MediaPreviousFavorite) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_MediaNextTrack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_MediaNextTrack"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_MediaNextTrack, rhs: VehicleAction_MediaNextTrack) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_MediaPreviousTrack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_MediaPreviousTrack"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_MediaPreviousTrack, rhs: VehicleAction_MediaPreviousTrack) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_VehicleControlCancelSoftwareUpdateAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_VehicleControlCancelSoftwareUpdateAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_VehicleControlCancelSoftwareUpdateAction, rhs: VehicleAction_VehicleControlCancelSoftwareUpdateAction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_VehicleControlFlashLightsAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_VehicleControlFlashLightsAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_VehicleControlFlashLightsAction, rhs: VehicleAction_VehicleControlFlashLightsAction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_VehicleControlHonkHornAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_VehicleControlHonkHornAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_VehicleControlHonkHornAction, rhs: VehicleAction_VehicleControlHonkHornAction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_VehicleControlResetValetPinAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_VehicleControlResetValetPinAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_VehicleControlResetValetPinAction, rhs: VehicleAction_VehicleControlResetValetPinAction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_VehicleControlScheduleSoftwareUpdateAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_VehicleControlScheduleSoftwareUpdateAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offset_sec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.offsetSec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offsetSec != 0 {
      try visitor.visitSingularInt32Field(value: self.offsetSec, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_VehicleControlScheduleSoftwareUpdateAction, rhs: VehicleAction_VehicleControlScheduleSoftwareUpdateAction) -> Bool {
    if lhs.offsetSec != rhs.offsetSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_VehicleControlSetSentryModeAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_VehicleControlSetSentryModeAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_VehicleControlSetSentryModeAction, rhs: VehicleAction_VehicleControlSetSentryModeAction) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_VehicleControlSetValetModeAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_VehicleControlSetValetModeAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_VehicleControlSetValetModeAction, rhs: VehicleAction_VehicleControlSetValetModeAction) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_VehicleControlSunroofOpenCloseAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_VehicleControlSunroofOpenCloseAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "absolute_level"),
    2: .standard(proto: "delta_level"),
    3: .same(proto: "vent"),
    4: .same(proto: "close"),
    5: .same(proto: "open"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.sunroofLevel != nil {try decoder.handleConflictingOneOf()}
          self.sunroofLevel = .absoluteLevel(v)
        }
      }()
      case 2: try {
        var v: Int32?
        try decoder.decodeSingularSInt32Field(value: &v)
        if let v = v {
          if self.sunroofLevel != nil {try decoder.handleConflictingOneOf()}
          self.sunroofLevel = .deltaLevel(v)
        }
      }()
      case 3: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .vent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .vent(v)
        }
      }()
      case 4: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .close(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .close(v)
        }
      }()
      case 5: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .open(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .open(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.sunroofLevel {
    case .absoluteLevel?: try {
      guard case .absoluteLevel(let v)? = self.sunroofLevel else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }()
    case .deltaLevel?: try {
      guard case .deltaLevel(let v)? = self.sunroofLevel else { preconditionFailure() }
      try visitor.visitSingularSInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    switch self.action {
    case .vent?: try {
      guard case .vent(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .close?: try {
      guard case .close(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .open?: try {
      guard case .open(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_VehicleControlSunroofOpenCloseAction, rhs: VehicleAction_VehicleControlSunroofOpenCloseAction) -> Bool {
    if lhs.sunroofLevel != rhs.sunroofLevel {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_VehicleControlTriggerHomelinkAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_VehicleControlTriggerHomelinkAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_VehicleControlTriggerHomelinkAction, rhs: VehicleAction_VehicleControlTriggerHomelinkAction) -> Bool {
    if lhs._location != rhs._location {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_VehicleControlWindowAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_VehicleControlWindowAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "unknown"),
    3: .same(proto: "vent"),
    4: .same(proto: "close"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 2: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .unknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .unknown(v)
        }
      }()
      case 3: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .vent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .vent(v)
        }
      }()
      case 4: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .close(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .close(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.action {
    case .unknown?: try {
      guard case .unknown(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .vent?: try {
      guard case .vent(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .close?: try {
      guard case .close(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_VehicleControlWindowAction, rhs: VehicleAction_VehicleControlWindowAction) -> Bool {
    if lhs._location != rhs._location {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_HvacBioweaponModeAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_HvacBioweaponModeAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .standard(proto: "manual_override"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.manualOverride) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    if self.manualOverride != false {
      try visitor.visitSingularBoolField(value: self.manualOverride, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_HvacBioweaponModeAction, rhs: VehicleAction_HvacBioweaponModeAction) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.manualOverride != rhs.manualOverride {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_AutoSeatClimateAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_AutoSeatClimateAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "carseat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.carseat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.carseat.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.carseat, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_AutoSeatClimateAction, rhs: VehicleAction_AutoSeatClimateAction) -> Bool {
    if lhs.carseat != rhs.carseat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Ping"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ping_id"),
    2: .standard(proto: "local_timestamp"),
    3: .standard(proto: "last_remote_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pingID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._localTimestamp) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastRemoteTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pingID != 0 {
      try visitor.visitSingularInt32Field(value: self.pingID, fieldNumber: 1)
    }
    try { if let v = self._localTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastRemoteTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ping, rhs: Ping) -> Bool {
    if lhs.pingID != rhs.pingID {return false}
    if lhs._localTimestamp != rhs._localTimestamp {return false}
    if lhs._lastRemoteTimestamp != rhs._lastRemoteTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_ScheduledChargingAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_ScheduledChargingAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "charging_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.chargingTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.chargingTime != 0 {
      try visitor.visitSingularInt32Field(value: self.chargingTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_ScheduledChargingAction, rhs: VehicleAction_ScheduledChargingAction) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.chargingTime != rhs.chargingTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_ScheduledDepartureAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_ScheduledDepartureAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "departure_time"),
    3: .standard(proto: "preconditioning_times"),
    4: .standard(proto: "off_peak_charging_times"),
    5: .standard(proto: "off_peak_hours_end_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.departureTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._preconditioningTimes) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._offPeakChargingTimes) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.offPeakHoursEndTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.departureTime != 0 {
      try visitor.visitSingularInt32Field(value: self.departureTime, fieldNumber: 2)
    }
    try { if let v = self._preconditioningTimes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._offPeakChargingTimes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.offPeakHoursEndTime != 0 {
      try visitor.visitSingularInt32Field(value: self.offPeakHoursEndTime, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_ScheduledDepartureAction, rhs: VehicleAction_ScheduledDepartureAction) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.departureTime != rhs.departureTime {return false}
    if lhs._preconditioningTimes != rhs._preconditioningTimes {return false}
    if lhs._offPeakChargingTimes != rhs._offPeakChargingTimes {return false}
    if lhs.offPeakHoursEndTime != rhs.offPeakHoursEndTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_HvacClimateKeeperAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_HvacClimateKeeperAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ClimateKeeperAction"),
    2: .standard(proto: "manual_override"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.climateKeeperAction) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.manualOverride) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.climateKeeperAction != .climateKeeperActionOff {
      try visitor.visitSingularEnumField(value: self.climateKeeperAction, fieldNumber: 1)
    }
    if self.manualOverride != false {
      try visitor.visitSingularBoolField(value: self.manualOverride, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_HvacClimateKeeperAction, rhs: VehicleAction_HvacClimateKeeperAction) -> Bool {
    if lhs.climateKeeperAction != rhs.climateKeeperAction {return false}
    if lhs.manualOverride != rhs.manualOverride {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_SetChargingAmpsAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_SetChargingAmpsAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "charging_amps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.chargingAmps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chargingAmps != 0 {
      try visitor.visitSingularInt32Field(value: self.chargingAmps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_SetChargingAmpsAction, rhs: VehicleAction_SetChargingAmpsAction) -> Bool {
    if lhs.chargingAmps != rhs.chargingAmps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_SetCabinOverheatProtectionAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_SetCabinOverheatProtectionAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .standard(proto: "fan_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.fanOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    if self.fanOnly != false {
      try visitor.visitSingularBoolField(value: self.fanOnly, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_SetCabinOverheatProtectionAction, rhs: VehicleAction_SetCabinOverheatProtectionAction) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.fanOnly != rhs.fanOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_SetVehicleNameAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_SetVehicleNameAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vehicleName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vehicleName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vehicleName.isEmpty {
      try visitor.visitSingularStringField(value: self.vehicleName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_SetVehicleNameAction, rhs: VehicleAction_SetVehicleNameAction) -> Bool {
    if lhs.vehicleName != rhs.vehicleName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_ChargePortDoorClose: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_ChargePortDoorClose"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_ChargePortDoorClose, rhs: VehicleAction_ChargePortDoorClose) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_ChargePortDoorOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_ChargePortDoorOpen"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_ChargePortDoorOpen, rhs: VehicleAction_ChargePortDoorOpen) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_SetCopTempAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_SetCopTempAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "copActivationTemp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.copActivationTemp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.copActivationTemp != .copActivationTempUnspecified {
      try visitor.visitSingularEnumField(value: self.copActivationTemp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_SetCopTempAction, rhs: VehicleAction_SetCopTempAction) -> Bool {
    if lhs.copActivationTemp != rhs.copActivationTemp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_VehicleControlSetPinToDriveAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_VehicleControlSetPinToDriveAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_VehicleControlSetPinToDriveAction, rhs: VehicleAction_VehicleControlSetPinToDriveAction) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleAction_VehicleControlResetPinToDriveAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleAction_VehicleControlResetPinToDriveAction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleAction_VehicleControlResetPinToDriveAction, rhs: VehicleAction_VehicleControlResetPinToDriveAction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HvacSeatHeaterActions_HvacSeatHeaterAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HvacSeatHeaterActions_HvacSeatHeaterAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "SEAT_HEATER_UNKNOWN"),
    2: .standard(proto: "SEAT_HEATER_OFF"),
    3: .standard(proto: "SEAT_HEATER_LOW"),
    4: .standard(proto: "SEAT_HEATER_MED"),
    5: .standard(proto: "SEAT_HEATER_HIGH"),
    6: .standard(proto: "CAR_SEAT_UNKNOWN"),
    7: .standard(proto: "CAR_SEAT_FRONT_LEFT"),
    8: .standard(proto: "CAR_SEAT_FRONT_RIGHT"),
    9: .standard(proto: "CAR_SEAT_REAR_LEFT"),
    10: .standard(proto: "CAR_SEAT_REAR_LEFT_BACK"),
    11: .standard(proto: "CAR_SEAT_REAR_CENTER"),
    12: .standard(proto: "CAR_SEAT_REAR_RIGHT"),
    13: .standard(proto: "CAR_SEAT_REAR_RIGHT_BACK"),
    14: .standard(proto: "CAR_SEAT_THIRD_ROW_LEFT"),
    15: .standard(proto: "CAR_SEAT_THIRD_ROW_RIGHT"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatHeaterLevel {
          hadOneofValue = true
          if case .seatHeaterUnknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatHeaterLevel = .seatHeaterUnknown(v)
        }
      }()
      case 2: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatHeaterLevel {
          hadOneofValue = true
          if case .seatHeaterOff(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatHeaterLevel = .seatHeaterOff(v)
        }
      }()
      case 3: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatHeaterLevel {
          hadOneofValue = true
          if case .seatHeaterLow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatHeaterLevel = .seatHeaterLow(v)
        }
      }()
      case 4: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatHeaterLevel {
          hadOneofValue = true
          if case .seatHeaterMed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatHeaterLevel = .seatHeaterMed(v)
        }
      }()
      case 5: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatHeaterLevel {
          hadOneofValue = true
          if case .seatHeaterHigh(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatHeaterLevel = .seatHeaterHigh(v)
        }
      }()
      case 6: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatUnknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatUnknown(v)
        }
      }()
      case 7: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatFrontLeft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatFrontLeft(v)
        }
      }()
      case 8: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatFrontRight(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatFrontRight(v)
        }
      }()
      case 9: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatRearLeft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatRearLeft(v)
        }
      }()
      case 10: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatRearLeftBack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatRearLeftBack(v)
        }
      }()
      case 11: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatRearCenter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatRearCenter(v)
        }
      }()
      case 12: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatRearRight(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatRearRight(v)
        }
      }()
      case 13: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatRearRightBack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatRearRightBack(v)
        }
      }()
      case 14: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatThirdRowLeft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatThirdRowLeft(v)
        }
      }()
      case 15: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.seatPosition {
          hadOneofValue = true
          if case .carSeatThirdRowRight(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.seatPosition = .carSeatThirdRowRight(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.seatHeaterLevel {
    case .seatHeaterUnknown?: try {
      guard case .seatHeaterUnknown(let v)? = self.seatHeaterLevel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .seatHeaterOff?: try {
      guard case .seatHeaterOff(let v)? = self.seatHeaterLevel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .seatHeaterLow?: try {
      guard case .seatHeaterLow(let v)? = self.seatHeaterLevel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .seatHeaterMed?: try {
      guard case .seatHeaterMed(let v)? = self.seatHeaterLevel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .seatHeaterHigh?: try {
      guard case .seatHeaterHigh(let v)? = self.seatHeaterLevel else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    switch self.seatPosition {
    case .carSeatUnknown?: try {
      guard case .carSeatUnknown(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .carSeatFrontLeft?: try {
      guard case .carSeatFrontLeft(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .carSeatFrontRight?: try {
      guard case .carSeatFrontRight(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .carSeatRearLeft?: try {
      guard case .carSeatRearLeft(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .carSeatRearLeftBack?: try {
      guard case .carSeatRearLeftBack(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .carSeatRearCenter?: try {
      guard case .carSeatRearCenter(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .carSeatRearRight?: try {
      guard case .carSeatRearRight(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .carSeatRearRightBack?: try {
      guard case .carSeatRearRightBack(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .carSeatThirdRowLeft?: try {
      guard case .carSeatThirdRowLeft(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .carSeatThirdRowRight?: try {
      guard case .carSeatThirdRowRight(let v)? = self.seatPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HvacSeatHeaterActions_HvacSeatHeaterAction, rhs: HvacSeatHeaterActions_HvacSeatHeaterAction) -> Bool {
    if lhs.seatHeaterLevel != rhs.seatHeaterLevel {return false}
    if lhs.seatPosition != rhs.seatPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HvacTemperatureAdjustmentAction_Temperature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HvacTemperatureAdjustmentAction_Temperature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "TEMP_UNKNOWN"),
    2: .standard(proto: "TEMP_MIN"),
    3: .standard(proto: "TEMP_MAX"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tempUnknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tempUnknown(v)
        }
      }()
      case 2: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tempMin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tempMin(v)
        }
      }()
      case 3: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tempMax(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tempMax(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .tempUnknown?: try {
      guard case .tempUnknown(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .tempMin?: try {
      guard case .tempMin(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .tempMax?: try {
      guard case .tempMax(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HvacTemperatureAdjustmentAction_Temperature, rhs: HvacTemperatureAdjustmentAction_Temperature) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HvacTemperatureAdjustmentAction_HvacTemperatureZone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HvacTemperatureAdjustmentAction_HvacTemperatureZone"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "TEMP_ZONE_UNKNOWN"),
    2: .standard(proto: "TEMP_ZONE_FRONT_LEFT"),
    3: .standard(proto: "TEMP_ZONE_FRONT_RIGHT"),
    4: .standard(proto: "TEMP_ZONE_REAR"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tempZoneUnknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tempZoneUnknown(v)
        }
      }()
      case 2: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tempZoneFrontLeft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tempZoneFrontLeft(v)
        }
      }()
      case 3: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tempZoneFrontRight(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tempZoneFrontRight(v)
        }
      }()
      case 4: try {
        var v: Void?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .tempZoneRear(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .tempZoneRear(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .tempZoneUnknown?: try {
      guard case .tempZoneUnknown(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .tempZoneFrontLeft?: try {
      guard case .tempZoneFrontLeft(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .tempZoneFrontRight?: try {
      guard case .tempZoneFrontRight(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .tempZoneRear?: try {
      guard case .tempZoneRear(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HvacTemperatureAdjustmentAction_HvacTemperatureZone, rhs: HvacTemperatureAdjustmentAction_HvacTemperatureZone) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoSeatClimateAction_CarSeat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AutoSeatClimateAction_CarSeat"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .standard(proto: "seat_position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.on) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.seatPosition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.on != false {
      try visitor.visitSingularBoolField(value: self.on, fieldNumber: 1)
    }
    if self.seatPosition != .autoSeatPositionUnknown {
      try visitor.visitSingularEnumField(value: self.seatPosition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoSeatClimateAction_CarSeat, rhs: AutoSeatClimateAction_CarSeat) -> Bool {
    if lhs.on != rhs.on {return false}
    if lhs.seatPosition != rhs.seatPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
