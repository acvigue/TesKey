// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: signatures.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.
//
// Adapted from https://github.com/teslamotors/vehicle-command

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Session_Info_Status: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ok // = 0
  case keyNotOnWhitelist // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .ok
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .keyNotOnWhitelist
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ok: return 0
    case .keyNotOnWhitelist: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Session_Info_Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Session_Info_Status] = [
    .ok,
    .keyNotOnWhitelist,
  ]
}

#endif  // swift(>=4.2)

struct AES_GCM_Personalized_Signature_Data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var epoch: Data = Data()

  var nonce: Data = Data()

  var counter: UInt32 = 0

  var expiresAt: UInt32 = 0

  var tag: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AES_GCM_Response_Signature_Data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: Data = Data()

  var counter: UInt32 = 0

  var tag: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetSessionInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyIdentity: KeyIdentity {
    get {return _keyIdentity ?? KeyIdentity()}
    set {_keyIdentity = newValue}
  }
  /// Returns true if `keyIdentity` has been explicitly set.
  var hasKeyIdentity: Bool {return self._keyIdentity != nil}
  /// Clears the value of `keyIdentity`. Subsequent reads from it will return its default value.
  mutating func clearKeyIdentity() {self._keyIdentity = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyIdentity: KeyIdentity? = nil
}

struct HMAC_Personalized_Signature_Data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var epoch: Data = Data()

  var counter: UInt32 = 0

  var expiresAt: UInt32 = 0

  var tag: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HMAC_Signature_Data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tag: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct KeyIdentity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: KeyIdentity.OneOf_SubMessage? = nil

  var publicKey: Data {
    get {
      if case .publicKey(let v)? = subMessage {return v}
      return Data()
    }
    set {subMessage = .publicKey(newValue)}
  }

  var keyID: Data {
    get {
      if case .keyID(let v)? = subMessage {return v}
      return Data()
    }
    set {subMessage = .keyID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case publicKey(Data)
    case keyID(Data)

  #if !swift(>=4.1)
    static func ==(lhs: KeyIdentity.OneOf_SubMessage, rhs: KeyIdentity.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.publicKey, .publicKey): return {
        guard case .publicKey(let l) = lhs, case .publicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keyID, .keyID): return {
        guard case .keyID(let l) = lhs, case .keyID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Present_Key_Signature_Data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var authToken: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RSA_Signature_Data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var expiresAt: UInt32 = 0

  var signature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SessionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var counter: UInt32 = 0

  var publicKey: Data = Data()

  var epoch: Data = Data()

  var clockTime: UInt32 = 0

  var status: Session_Info_Status = .ok

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SignatureData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signerIdentity: KeyIdentity {
    get {return _signerIdentity ?? KeyIdentity()}
    set {_signerIdentity = newValue}
  }
  /// Returns true if `signerIdentity` has been explicitly set.
  var hasSignerIdentity: Bool {return self._signerIdentity != nil}
  /// Clears the value of `signerIdentity`. Subsequent reads from it will return its default value.
  mutating func clearSignerIdentity() {self._signerIdentity = nil}

  var subMessage: SignatureData.OneOf_SubMessage? = nil

  var presentKeyData: Present_Key_Signature_Data {
    get {
      if case .presentKeyData(let v)? = subMessage {return v}
      return Present_Key_Signature_Data()
    }
    set {subMessage = .presentKeyData(newValue)}
  }

  var aesGcmPersonalizedData: AES_GCM_Personalized_Signature_Data {
    get {
      if case .aesGcmPersonalizedData(let v)? = subMessage {return v}
      return AES_GCM_Personalized_Signature_Data()
    }
    set {subMessage = .aesGcmPersonalizedData(newValue)}
  }

  var sessionInfoTag: HMAC_Signature_Data {
    get {
      if case .sessionInfoTag(let v)? = subMessage {return v}
      return HMAC_Signature_Data()
    }
    set {subMessage = .sessionInfoTag(newValue)}
  }

  var rsaData: RSA_Signature_Data {
    get {
      if case .rsaData(let v)? = subMessage {return v}
      return RSA_Signature_Data()
    }
    set {subMessage = .rsaData(newValue)}
  }

  var hmacPersonalizedData: HMAC_Personalized_Signature_Data {
    get {
      if case .hmacPersonalizedData(let v)? = subMessage {return v}
      return HMAC_Personalized_Signature_Data()
    }
    set {subMessage = .hmacPersonalizedData(newValue)}
  }

  var aesGcmResponseData: AES_GCM_Response_Signature_Data {
    get {
      if case .aesGcmResponseData(let v)? = subMessage {return v}
      return AES_GCM_Response_Signature_Data()
    }
    set {subMessage = .aesGcmResponseData(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case presentKeyData(Present_Key_Signature_Data)
    case aesGcmPersonalizedData(AES_GCM_Personalized_Signature_Data)
    case sessionInfoTag(HMAC_Signature_Data)
    case rsaData(RSA_Signature_Data)
    case hmacPersonalizedData(HMAC_Personalized_Signature_Data)
    case aesGcmResponseData(AES_GCM_Response_Signature_Data)

  #if !swift(>=4.1)
    static func ==(lhs: SignatureData.OneOf_SubMessage, rhs: SignatureData.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.presentKeyData, .presentKeyData): return {
        guard case .presentKeyData(let l) = lhs, case .presentKeyData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.aesGcmPersonalizedData, .aesGcmPersonalizedData): return {
        guard case .aesGcmPersonalizedData(let l) = lhs, case .aesGcmPersonalizedData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionInfoTag, .sessionInfoTag): return {
        guard case .sessionInfoTag(let l) = lhs, case .sessionInfoTag(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rsaData, .rsaData): return {
        guard case .rsaData(let l) = lhs, case .rsaData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hmacPersonalizedData, .hmacPersonalizedData): return {
        guard case .hmacPersonalizedData(let l) = lhs, case .hmacPersonalizedData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.aesGcmResponseData, .aesGcmResponseData): return {
        guard case .aesGcmResponseData(let l) = lhs, case .aesGcmResponseData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _signerIdentity: KeyIdentity? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Session_Info_Status: @unchecked Sendable {}
extension AES_GCM_Personalized_Signature_Data: @unchecked Sendable {}
extension AES_GCM_Response_Signature_Data: @unchecked Sendable {}
extension GetSessionInfoRequest: @unchecked Sendable {}
extension HMAC_Personalized_Signature_Data: @unchecked Sendable {}
extension HMAC_Signature_Data: @unchecked Sendable {}
extension KeyIdentity: @unchecked Sendable {}
extension KeyIdentity.OneOf_SubMessage: @unchecked Sendable {}
extension Present_Key_Signature_Data: @unchecked Sendable {}
extension RSA_Signature_Data: @unchecked Sendable {}
extension SessionInfo: @unchecked Sendable {}
extension SignatureData: @unchecked Sendable {}
extension SignatureData.OneOf_SubMessage: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Session_Info_Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SESSION_INFO_STATUS_OK"),
    1: .same(proto: "SESSION_INFO_STATUS_KEY_NOT_ON_WHITELIST"),
  ]
}

extension AES_GCM_Personalized_Signature_Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AES_GCM_Personalized_Signature_Data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "epoch"),
    2: .same(proto: "nonce"),
    3: .same(proto: "counter"),
    4: .standard(proto: "expires_at"),
    5: .same(proto: "tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.epoch) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.counter) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self.expiresAt) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.tag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.epoch.isEmpty {
      try visitor.visitSingularBytesField(value: self.epoch, fieldNumber: 1)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 2)
    }
    if self.counter != 0 {
      try visitor.visitSingularUInt32Field(value: self.counter, fieldNumber: 3)
    }
    if self.expiresAt != 0 {
      try visitor.visitSingularFixed32Field(value: self.expiresAt, fieldNumber: 4)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularBytesField(value: self.tag, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AES_GCM_Personalized_Signature_Data, rhs: AES_GCM_Personalized_Signature_Data) -> Bool {
    if lhs.epoch != rhs.epoch {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.counter != rhs.counter {return false}
    if lhs.expiresAt != rhs.expiresAt {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AES_GCM_Response_Signature_Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AES_GCM_Response_Signature_Data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .same(proto: "counter"),
    3: .same(proto: "tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.counter) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.tag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 1)
    }
    if self.counter != 0 {
      try visitor.visitSingularUInt32Field(value: self.counter, fieldNumber: 2)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularBytesField(value: self.tag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AES_GCM_Response_Signature_Data, rhs: AES_GCM_Response_Signature_Data) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.counter != rhs.counter {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetSessionInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetSessionInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_identity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyIdentity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetSessionInfoRequest, rhs: GetSessionInfoRequest) -> Bool {
    if lhs._keyIdentity != rhs._keyIdentity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HMAC_Personalized_Signature_Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HMAC_Personalized_Signature_Data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "epoch"),
    2: .same(proto: "counter"),
    3: .standard(proto: "expires_at"),
    4: .same(proto: "tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.epoch) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.counter) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self.expiresAt) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.tag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.epoch.isEmpty {
      try visitor.visitSingularBytesField(value: self.epoch, fieldNumber: 1)
    }
    if self.counter != 0 {
      try visitor.visitSingularUInt32Field(value: self.counter, fieldNumber: 2)
    }
    if self.expiresAt != 0 {
      try visitor.visitSingularFixed32Field(value: self.expiresAt, fieldNumber: 3)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularBytesField(value: self.tag, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HMAC_Personalized_Signature_Data, rhs: HMAC_Personalized_Signature_Data) -> Bool {
    if lhs.epoch != rhs.epoch {return false}
    if lhs.counter != rhs.counter {return false}
    if lhs.expiresAt != rhs.expiresAt {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HMAC_Signature_Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HMAC_Signature_Data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tag.isEmpty {
      try visitor.visitSingularBytesField(value: self.tag, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HMAC_Signature_Data, rhs: HMAC_Signature_Data) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KeyIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "KeyIdentity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "key_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .publicKey(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .keyID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .publicKey?: try {
      guard case .publicKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .keyID?: try {
      guard case .keyID(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KeyIdentity, rhs: KeyIdentity) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Present_Key_Signature_Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Present_Key_Signature_Data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.authToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.authToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Present_Key_Signature_Data, rhs: Present_Key_Signature_Data) -> Bool {
    if lhs.authToken != rhs.authToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RSA_Signature_Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RSA_Signature_Data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "expires_at"),
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.expiresAt) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.expiresAt != 0 {
      try visitor.visitSingularFixed32Field(value: self.expiresAt, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RSA_Signature_Data, rhs: RSA_Signature_Data) -> Bool {
    if lhs.expiresAt != rhs.expiresAt {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SessionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "counter"),
    2: .same(proto: "publicKey"),
    3: .same(proto: "epoch"),
    4: .standard(proto: "clock_time"),
    5: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.counter) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.epoch) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self.clockTime) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.counter != 0 {
      try visitor.visitSingularUInt32Field(value: self.counter, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 2)
    }
    if !self.epoch.isEmpty {
      try visitor.visitSingularBytesField(value: self.epoch, fieldNumber: 3)
    }
    if self.clockTime != 0 {
      try visitor.visitSingularFixed32Field(value: self.clockTime, fieldNumber: 4)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionInfo, rhs: SessionInfo) -> Bool {
    if lhs.counter != rhs.counter {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.clockTime != rhs.clockTime {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignatureData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SignatureData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signer_identity"),
    2: .standard(proto: "Present_Key_data"),
    5: .standard(proto: "AES_GCM_Personalized_data"),
    6: .standard(proto: "session_info_tag"),
    7: .standard(proto: "RSA_data"),
    8: .standard(proto: "HMAC_Personalized_data"),
    9: .standard(proto: "AES_GCM_Response_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._signerIdentity) }()
      case 2: try {
        var v: Present_Key_Signature_Data?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .presentKeyData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .presentKeyData(v)
        }
      }()
      case 5: try {
        var v: AES_GCM_Personalized_Signature_Data?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .aesGcmPersonalizedData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .aesGcmPersonalizedData(v)
        }
      }()
      case 6: try {
        var v: HMAC_Signature_Data?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .sessionInfoTag(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .sessionInfoTag(v)
        }
      }()
      case 7: try {
        var v: RSA_Signature_Data?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .rsaData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .rsaData(v)
        }
      }()
      case 8: try {
        var v: HMAC_Personalized_Signature_Data?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .hmacPersonalizedData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .hmacPersonalizedData(v)
        }
      }()
      case 9: try {
        var v: AES_GCM_Response_Signature_Data?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .aesGcmResponseData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .aesGcmResponseData(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signerIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.subMessage {
    case .presentKeyData?: try {
      guard case .presentKeyData(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .aesGcmPersonalizedData?: try {
      guard case .aesGcmPersonalizedData(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .sessionInfoTag?: try {
      guard case .sessionInfoTag(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .rsaData?: try {
      guard case .rsaData(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .hmacPersonalizedData?: try {
      guard case .hmacPersonalizedData(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .aesGcmResponseData?: try {
      guard case .aesGcmResponseData(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignatureData, rhs: SignatureData) -> Bool {
    if lhs._signerIdentity != rhs._signerIdentity {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
