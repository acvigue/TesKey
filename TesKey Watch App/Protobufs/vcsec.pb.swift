// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: vcsec.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.
//
// Adapted from https://github.com/teslamotors/vehicle-command

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Activity_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case activityNone // = 0
  case activityStationary // = 1
  case activityMotion // = 2
  case activitySignificantMotion // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .activityNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .activityNone
    case 1: self = .activityStationary
    case 2: self = .activityMotion
    case 3: self = .activitySignificantMotion
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .activityNone: return 0
    case .activityStationary: return 1
    case .activityMotion: return 2
    case .activitySignificantMotion: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Activity_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Activity_E] = [
    .activityNone,
    .activityStationary,
    .activityMotion,
    .activitySignificantMotion,
  ]
}

#endif  // swift(>=4.2)

enum AlertConfirmation: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case peerRemovedInformation // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .peerRemovedInformation
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .peerRemovedInformation: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension AlertConfirmation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AlertConfirmation] = [
    .none,
    .peerRemovedInformation,
  ]
}

#endif  // swift(>=4.2)

enum AppDeviceInfoRequest_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case appDeviceInfoRequestNone // = 0
  case appDeviceInfoRequestGetModelNumber // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .appDeviceInfoRequestNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .appDeviceInfoRequestNone
    case 1: self = .appDeviceInfoRequestGetModelNumber
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .appDeviceInfoRequestNone: return 0
    case .appDeviceInfoRequestGetModelNumber: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension AppDeviceInfoRequest_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AppDeviceInfoRequest_E] = [
    .appDeviceInfoRequestNone,
    .appDeviceInfoRequestGetModelNumber,
  ]
}

#endif  // swift(>=4.2)

enum AppOperatingSystem: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case android // = 1
  case ios // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .android
    case 2: self = .ios
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .android: return 1
    case .ios: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension AppOperatingSystem: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AppOperatingSystem] = [
    .unknown,
    .android,
    .ios,
  ]
}

#endif  // swift(>=4.2)

enum AuthenticationLevel_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case authenticationLevelNone // = 0
  case authenticationLevelUnlock // = 1
  case authenticationLevelDrive // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .authenticationLevelNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .authenticationLevelNone
    case 1: self = .authenticationLevelUnlock
    case 2: self = .authenticationLevelDrive
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .authenticationLevelNone: return 0
    case .authenticationLevelUnlock: return 1
    case .authenticationLevelDrive: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension AuthenticationLevel_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AuthenticationLevel_E] = [
    .authenticationLevelNone,
    .authenticationLevelUnlock,
    .authenticationLevelDrive,
  ]
}

#endif  // swift(>=4.2)

enum AuthenticationReason_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case authenticationreasonNotDocumented // = 0
  case authenticationreasonIdentification // = 1
  case authenticationreasonPowerOnVehicleRequest // = 2
  case authenticationreasonGtwRequest // = 3
  case authenticationreasonUiUnlockPassiveAuth // = 4
  case authenticationreasonPassiveUnlockExteriorHandlePull // = 5
  case authenticationreasonPassiveUnlockInteriorHandlePull // = 6
  case authenticationreasonPassiveUnlockAutopresentDoor // = 7
  case nteredHigherAuthZone // = 8
  case authenticationreasonWalkUpUnlock // = 9
  case authenticationreasonImmobilizer // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .authenticationreasonNotDocumented
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .authenticationreasonNotDocumented
    case 1: self = .authenticationreasonIdentification
    case 2: self = .authenticationreasonPowerOnVehicleRequest
    case 3: self = .authenticationreasonGtwRequest
    case 4: self = .authenticationreasonUiUnlockPassiveAuth
    case 5: self = .authenticationreasonPassiveUnlockExteriorHandlePull
    case 6: self = .authenticationreasonPassiveUnlockInteriorHandlePull
    case 7: self = .authenticationreasonPassiveUnlockAutopresentDoor
    case 8: self = .nteredHigherAuthZone
    case 9: self = .authenticationreasonWalkUpUnlock
    case 10: self = .authenticationreasonImmobilizer
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .authenticationreasonNotDocumented: return 0
    case .authenticationreasonIdentification: return 1
    case .authenticationreasonPowerOnVehicleRequest: return 2
    case .authenticationreasonGtwRequest: return 3
    case .authenticationreasonUiUnlockPassiveAuth: return 4
    case .authenticationreasonPassiveUnlockExteriorHandlePull: return 5
    case .authenticationreasonPassiveUnlockInteriorHandlePull: return 6
    case .authenticationreasonPassiveUnlockAutopresentDoor: return 7
    case .nteredHigherAuthZone: return 8
    case .authenticationreasonWalkUpUnlock: return 9
    case .authenticationreasonImmobilizer: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension AuthenticationReason_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AuthenticationReason_E] = [
    .authenticationreasonNotDocumented,
    .authenticationreasonIdentification,
    .authenticationreasonPowerOnVehicleRequest,
    .authenticationreasonGtwRequest,
    .authenticationreasonUiUnlockPassiveAuth,
    .authenticationreasonPassiveUnlockExteriorHandlePull,
    .authenticationreasonPassiveUnlockInteriorHandlePull,
    .authenticationreasonPassiveUnlockAutopresentDoor,
    .nteredHigherAuthZone,
    .authenticationreasonWalkUpUnlock,
    .authenticationreasonImmobilizer,
  ]
}

#endif  // swift(>=4.2)

enum AuthenticationRejection_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case authenticationrejectionNone // = 0
  case authenticationrejectionDeviceStationary // = 1
  case authenticationrejectionPassiveDisabled // = 2
  case authenticationrejectionNoToken // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .authenticationrejectionNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .authenticationrejectionNone
    case 1: self = .authenticationrejectionDeviceStationary
    case 2: self = .authenticationrejectionPassiveDisabled
    case 3: self = .authenticationrejectionNoToken
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .authenticationrejectionNone: return 0
    case .authenticationrejectionDeviceStationary: return 1
    case .authenticationrejectionPassiveDisabled: return 2
    case .authenticationrejectionNoToken: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension AuthenticationRejection_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AuthenticationRejection_E] = [
    .authenticationrejectionNone,
    .authenticationrejectionDeviceStationary,
    .authenticationrejectionPassiveDisabled,
    .authenticationrejectionNoToken,
  ]
}

#endif  // swift(>=4.2)

enum BLEAdditionalTRIMApplied_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case bleAdditionalTrimAppliedNone // = 0
  case bleAdditionalTrimAppliedApplied // = 1
  case bleAdditionalTrimAppliedNotApplied // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .bleAdditionalTrimAppliedNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bleAdditionalTrimAppliedNone
    case 1: self = .bleAdditionalTrimAppliedApplied
    case 2: self = .bleAdditionalTrimAppliedNotApplied
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .bleAdditionalTrimAppliedNone: return 0
    case .bleAdditionalTrimAppliedApplied: return 1
    case .bleAdditionalTrimAppliedNotApplied: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BLEAdditionalTRIMApplied_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [BLEAdditionalTRIMApplied_E] = [
    .bleAdditionalTrimAppliedNone,
    .bleAdditionalTrimAppliedApplied,
    .bleAdditionalTrimAppliedNotApplied,
  ]
}

#endif  // swift(>=4.2)

enum BLEConfigCommandType_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case bleConfigCommandTypeNone // = 0
  case bleConfigCommandTypeRead // = 1
  case bleConfigCommandTypeWrite // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .bleConfigCommandTypeNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bleConfigCommandTypeNone
    case 1: self = .bleConfigCommandTypeRead
    case 2: self = .bleConfigCommandTypeWrite
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .bleConfigCommandTypeNone: return 0
    case .bleConfigCommandTypeRead: return 1
    case .bleConfigCommandTypeWrite: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BLEConfigCommandType_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [BLEConfigCommandType_E] = [
    .bleConfigCommandTypeNone,
    .bleConfigCommandTypeRead,
    .bleConfigCommandTypeWrite,
  ]
}

#endif  // swift(>=4.2)

enum BLEPresence: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case notPresent // = 0
  case present // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .notPresent
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notPresent
    case 1: self = .present
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .notPresent: return 0
    case .present: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BLEPresence: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [BLEPresence] = [
    .notPresent,
    .present,
  ]
}

#endif  // swift(>=4.2)

enum CertificateStatus_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case certificateStatusNone // = 0
  case ceritficateStatusNotWritten // = 1
  case certificateStatusWritten // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .certificateStatusNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .certificateStatusNone
    case 1: self = .ceritficateStatusNotWritten
    case 2: self = .certificateStatusWritten
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .certificateStatusNone: return 0
    case .ceritficateStatusNotWritten: return 1
    case .certificateStatusWritten: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CertificateStatus_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [CertificateStatus_E] = [
    .certificateStatusNone,
    .ceritficateStatusNotWritten,
    .certificateStatusWritten,
  ]
}

#endif  // swift(>=4.2)

enum ClosureMoveType_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case closureMoveTypeNone // = 0
  case closureMoveTypeMove // = 1
  case closureMoveTypeStop // = 2
  case closureMoveTypeOpen // = 3
  case closureMoveTypeClose // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .closureMoveTypeNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .closureMoveTypeNone
    case 1: self = .closureMoveTypeMove
    case 2: self = .closureMoveTypeStop
    case 3: self = .closureMoveTypeOpen
    case 4: self = .closureMoveTypeClose
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .closureMoveTypeNone: return 0
    case .closureMoveTypeMove: return 1
    case .closureMoveTypeStop: return 2
    case .closureMoveTypeOpen: return 3
    case .closureMoveTypeClose: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ClosureMoveType_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ClosureMoveType_E] = [
    .closureMoveTypeNone,
    .closureMoveTypeMove,
    .closureMoveTypeStop,
    .closureMoveTypeOpen,
    .closureMoveTypeClose,
  ]
}

#endif  // swift(>=4.2)

enum ClosureState_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case closurestateClosed // = 0
  case closurestateOpen // = 1
  case closurestateAjar // = 2
  case closurestateUnknown // = 3
  case closurestateFailedUnlatch // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .closurestateClosed
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .closurestateClosed
    case 1: self = .closurestateOpen
    case 2: self = .closurestateAjar
    case 3: self = .closurestateUnknown
    case 4: self = .closurestateFailedUnlatch
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .closurestateClosed: return 0
    case .closurestateOpen: return 1
    case .closurestateAjar: return 2
    case .closurestateUnknown: return 3
    case .closurestateFailedUnlatch: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ClosureState_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ClosureState_E] = [
    .closurestateClosed,
    .closurestateOpen,
    .closurestateAjar,
    .closurestateUnknown,
    .closurestateFailedUnlatch,
  ]
}

#endif  // swift(>=4.2)

enum Device_Motion_Confidence: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case low // = 1
  case medium // = 2
  case high // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .low
    case 2: self = .medium
    case 3: self = .high
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .low: return 1
    case .medium: return 2
    case .high: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Device_Motion_Confidence: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Device_Motion_Confidence] = [
    .unknown,
    .low,
    .medium,
    .high,
  ]
}

#endif  // swift(>=4.2)

enum Device_Motion_State: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case deviceMotionUnknown // = 0
  case deviceMotionStationary // = 1
  case deviceMotionWalking // = 2
  case deviceMotionRunning // = 3
  case deviceMotionAutomotive // = 4
  case deviceMotionCycling // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .deviceMotionUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .deviceMotionUnknown
    case 1: self = .deviceMotionStationary
    case 2: self = .deviceMotionWalking
    case 3: self = .deviceMotionRunning
    case 4: self = .deviceMotionAutomotive
    case 5: self = .deviceMotionCycling
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .deviceMotionUnknown: return 0
    case .deviceMotionStationary: return 1
    case .deviceMotionWalking: return 2
    case .deviceMotionRunning: return 3
    case .deviceMotionAutomotive: return 4
    case .deviceMotionCycling: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Device_Motion_State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Device_Motion_State] = [
    .deviceMotionUnknown,
    .deviceMotionStationary,
    .deviceMotionWalking,
    .deviceMotionRunning,
    .deviceMotionAutomotive,
    .deviceMotionCycling,
  ]
}

#endif  // swift(>=4.2)

enum GenealogyRequest_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case genealogyrequestNone // = 0
  case genealogyrequestRead // = 1
  case genealogyrequestKeyfobinfoRead // = 2
  case genealogyrequestTpwheelunitinfoRead // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .genealogyrequestNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .genealogyrequestNone
    case 1: self = .genealogyrequestRead
    case 2: self = .genealogyrequestKeyfobinfoRead
    case 3: self = .genealogyrequestTpwheelunitinfoRead
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .genealogyrequestNone: return 0
    case .genealogyrequestRead: return 1
    case .genealogyrequestKeyfobinfoRead: return 2
    case .genealogyrequestTpwheelunitinfoRead: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension GenealogyRequest_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [GenealogyRequest_E] = [
    .genealogyrequestNone,
    .genealogyrequestRead,
    .genealogyrequestKeyfobinfoRead,
    .genealogyrequestTpwheelunitinfoRead,
  ]
}

#endif  // swift(>=4.2)

enum GenealogyStatus_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case genealogyStatusNone // = 0
  case genealogyStatusNotWritten // = 1
  case genealogyStatusWriteSuccess // = 2
  case genealogyStatusWriteFailure // = 3
  case genealogyStatusReadSuccess // = 4
  case genealogyStatusReadFailure // = 5
  case genealogyStatusCrcFailure // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .genealogyStatusNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .genealogyStatusNone
    case 1: self = .genealogyStatusNotWritten
    case 2: self = .genealogyStatusWriteSuccess
    case 3: self = .genealogyStatusWriteFailure
    case 4: self = .genealogyStatusReadSuccess
    case 5: self = .genealogyStatusReadFailure
    case 6: self = .genealogyStatusCrcFailure
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .genealogyStatusNone: return 0
    case .genealogyStatusNotWritten: return 1
    case .genealogyStatusWriteSuccess: return 2
    case .genealogyStatusWriteFailure: return 3
    case .genealogyStatusReadSuccess: return 4
    case .genealogyStatusReadFailure: return 5
    case .genealogyStatusCrcFailure: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension GenealogyStatus_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [GenealogyStatus_E] = [
    .genealogyStatusNone,
    .genealogyStatusNotWritten,
    .genealogyStatusWriteSuccess,
    .genealogyStatusWriteFailure,
    .genealogyStatusReadSuccess,
    .genealogyStatusReadFailure,
    .genealogyStatusCrcFailure,
  ]
}

#endif  // swift(>=4.2)

enum GetReaderKeyCommand: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case startLooking // = 1
  case stopLooking // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .startLooking
    case 2: self = .stopLooking
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .startLooking: return 1
    case .stopLooking: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension GetReaderKeyCommand: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [GetReaderKeyCommand] = [
    .unknown,
    .startLooking,
    .stopLooking,
  ]
}

#endif  // swift(>=4.2)

enum HandlePulled_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case handlePulledFrontDriverDoor // = 0
  case handlePulledFrontPassengerDoor // = 1
  case handlePulledRearDriverDoor // = 2
  case handlePulledRearPassengerDoor // = 3
  case handlePulledTrunk // = 4
  case handlePulledChargePort // = 5
  case handlePulledFrontDriverAutoPresentDoor // = 6
  case handlePulledFrontPassengerAutoPresentDoor // = 7
  case handlePulledOther // = 8
  case handlePulledFrunk // = 9
  case UNRECOGNIZED(Int)

  init() {
    self = .handlePulledFrontDriverDoor
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .handlePulledFrontDriverDoor
    case 1: self = .handlePulledFrontPassengerDoor
    case 2: self = .handlePulledRearDriverDoor
    case 3: self = .handlePulledRearPassengerDoor
    case 4: self = .handlePulledTrunk
    case 5: self = .handlePulledChargePort
    case 6: self = .handlePulledFrontDriverAutoPresentDoor
    case 7: self = .handlePulledFrontPassengerAutoPresentDoor
    case 8: self = .handlePulledOther
    case 9: self = .handlePulledFrunk
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .handlePulledFrontDriverDoor: return 0
    case .handlePulledFrontPassengerDoor: return 1
    case .handlePulledRearDriverDoor: return 2
    case .handlePulledRearPassengerDoor: return 3
    case .handlePulledTrunk: return 4
    case .handlePulledChargePort: return 5
    case .handlePulledFrontDriverAutoPresentDoor: return 6
    case .handlePulledFrontPassengerAutoPresentDoor: return 7
    case .handlePulledOther: return 8
    case .handlePulledFrunk: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension HandlePulled_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [HandlePulled_E] = [
    .handlePulledFrontDriverDoor,
    .handlePulledFrontPassengerDoor,
    .handlePulledRearDriverDoor,
    .handlePulledRearPassengerDoor,
    .handlePulledTrunk,
    .handlePulledChargePort,
    .handlePulledFrontDriverAutoPresentDoor,
    .handlePulledFrontPassengerAutoPresentDoor,
    .handlePulledOther,
    .handlePulledFrunk,
  ]
}

#endif  // swift(>=4.2)

enum IMURequest_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case imuRequestNone // = 0
  case imuRequestGetSleepState // = 1
  case nableContinuousActivityUpdate // = 2
  case imuRequestDisableContinuousActivityUpdate // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .imuRequestNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .imuRequestNone
    case 1: self = .imuRequestGetSleepState
    case 2: self = .nableContinuousActivityUpdate
    case 3: self = .imuRequestDisableContinuousActivityUpdate
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .imuRequestNone: return 0
    case .imuRequestGetSleepState: return 1
    case .nableContinuousActivityUpdate: return 2
    case .imuRequestDisableContinuousActivityUpdate: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension IMURequest_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [IMURequest_E] = [
    .imuRequestNone,
    .imuRequestGetSleepState,
    .nableContinuousActivityUpdate,
    .imuRequestDisableContinuousActivityUpdate,
  ]
}

#endif  // swift(>=4.2)

enum IMUState_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case imuStateNotConfigured // = 0
  case imuStateActivity // = 1
  case imuStateInactivity // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .imuStateNotConfigured
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .imuStateNotConfigured
    case 1: self = .imuStateActivity
    case 2: self = .imuStateInactivity
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .imuStateNotConfigured: return 0
    case .imuStateActivity: return 1
    case .imuStateInactivity: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension IMUState_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [IMUState_E] = [
    .imuStateNotConfigured,
    .imuStateActivity,
    .imuStateInactivity,
  ]
}

#endif  // swift(>=4.2)

enum InformationRequestType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case getStatus // = 0
  case getToken // = 1
  case getCounter // = 2
  case getEphemeralPublicKey // = 3
  case getSessionData // = 4
  case getWhitelistInfo // = 5
  case getWhitelistEntryInfo // = 6
  case getVehicleInfo // = 7
  case getKeystatusInfo // = 8
  case getActiveKey // = 9
  case getCapabilities // = 16
  case UNRECOGNIZED(Int)

  init() {
    self = .getStatus
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .getStatus
    case 1: self = .getToken
    case 2: self = .getCounter
    case 3: self = .getEphemeralPublicKey
    case 4: self = .getSessionData
    case 5: self = .getWhitelistInfo
    case 6: self = .getWhitelistEntryInfo
    case 7: self = .getVehicleInfo
    case 8: self = .getKeystatusInfo
    case 9: self = .getActiveKey
    case 16: self = .getCapabilities
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .getStatus: return 0
    case .getToken: return 1
    case .getCounter: return 2
    case .getEphemeralPublicKey: return 3
    case .getSessionData: return 4
    case .getWhitelistInfo: return 5
    case .getWhitelistEntryInfo: return 6
    case .getVehicleInfo: return 7
    case .getKeystatusInfo: return 8
    case .getActiveKey: return 9
    case .getCapabilities: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension InformationRequestType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [InformationRequestType] = [
    .getStatus,
    .getToken,
    .getCounter,
    .getEphemeralPublicKey,
    .getSessionData,
    .getWhitelistInfo,
    .getWhitelistEntryInfo,
    .getVehicleInfo,
    .getKeystatusInfo,
    .getActiveKey,
    .getCapabilities,
  ]
}

#endif  // swift(>=4.2)

enum KeyFormFactor: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case nfcCard // = 1
  case keyFormFactor3ButtonBleCarKeyfob // = 2
  case bleDevice // = 3
  case nfcDevice // = 4
  case bleAndNfcDevice // = 5
  case iosDevice // = 6
  case androidDevice // = 7
  case keyFormFactor3ButtonBleCarKeyfobP60 // = 8
  case cloudKey // = 9
  case keyFormFactor3ButtonGen2CarKeyfobP60 // = 10
  case keyFormFactor5ButtonGen2CarKeyfobP60 // = 11
  case keyFormFactor3ButtonGen2CarKeyfobP60V2 // = 12
  case keyFormFactor3ButtonGen2CarKeyfobP60V3 // = 13
  case nfcCardP71 // = 14
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .nfcCard
    case 2: self = .keyFormFactor3ButtonBleCarKeyfob
    case 3: self = .bleDevice
    case 4: self = .nfcDevice
    case 5: self = .bleAndNfcDevice
    case 6: self = .iosDevice
    case 7: self = .androidDevice
    case 8: self = .keyFormFactor3ButtonBleCarKeyfobP60
    case 9: self = .cloudKey
    case 10: self = .keyFormFactor3ButtonGen2CarKeyfobP60
    case 11: self = .keyFormFactor5ButtonGen2CarKeyfobP60
    case 12: self = .keyFormFactor3ButtonGen2CarKeyfobP60V2
    case 13: self = .keyFormFactor3ButtonGen2CarKeyfobP60V3
    case 14: self = .nfcCardP71
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .nfcCard: return 1
    case .keyFormFactor3ButtonBleCarKeyfob: return 2
    case .bleDevice: return 3
    case .nfcDevice: return 4
    case .bleAndNfcDevice: return 5
    case .iosDevice: return 6
    case .androidDevice: return 7
    case .keyFormFactor3ButtonBleCarKeyfobP60: return 8
    case .cloudKey: return 9
    case .keyFormFactor3ButtonGen2CarKeyfobP60: return 10
    case .keyFormFactor5ButtonGen2CarKeyfobP60: return 11
    case .keyFormFactor3ButtonGen2CarKeyfobP60V2: return 12
    case .keyFormFactor3ButtonGen2CarKeyfobP60V3: return 13
    case .nfcCardP71: return 14
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension KeyFormFactor: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [KeyFormFactor] = [
    .unknown,
    .nfcCard,
    .keyFormFactor3ButtonBleCarKeyfob,
    .bleDevice,
    .nfcDevice,
    .bleAndNfcDevice,
    .iosDevice,
    .androidDevice,
    .keyFormFactor3ButtonBleCarKeyfobP60,
    .cloudKey,
    .keyFormFactor3ButtonGen2CarKeyfobP60,
    .keyFormFactor5ButtonGen2CarKeyfobP60,
    .keyFormFactor3ButtonGen2CarKeyfobP60V2,
    .keyFormFactor3ButtonGen2CarKeyfobP60V3,
    .nfcCardP71,
  ]
}

#endif  // swift(>=4.2)

enum LRDetectionResult_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case rrorMaxcnt // = 0
  case rrorNegperiod // = 1
  case rrorLongperiod // = 2
  case lrdetectionresultLeft // = 3
  case lrdetectionresultRight // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .rrorMaxcnt
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rrorMaxcnt
    case 1: self = .rrorNegperiod
    case 2: self = .rrorLongperiod
    case 3: self = .lrdetectionresultLeft
    case 4: self = .lrdetectionresultRight
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .rrorMaxcnt: return 0
    case .rrorNegperiod: return 1
    case .rrorLongperiod: return 2
    case .lrdetectionresultLeft: return 3
    case .lrdetectionresultRight: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension LRDetectionResult_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [LRDetectionResult_E] = [
    .rrorMaxcnt,
    .rrorNegperiod,
    .rrorLongperiod,
    .lrdetectionresultLeft,
    .lrdetectionresultRight,
  ]
}

#endif  // swift(>=4.2)

enum MIError_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case errorUnknown // = 0
  case errorSessionLimitExceeded // = 1
  case errorInvalidConfiguration // = 2
  case errorResourceUsageTimeout // = 3
  case errorSessionFailed // = 4
  case errorUnsupportedPlatform // = 5
  case errorUserDidNotAllow // = 6
  case errorBlePeerUnavailable // = 7
  case errorVehicleNotSelectedForRanging // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .errorUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .errorUnknown
    case 1: self = .errorSessionLimitExceeded
    case 2: self = .errorInvalidConfiguration
    case 3: self = .errorResourceUsageTimeout
    case 4: self = .errorSessionFailed
    case 5: self = .errorUnsupportedPlatform
    case 6: self = .errorUserDidNotAllow
    case 7: self = .errorBlePeerUnavailable
    case 8: self = .errorVehicleNotSelectedForRanging
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .errorUnknown: return 0
    case .errorSessionLimitExceeded: return 1
    case .errorInvalidConfiguration: return 2
    case .errorResourceUsageTimeout: return 3
    case .errorSessionFailed: return 4
    case .errorUnsupportedPlatform: return 5
    case .errorUserDidNotAllow: return 6
    case .errorBlePeerUnavailable: return 7
    case .errorVehicleNotSelectedForRanging: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MIError_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [MIError_E] = [
    .errorUnknown,
    .errorSessionLimitExceeded,
    .errorInvalidConfiguration,
    .errorResourceUsageTimeout,
    .errorSessionFailed,
    .errorUnsupportedPlatform,
    .errorUserDidNotAllow,
    .errorBlePeerUnavailable,
    .errorVehicleNotSelectedForRanging,
  ]
}

#endif  // swift(>=4.2)

enum MLXWakePeriod_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case mlxwakeperiod2Ms // = 0
  case mlxwakeperiod3Ms // = 1
  case mlxwakeperiod5Ms // = 2
  case mlxwakeperiod15Ms // = 3
  case mlxwakeperiod30Ms // = 4
  case mlxwakeperiod50Ms // = 5
  case mlxwakeperiod100Ms // = 6
  case mlxwakeperiod150Ms // = 7
  case mlxwakeperiod250Ms // = 8
  case mlxwakeperiod500Ms // = 9
  case mlxwakeperiod1S // = 10
  case mlxwakeperiod2S // = 11
  case mlxwakeperiod25S // = 12
  case mlxwakeperiod3S // = 13
  case mlxwakeperiod4S // = 14
  case mlxwakeperiod5S // = 15
  case mlxwakeperiod6S // = 16
  case mlxwakeperiod7S // = 17
  case mlxwakeperiod8S // = 18
  case mlxwakeperiod9S // = 19
  case mlxwakeperiod10S // = 20
  case mlxwakeperiod11S // = 21
  case mlxwakeperiod12S // = 22
  case mlxwakeperiod15S // = 23
  case mlxwakeperiod20S // = 24
  case mlxwakeperiod30S // = 25
  case mlxwakeperiod1M // = 26
  case mlxwakeperiod2M // = 27
  case mlxwakeperiod3M // = 28
  case mlxwakeperiod4M // = 29
  case mlxwakeperiod5M // = 30
  case mlxwakeperiod10M // = 31
  case mlxwakeperiod16M // = 32
  case mlxwakeperiodNotSet // = 33
  case UNRECOGNIZED(Int)

  init() {
    self = .mlxwakeperiod2Ms
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mlxwakeperiod2Ms
    case 1: self = .mlxwakeperiod3Ms
    case 2: self = .mlxwakeperiod5Ms
    case 3: self = .mlxwakeperiod15Ms
    case 4: self = .mlxwakeperiod30Ms
    case 5: self = .mlxwakeperiod50Ms
    case 6: self = .mlxwakeperiod100Ms
    case 7: self = .mlxwakeperiod150Ms
    case 8: self = .mlxwakeperiod250Ms
    case 9: self = .mlxwakeperiod500Ms
    case 10: self = .mlxwakeperiod1S
    case 11: self = .mlxwakeperiod2S
    case 12: self = .mlxwakeperiod25S
    case 13: self = .mlxwakeperiod3S
    case 14: self = .mlxwakeperiod4S
    case 15: self = .mlxwakeperiod5S
    case 16: self = .mlxwakeperiod6S
    case 17: self = .mlxwakeperiod7S
    case 18: self = .mlxwakeperiod8S
    case 19: self = .mlxwakeperiod9S
    case 20: self = .mlxwakeperiod10S
    case 21: self = .mlxwakeperiod11S
    case 22: self = .mlxwakeperiod12S
    case 23: self = .mlxwakeperiod15S
    case 24: self = .mlxwakeperiod20S
    case 25: self = .mlxwakeperiod30S
    case 26: self = .mlxwakeperiod1M
    case 27: self = .mlxwakeperiod2M
    case 28: self = .mlxwakeperiod3M
    case 29: self = .mlxwakeperiod4M
    case 30: self = .mlxwakeperiod5M
    case 31: self = .mlxwakeperiod10M
    case 32: self = .mlxwakeperiod16M
    case 33: self = .mlxwakeperiodNotSet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .mlxwakeperiod2Ms: return 0
    case .mlxwakeperiod3Ms: return 1
    case .mlxwakeperiod5Ms: return 2
    case .mlxwakeperiod15Ms: return 3
    case .mlxwakeperiod30Ms: return 4
    case .mlxwakeperiod50Ms: return 5
    case .mlxwakeperiod100Ms: return 6
    case .mlxwakeperiod150Ms: return 7
    case .mlxwakeperiod250Ms: return 8
    case .mlxwakeperiod500Ms: return 9
    case .mlxwakeperiod1S: return 10
    case .mlxwakeperiod2S: return 11
    case .mlxwakeperiod25S: return 12
    case .mlxwakeperiod3S: return 13
    case .mlxwakeperiod4S: return 14
    case .mlxwakeperiod5S: return 15
    case .mlxwakeperiod6S: return 16
    case .mlxwakeperiod7S: return 17
    case .mlxwakeperiod8S: return 18
    case .mlxwakeperiod9S: return 19
    case .mlxwakeperiod10S: return 20
    case .mlxwakeperiod11S: return 21
    case .mlxwakeperiod12S: return 22
    case .mlxwakeperiod15S: return 23
    case .mlxwakeperiod20S: return 24
    case .mlxwakeperiod30S: return 25
    case .mlxwakeperiod1M: return 26
    case .mlxwakeperiod2M: return 27
    case .mlxwakeperiod3M: return 28
    case .mlxwakeperiod4M: return 29
    case .mlxwakeperiod5M: return 30
    case .mlxwakeperiod10M: return 31
    case .mlxwakeperiod16M: return 32
    case .mlxwakeperiodNotSet: return 33
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MLXWakePeriod_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [MLXWakePeriod_E] = [
    .mlxwakeperiod2Ms,
    .mlxwakeperiod3Ms,
    .mlxwakeperiod5Ms,
    .mlxwakeperiod15Ms,
    .mlxwakeperiod30Ms,
    .mlxwakeperiod50Ms,
    .mlxwakeperiod100Ms,
    .mlxwakeperiod150Ms,
    .mlxwakeperiod250Ms,
    .mlxwakeperiod500Ms,
    .mlxwakeperiod1S,
    .mlxwakeperiod2S,
    .mlxwakeperiod25S,
    .mlxwakeperiod3S,
    .mlxwakeperiod4S,
    .mlxwakeperiod5S,
    .mlxwakeperiod6S,
    .mlxwakeperiod7S,
    .mlxwakeperiod8S,
    .mlxwakeperiod9S,
    .mlxwakeperiod10S,
    .mlxwakeperiod11S,
    .mlxwakeperiod12S,
    .mlxwakeperiod15S,
    .mlxwakeperiod20S,
    .mlxwakeperiod30S,
    .mlxwakeperiod1M,
    .mlxwakeperiod2M,
    .mlxwakeperiod3M,
    .mlxwakeperiod4M,
    .mlxwakeperiod5M,
    .mlxwakeperiod10M,
    .mlxwakeperiod16M,
    .mlxwakeperiodNotSet,
  ]
}

#endif  // swift(>=4.2)

enum NFCPresence: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case notPresent // = 0
  case presentAtBPillar // = 1
  case presentAtCenterConsole // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .notPresent
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notPresent
    case 1: self = .presentAtBPillar
    case 2: self = .presentAtCenterConsole
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .notPresent: return 0
    case .presentAtBPillar: return 1
    case .presentAtCenterConsole: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension NFCPresence: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [NFCPresence] = [
    .notPresent,
    .presentAtBPillar,
    .presentAtCenterConsole,
  ]
}

#endif  // swift(>=4.2)

enum NFCSEDevicePubKeyState_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nfcsecDevicepubkeyStateNone // = 0
  case nfcsecDevicepubkeyStateRetrieved // = 1
  case nfcsecDevicepubkeyStateNotRetrieved // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .nfcsecDevicepubkeyStateNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nfcsecDevicepubkeyStateNone
    case 1: self = .nfcsecDevicepubkeyStateRetrieved
    case 2: self = .nfcsecDevicepubkeyStateNotRetrieved
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nfcsecDevicepubkeyStateNone: return 0
    case .nfcsecDevicepubkeyStateRetrieved: return 1
    case .nfcsecDevicepubkeyStateNotRetrieved: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension NFCSEDevicePubKeyState_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [NFCSEDevicePubKeyState_E] = [
    .nfcsecDevicepubkeyStateNone,
    .nfcsecDevicepubkeyStateRetrieved,
    .nfcsecDevicepubkeyStateNotRetrieved,
  ]
}

#endif  // swift(>=4.2)

enum NFCSEInsecureCommandState_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nfcsecInsecureCommandStateNone // = 0
  case nfcsecInsecureCommandStateEnabled // = 1
  case nfcsecInsecureCommandStateDisabled // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .nfcsecInsecureCommandStateNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nfcsecInsecureCommandStateNone
    case 1: self = .nfcsecInsecureCommandStateEnabled
    case 2: self = .nfcsecInsecureCommandStateDisabled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nfcsecInsecureCommandStateNone: return 0
    case .nfcsecInsecureCommandStateEnabled: return 1
    case .nfcsecInsecureCommandStateDisabled: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension NFCSEInsecureCommandState_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [NFCSEInsecureCommandState_E] = [
    .nfcsecInsecureCommandStateNone,
    .nfcsecInsecureCommandStateEnabled,
    .nfcsecInsecureCommandStateDisabled,
  ]
}

#endif  // swift(>=4.2)

enum NFCSERequest_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nfcseRequestNone // = 0
  case nfcseRequestRefetchSessionInfo // = 1
  case nfcseRequestDisableInsecureCommands // = 2
  case nfcseRequestGetCurrentState // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .nfcseRequestNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nfcseRequestNone
    case 1: self = .nfcseRequestRefetchSessionInfo
    case 2: self = .nfcseRequestDisableInsecureCommands
    case 3: self = .nfcseRequestGetCurrentState
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nfcseRequestNone: return 0
    case .nfcseRequestRefetchSessionInfo: return 1
    case .nfcseRequestDisableInsecureCommands: return 2
    case .nfcseRequestGetCurrentState: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension NFCSERequest_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [NFCSERequest_E] = [
    .nfcseRequestNone,
    .nfcseRequestRefetchSessionInfo,
    .nfcseRequestDisableInsecureCommands,
    .nfcseRequestGetCurrentState,
  ]
}

#endif  // swift(>=4.2)

enum NFCSESharedSecretState_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nfcsecSharedsecretStateNone // = 0
  case nfcsecSharedsecretStateGenerated // = 1
  case nfcsecSharedsecretStateNotGenerated // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .nfcsecSharedsecretStateNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nfcsecSharedsecretStateNone
    case 1: self = .nfcsecSharedsecretStateGenerated
    case 2: self = .nfcsecSharedsecretStateNotGenerated
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nfcsecSharedsecretStateNone: return 0
    case .nfcsecSharedsecretStateGenerated: return 1
    case .nfcsecSharedsecretStateNotGenerated: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension NFCSESharedSecretState_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [NFCSESharedSecretState_E] = [
    .nfcsecSharedsecretStateNone,
    .nfcsecSharedsecretStateGenerated,
    .nfcsecSharedsecretStateNotGenerated,
  ]
}

#endif  // swift(>=4.2)

enum NFCSEVehiclePubKeyState_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case nfcsecVehiclepubkeyStateNone // = 0
  case nfcsecVehiclepubkeyStateRetrieved // = 1
  case nfcsecVehiclepubkeyStateNotRetrieved // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .nfcsecVehiclepubkeyStateNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .nfcsecVehiclepubkeyStateNone
    case 1: self = .nfcsecVehiclepubkeyStateRetrieved
    case 2: self = .nfcsecVehiclepubkeyStateNotRetrieved
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .nfcsecVehiclepubkeyStateNone: return 0
    case .nfcsecVehiclepubkeyStateRetrieved: return 1
    case .nfcsecVehiclepubkeyStateNotRetrieved: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension NFCSEVehiclePubKeyState_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [NFCSEVehiclePubKeyState_E] = [
    .nfcsecVehiclepubkeyStateNone,
    .nfcsecVehiclepubkeyStateRetrieved,
    .nfcsecVehiclepubkeyStateNotRetrieved,
  ]
}

#endif  // swift(>=4.2)

enum PublicKeyRequest_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case publicKeyRequestNone // = 0
  case publicKeyRequestRead // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .publicKeyRequestNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .publicKeyRequestNone
    case 1: self = .publicKeyRequestRead
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .publicKeyRequestNone: return 0
    case .publicKeyRequestRead: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PublicKeyRequest_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PublicKeyRequest_E] = [
    .publicKeyRequestNone,
    .publicKeyRequestRead,
  ]
}

#endif  // swift(>=4.2)

enum PublicKeyStatus_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case publicKeyStatusNone // = 0
  case publicKeyStatusNotWritten // = 1
  case publicKeyStatusWritten // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .publicKeyStatusNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .publicKeyStatusNone
    case 1: self = .publicKeyStatusNotWritten
    case 2: self = .publicKeyStatusWritten
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .publicKeyStatusNone: return 0
    case .publicKeyStatusNotWritten: return 1
    case .publicKeyStatusWritten: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PublicKeyStatus_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PublicKeyStatus_E] = [
    .publicKeyStatusNone,
    .publicKeyStatusNotWritten,
    .publicKeyStatusWritten,
  ]
}

#endif  // swift(>=4.2)

enum RCI_control_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case rciControlNone // = 0
  case rciControlTurnOff // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .rciControlNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rciControlNone
    case 1: self = .rciControlTurnOff
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .rciControlNone: return 0
    case .rciControlTurnOff: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension RCI_control_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RCI_control_E] = [
    .rciControlNone,
    .rciControlTurnOff,
  ]
}

#endif  // swift(>=4.2)

enum ResetTrackerCommand_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case resettrackerCommandNone // = 0
  case resettrackerCommandGetStats // = 1
  case resettrackerCommandClearStats // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .resettrackerCommandNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .resettrackerCommandNone
    case 1: self = .resettrackerCommandGetStats
    case 2: self = .resettrackerCommandClearStats
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .resettrackerCommandNone: return 0
    case .resettrackerCommandGetStats: return 1
    case .resettrackerCommandClearStats: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ResetTrackerCommand_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ResetTrackerCommand_E] = [
    .resettrackerCommandNone,
    .resettrackerCommandGetStats,
    .resettrackerCommandClearStats,
  ]
}

#endif  // swift(>=4.2)

enum RKEAction_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case rkeActionUnlock // = 0
  case rkeActionLock // = 1
  case rkeActionOpenTrunk // = 2
  case rkeActionOpenFrunk // = 3
  case rkeActionOpenChargePort // = 4
  case rkeActionCloseChargePort // = 5
  case rkeActionCancelExternalAuthenticate // = 6
  case rkeActionSinglePressTop // = 7
  case rkeActionDoublePressTop // = 8
  case rkeActionTriplePressTop // = 9
  case rkeActionHoldTop // = 10
  case rkeActionSinglePressBack // = 11
  case rkeActionDoublePressBack // = 12
  case rkeActionTriplePressBack // = 13
  case rkeActionHoldBack // = 14
  case rkeActionSinglePressFront // = 15
  case rkeActionDoublePressFront // = 16
  case rkeActionTriplePressFront // = 17
  case rkeActionHoldFront // = 18
  case rkeActionUnknown // = 19
  case rkeActionRemoteDrive // = 20
  case rkeActionSinglePressLeft // = 21
  case rkeActionDoublePressLeft // = 22
  case rkeActionTriplePressLeft // = 23
  case rkeActionHoldLeft // = 24
  case rkeActionSinglePressRight // = 25
  case rkeActionDoublePressRight // = 26
  case rkeActionTriplePressRight // = 27
  case rkeActionHoldRight // = 28
  case rkeActionAutoSecureVehicle // = 29
  case rkeActionWakeVehicle // = 30
  case UNRECOGNIZED(Int)

  init() {
    self = .rkeActionUnlock
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rkeActionUnlock
    case 1: self = .rkeActionLock
    case 2: self = .rkeActionOpenTrunk
    case 3: self = .rkeActionOpenFrunk
    case 4: self = .rkeActionOpenChargePort
    case 5: self = .rkeActionCloseChargePort
    case 6: self = .rkeActionCancelExternalAuthenticate
    case 7: self = .rkeActionSinglePressTop
    case 8: self = .rkeActionDoublePressTop
    case 9: self = .rkeActionTriplePressTop
    case 10: self = .rkeActionHoldTop
    case 11: self = .rkeActionSinglePressBack
    case 12: self = .rkeActionDoublePressBack
    case 13: self = .rkeActionTriplePressBack
    case 14: self = .rkeActionHoldBack
    case 15: self = .rkeActionSinglePressFront
    case 16: self = .rkeActionDoublePressFront
    case 17: self = .rkeActionTriplePressFront
    case 18: self = .rkeActionHoldFront
    case 19: self = .rkeActionUnknown
    case 20: self = .rkeActionRemoteDrive
    case 21: self = .rkeActionSinglePressLeft
    case 22: self = .rkeActionDoublePressLeft
    case 23: self = .rkeActionTriplePressLeft
    case 24: self = .rkeActionHoldLeft
    case 25: self = .rkeActionSinglePressRight
    case 26: self = .rkeActionDoublePressRight
    case 27: self = .rkeActionTriplePressRight
    case 28: self = .rkeActionHoldRight
    case 29: self = .rkeActionAutoSecureVehicle
    case 30: self = .rkeActionWakeVehicle
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .rkeActionUnlock: return 0
    case .rkeActionLock: return 1
    case .rkeActionOpenTrunk: return 2
    case .rkeActionOpenFrunk: return 3
    case .rkeActionOpenChargePort: return 4
    case .rkeActionCloseChargePort: return 5
    case .rkeActionCancelExternalAuthenticate: return 6
    case .rkeActionSinglePressTop: return 7
    case .rkeActionDoublePressTop: return 8
    case .rkeActionTriplePressTop: return 9
    case .rkeActionHoldTop: return 10
    case .rkeActionSinglePressBack: return 11
    case .rkeActionDoublePressBack: return 12
    case .rkeActionTriplePressBack: return 13
    case .rkeActionHoldBack: return 14
    case .rkeActionSinglePressFront: return 15
    case .rkeActionDoublePressFront: return 16
    case .rkeActionTriplePressFront: return 17
    case .rkeActionHoldFront: return 18
    case .rkeActionUnknown: return 19
    case .rkeActionRemoteDrive: return 20
    case .rkeActionSinglePressLeft: return 21
    case .rkeActionDoublePressLeft: return 22
    case .rkeActionTriplePressLeft: return 23
    case .rkeActionHoldLeft: return 24
    case .rkeActionSinglePressRight: return 25
    case .rkeActionDoublePressRight: return 26
    case .rkeActionTriplePressRight: return 27
    case .rkeActionHoldRight: return 28
    case .rkeActionAutoSecureVehicle: return 29
    case .rkeActionWakeVehicle: return 30
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension RKEAction_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [RKEAction_E] = [
    .rkeActionUnlock,
    .rkeActionLock,
    .rkeActionOpenTrunk,
    .rkeActionOpenFrunk,
    .rkeActionOpenChargePort,
    .rkeActionCloseChargePort,
    .rkeActionCancelExternalAuthenticate,
    .rkeActionSinglePressTop,
    .rkeActionDoublePressTop,
    .rkeActionTriplePressTop,
    .rkeActionHoldTop,
    .rkeActionSinglePressBack,
    .rkeActionDoublePressBack,
    .rkeActionTriplePressBack,
    .rkeActionHoldBack,
    .rkeActionSinglePressFront,
    .rkeActionDoublePressFront,
    .rkeActionTriplePressFront,
    .rkeActionHoldFront,
    .rkeActionUnknown,
    .rkeActionRemoteDrive,
    .rkeActionSinglePressLeft,
    .rkeActionDoublePressLeft,
    .rkeActionTriplePressLeft,
    .rkeActionHoldLeft,
    .rkeActionSinglePressRight,
    .rkeActionDoublePressRight,
    .rkeActionTriplePressRight,
    .rkeActionHoldRight,
    .rkeActionAutoSecureVehicle,
    .rkeActionWakeVehicle,
  ]
}

#endif  // swift(>=4.2)

enum SignatureType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case aesGcm // = 0
  case ecdsa // = 1
  case presentKey // = 2
  case aesGcmToken // = 3
  case unsigned // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .aesGcm
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .aesGcm
    case 1: self = .ecdsa
    case 2: self = .presentKey
    case 3: self = .aesGcmToken
    case 4: self = .unsigned
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .aesGcm: return 0
    case .ecdsa: return 1
    case .presentKey: return 2
    case .aesGcmToken: return 3
    case .unsigned: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SignatureType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SignatureType] = [
    .aesGcm,
    .ecdsa,
    .presentKey,
    .aesGcmToken,
    .unsigned,
  ]
}

#endif  // swift(>=4.2)

enum SignedMessage_information_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case signedmessageInformationNone // = 0
  case signedmessageInformationFaultUnknown // = 1
  case signedmessageInformationFaultNotOnWhitelist // = 2
  case signedmessageInformationFaultIvSmallerThanExpected // = 3
  case signedmessageInformationFaultInvalidToken // = 4
  case signedmessageInformationFaultTokenAndCounterInvalid // = 5
  case signedmessageInformationFaultAesDecryptAuth // = 6
  case signedmessageInformationFaultEcdsaInput // = 7
  case signedmessageInformationFaultEcdsaSignature // = 8
  case signedmessageInformationFaultLocalEntityStart // = 9
  case signedmessageInformationFaultLocalEntityResult // = 10
  case signedmessageInformationFaultCouldNotRetrieveKey // = 11
  case signedmessageInformationFaultCouldNotRetrieveToken // = 12
  case signedmessageInformationFaultSignatureTooShort // = 13
  case signedmessageInformationFaultTokenIsIncorrectLength // = 14
  case signedmessageInformationFaultIncorrectEpoch // = 15
  case signedmessageInformationFaultIvIncorrectLength // = 16
  case signedmessageInformationFaultTimeExpired // = 17
  case signedmessageInformationFaultNotProvisionedWithIdentity // = 18
  case signedmessageInformationFaultCouldNotHashMetadata // = 19
  case UNRECOGNIZED(Int)

  init() {
    self = .signedmessageInformationNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .signedmessageInformationNone
    case 1: self = .signedmessageInformationFaultUnknown
    case 2: self = .signedmessageInformationFaultNotOnWhitelist
    case 3: self = .signedmessageInformationFaultIvSmallerThanExpected
    case 4: self = .signedmessageInformationFaultInvalidToken
    case 5: self = .signedmessageInformationFaultTokenAndCounterInvalid
    case 6: self = .signedmessageInformationFaultAesDecryptAuth
    case 7: self = .signedmessageInformationFaultEcdsaInput
    case 8: self = .signedmessageInformationFaultEcdsaSignature
    case 9: self = .signedmessageInformationFaultLocalEntityStart
    case 10: self = .signedmessageInformationFaultLocalEntityResult
    case 11: self = .signedmessageInformationFaultCouldNotRetrieveKey
    case 12: self = .signedmessageInformationFaultCouldNotRetrieveToken
    case 13: self = .signedmessageInformationFaultSignatureTooShort
    case 14: self = .signedmessageInformationFaultTokenIsIncorrectLength
    case 15: self = .signedmessageInformationFaultIncorrectEpoch
    case 16: self = .signedmessageInformationFaultIvIncorrectLength
    case 17: self = .signedmessageInformationFaultTimeExpired
    case 18: self = .signedmessageInformationFaultNotProvisionedWithIdentity
    case 19: self = .signedmessageInformationFaultCouldNotHashMetadata
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .signedmessageInformationNone: return 0
    case .signedmessageInformationFaultUnknown: return 1
    case .signedmessageInformationFaultNotOnWhitelist: return 2
    case .signedmessageInformationFaultIvSmallerThanExpected: return 3
    case .signedmessageInformationFaultInvalidToken: return 4
    case .signedmessageInformationFaultTokenAndCounterInvalid: return 5
    case .signedmessageInformationFaultAesDecryptAuth: return 6
    case .signedmessageInformationFaultEcdsaInput: return 7
    case .signedmessageInformationFaultEcdsaSignature: return 8
    case .signedmessageInformationFaultLocalEntityStart: return 9
    case .signedmessageInformationFaultLocalEntityResult: return 10
    case .signedmessageInformationFaultCouldNotRetrieveKey: return 11
    case .signedmessageInformationFaultCouldNotRetrieveToken: return 12
    case .signedmessageInformationFaultSignatureTooShort: return 13
    case .signedmessageInformationFaultTokenIsIncorrectLength: return 14
    case .signedmessageInformationFaultIncorrectEpoch: return 15
    case .signedmessageInformationFaultIvIncorrectLength: return 16
    case .signedmessageInformationFaultTimeExpired: return 17
    case .signedmessageInformationFaultNotProvisionedWithIdentity: return 18
    case .signedmessageInformationFaultCouldNotHashMetadata: return 19
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SignedMessage_information_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SignedMessage_information_E] = [
    .signedmessageInformationNone,
    .signedmessageInformationFaultUnknown,
    .signedmessageInformationFaultNotOnWhitelist,
    .signedmessageInformationFaultIvSmallerThanExpected,
    .signedmessageInformationFaultInvalidToken,
    .signedmessageInformationFaultTokenAndCounterInvalid,
    .signedmessageInformationFaultAesDecryptAuth,
    .signedmessageInformationFaultEcdsaInput,
    .signedmessageInformationFaultEcdsaSignature,
    .signedmessageInformationFaultLocalEntityStart,
    .signedmessageInformationFaultLocalEntityResult,
    .signedmessageInformationFaultCouldNotRetrieveKey,
    .signedmessageInformationFaultCouldNotRetrieveToken,
    .signedmessageInformationFaultSignatureTooShort,
    .signedmessageInformationFaultTokenIsIncorrectLength,
    .signedmessageInformationFaultIncorrectEpoch,
    .signedmessageInformationFaultIvIncorrectLength,
    .signedmessageInformationFaultTimeExpired,
    .signedmessageInformationFaultNotProvisionedWithIdentity,
    .signedmessageInformationFaultCouldNotHashMetadata,
  ]
}

#endif  // swift(>=4.2)

enum SleepManagerCommand_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case sleepmanagerCommandNone // = 0
  case sleepmanagerGetStats // = 1
  case sleepmanagerResetStats // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .sleepmanagerCommandNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sleepmanagerCommandNone
    case 1: self = .sleepmanagerGetStats
    case 2: self = .sleepmanagerResetStats
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .sleepmanagerCommandNone: return 0
    case .sleepmanagerGetStats: return 1
    case .sleepmanagerResetStats: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension SleepManagerCommand_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SleepManagerCommand_E] = [
    .sleepmanagerCommandNone,
    .sleepmanagerGetStats,
    .sleepmanagerResetStats,
  ]
}

#endif  // swift(>=4.2)

enum TPDataRequest_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case tpDatarequestNone // = 0
  case tpDatarequestPressureTemperature // = 1
  case tpDatarequestNewSensorInfo // = 2
  case tpDatarequestWheelRotationDirection // = 3
  case tpDatarequestAccel // = 4
  case tpDatarequestMotionDetectionStart // = 5
  case tpDatarequestReadAlarms // = 6
  case tpDatarequestMotionDetectionStop // = 7
  case tpDatarequestReadPublicKey // = 8
  case tpDatarequestRfMonitorCounters // = 9
  case tpDatarequestMotionConfig // = 10
  case tpDatarequestStationaryConfig // = 11
  case tpDatarequestCapabilities // = 12
  case UNRECOGNIZED(Int)

  init() {
    self = .tpDatarequestNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tpDatarequestNone
    case 1: self = .tpDatarequestPressureTemperature
    case 2: self = .tpDatarequestNewSensorInfo
    case 3: self = .tpDatarequestWheelRotationDirection
    case 4: self = .tpDatarequestAccel
    case 5: self = .tpDatarequestMotionDetectionStart
    case 6: self = .tpDatarequestReadAlarms
    case 7: self = .tpDatarequestMotionDetectionStop
    case 8: self = .tpDatarequestReadPublicKey
    case 9: self = .tpDatarequestRfMonitorCounters
    case 10: self = .tpDatarequestMotionConfig
    case 11: self = .tpDatarequestStationaryConfig
    case 12: self = .tpDatarequestCapabilities
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .tpDatarequestNone: return 0
    case .tpDatarequestPressureTemperature: return 1
    case .tpDatarequestNewSensorInfo: return 2
    case .tpDatarequestWheelRotationDirection: return 3
    case .tpDatarequestAccel: return 4
    case .tpDatarequestMotionDetectionStart: return 5
    case .tpDatarequestReadAlarms: return 6
    case .tpDatarequestMotionDetectionStop: return 7
    case .tpDatarequestReadPublicKey: return 8
    case .tpDatarequestRfMonitorCounters: return 9
    case .tpDatarequestMotionConfig: return 10
    case .tpDatarequestStationaryConfig: return 11
    case .tpDatarequestCapabilities: return 12
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TPDataRequest_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [TPDataRequest_E] = [
    .tpDatarequestNone,
    .tpDatarequestPressureTemperature,
    .tpDatarequestNewSensorInfo,
    .tpDatarequestWheelRotationDirection,
    .tpDatarequestAccel,
    .tpDatarequestMotionDetectionStart,
    .tpDatarequestReadAlarms,
    .tpDatarequestMotionDetectionStop,
    .tpDatarequestReadPublicKey,
    .tpDatarequestRfMonitorCounters,
    .tpDatarequestMotionConfig,
    .tpDatarequestStationaryConfig,
    .tpDatarequestCapabilities,
  ]
}

#endif  // swift(>=4.2)

enum TPMSAdvType_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case tpmsAdvTypeSemi // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .tpmsAdvTypeSemi
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tpmsAdvTypeSemi
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .tpmsAdvTypeSemi: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TPMSAdvType_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [TPMSAdvType_E] = [
    .tpmsAdvTypeSemi,
  ]
}

#endif  // swift(>=4.2)

enum TPNotifyReason_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case tpNotifyReasonUnknown // = 0
  case tpNotifyReasonLowPressure // = 1
  case tpNotifyReasonPtValueUpdate // = 2
  case tpNotifyReasonWheelMoving // = 3
  case tpNotifyReasonWheelRotationDirectionCalculationReady // = 4
  case tpNotifyReasonLf // = 5
  case tpNotifyReasonFault // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .tpNotifyReasonUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tpNotifyReasonUnknown
    case 1: self = .tpNotifyReasonLowPressure
    case 2: self = .tpNotifyReasonPtValueUpdate
    case 3: self = .tpNotifyReasonWheelMoving
    case 4: self = .tpNotifyReasonWheelRotationDirectionCalculationReady
    case 5: self = .tpNotifyReasonLf
    case 6: self = .tpNotifyReasonFault
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .tpNotifyReasonUnknown: return 0
    case .tpNotifyReasonLowPressure: return 1
    case .tpNotifyReasonPtValueUpdate: return 2
    case .tpNotifyReasonWheelMoving: return 3
    case .tpNotifyReasonWheelRotationDirectionCalculationReady: return 4
    case .tpNotifyReasonLf: return 5
    case .tpNotifyReasonFault: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TPNotifyReason_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [TPNotifyReason_E] = [
    .tpNotifyReasonUnknown,
    .tpNotifyReasonLowPressure,
    .tpNotifyReasonPtValueUpdate,
    .tpNotifyReasonWheelMoving,
    .tpNotifyReasonWheelRotationDirectionCalculationReady,
    .tpNotifyReasonLf,
    .tpNotifyReasonFault,
  ]
}

#endif  // swift(>=4.2)

enum TPNotifyTrackerCommand_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case tpNotifytrackerCommandNone // = 0
  case tpNotifytrackerCommandGetStats // = 1
  case tpNotifytrackerCommandClearStats // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .tpNotifytrackerCommandNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tpNotifytrackerCommandNone
    case 1: self = .tpNotifytrackerCommandGetStats
    case 2: self = .tpNotifytrackerCommandClearStats
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .tpNotifytrackerCommandNone: return 0
    case .tpNotifytrackerCommandGetStats: return 1
    case .tpNotifytrackerCommandClearStats: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TPNotifyTrackerCommand_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [TPNotifyTrackerCommand_E] = [
    .tpNotifytrackerCommandNone,
    .tpNotifytrackerCommandGetStats,
    .tpNotifytrackerCommandClearStats,
  ]
}

#endif  // swift(>=4.2)

enum UIRequest_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case uiRequestNone // = 0
  case uiRequestGetVehicleBleNickName // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .uiRequestNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .uiRequestNone
    case 1: self = .uiRequestGetVehicleBleNickName
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .uiRequestNone: return 0
    case .uiRequestGetVehicleBleNickName: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension UIRequest_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [UIRequest_E] = [
    .uiRequestNone,
    .uiRequestGetVehicleBleNickName,
  ]
}

#endif  // swift(>=4.2)

enum UpdaterLocation: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case application // = 1
  case bootloader // = 2
  case secondaryApplication // = 3
  case applicationInExternalFlash // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .application
    case 2: self = .bootloader
    case 3: self = .secondaryApplication
    case 4: self = .applicationInExternalFlash
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .application: return 1
    case .bootloader: return 2
    case .secondaryApplication: return 3
    case .applicationInExternalFlash: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension UpdaterLocation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [UpdaterLocation] = [
    .none,
    .application,
    .bootloader,
    .secondaryApplication,
    .applicationInExternalFlash,
  ]
}

#endif  // swift(>=4.2)

enum UpdaterStatusCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case error // = 0
  case wait // = 1
  case blockStaged // = 2
  case imageStaged // = 3
  case crcCheckSuccess // = 4
  case crcCheckFail // = 5
  case hashFail // = 6
  case signatureFail // = 7
  case errorHashRestoreFail // = 8
  case locationSet // = 9
  case UNRECOGNIZED(Int)

  init() {
    self = .error
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .error
    case 1: self = .wait
    case 2: self = .blockStaged
    case 3: self = .imageStaged
    case 4: self = .crcCheckSuccess
    case 5: self = .crcCheckFail
    case 6: self = .hashFail
    case 7: self = .signatureFail
    case 8: self = .errorHashRestoreFail
    case 9: self = .locationSet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .error: return 0
    case .wait: return 1
    case .blockStaged: return 2
    case .imageStaged: return 3
    case .crcCheckSuccess: return 4
    case .crcCheckFail: return 5
    case .hashFail: return 6
    case .signatureFail: return 7
    case .errorHashRestoreFail: return 8
    case .locationSet: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension UpdaterStatusCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [UpdaterStatusCode] = [
    .error,
    .wait,
    .blockStaged,
    .imageStaged,
    .crcCheckSuccess,
    .crcCheckFail,
    .hashFail,
    .signatureFail,
    .errorHashRestoreFail,
    .locationSet,
  ]
}

#endif  // swift(>=4.2)

enum UserPresence_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case vehicleUserPresenceUnknown // = 0
  case vehicleUserPresenceNotPresent // = 1
  case vehicleUserPresencePresent // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .vehicleUserPresenceUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .vehicleUserPresenceUnknown
    case 1: self = .vehicleUserPresenceNotPresent
    case 2: self = .vehicleUserPresencePresent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .vehicleUserPresenceUnknown: return 0
    case .vehicleUserPresenceNotPresent: return 1
    case .vehicleUserPresencePresent: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension UserPresence_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [UserPresence_E] = [
    .vehicleUserPresenceUnknown,
    .vehicleUserPresenceNotPresent,
    .vehicleUserPresencePresent,
  ]
}

#endif  // swift(>=4.2)

enum UWBAvailability: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case available // = 1
  case unavailableUnsupportedDevice // = 2
  case unavailablePermissionDenied // = 3
  case unavailable // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .available
    case 2: self = .unavailableUnsupportedDevice
    case 3: self = .unavailablePermissionDenied
    case 4: self = .unavailable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .available: return 1
    case .unavailableUnsupportedDevice: return 2
    case .unavailablePermissionDenied: return 3
    case .unavailable: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension UWBAvailability: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [UWBAvailability] = [
    .unknown,
    .available,
    .unavailableUnsupportedDevice,
    .unavailablePermissionDenied,
    .unavailable,
  ]
}

#endif  // swift(>=4.2)

enum VehicleLockState_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case vehiclelockstateUnlocked // = 0
  case vehiclelockstateLocked // = 1
  case vehiclelockstateInternalLocked // = 2
  case vehiclelockstateSelectiveUnlocked // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .vehiclelockstateUnlocked
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .vehiclelockstateUnlocked
    case 1: self = .vehiclelockstateLocked
    case 2: self = .vehiclelockstateInternalLocked
    case 3: self = .vehiclelockstateSelectiveUnlocked
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .vehiclelockstateUnlocked: return 0
    case .vehiclelockstateLocked: return 1
    case .vehiclelockstateInternalLocked: return 2
    case .vehiclelockstateSelectiveUnlocked: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VehicleLockState_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VehicleLockState_E] = [
    .vehiclelockstateUnlocked,
    .vehiclelockstateLocked,
    .vehiclelockstateInternalLocked,
    .vehiclelockstateSelectiveUnlocked,
  ]
}

#endif  // swift(>=4.2)

enum VehicleSleepStatus_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case vehicleSleepStatusUnknown // = 0
  case vehicleSleepStatusAwake // = 1
  case vehicleSleepStatusAsleep // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .vehicleSleepStatusUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .vehicleSleepStatusUnknown
    case 1: self = .vehicleSleepStatusAwake
    case 2: self = .vehicleSleepStatusAsleep
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .vehicleSleepStatusUnknown: return 0
    case .vehicleSleepStatusAwake: return 1
    case .vehicleSleepStatusAsleep: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension VehicleSleepStatus_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VehicleSleepStatus_E] = [
    .vehicleSleepStatusUnknown,
    .vehicleSleepStatusAwake,
    .vehicleSleepStatusAsleep,
  ]
}

#endif  // swift(>=4.2)

enum WhitelistKeyPermission_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case whitelistkeypermissionAddToWhitelist // = 0
  case whitelistkeypermissionLocalUnlock // = 1
  case whitelistkeypermissionLocalDrive // = 2
  case whitelistkeypermissionRemoteUnlock // = 3
  case whitelistkeypermissionRemoteDrive // = 4
  case whitelistkeypermissionChangePermissions // = 5
  case whitelistkeypermissionRemoveFromWhitelist // = 6
  case whitelistkeypermissionRemoveSelfFromWhitelist // = 7
  case whitelistkeypermissionModifyFleetReservedSlots // = 8
  case whitelistkeypermissionUnknown // = 31
  case UNRECOGNIZED(Int)

  init() {
    self = .whitelistkeypermissionAddToWhitelist
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .whitelistkeypermissionAddToWhitelist
    case 1: self = .whitelistkeypermissionLocalUnlock
    case 2: self = .whitelistkeypermissionLocalDrive
    case 3: self = .whitelistkeypermissionRemoteUnlock
    case 4: self = .whitelistkeypermissionRemoteDrive
    case 5: self = .whitelistkeypermissionChangePermissions
    case 6: self = .whitelistkeypermissionRemoveFromWhitelist
    case 7: self = .whitelistkeypermissionRemoveSelfFromWhitelist
    case 8: self = .whitelistkeypermissionModifyFleetReservedSlots
    case 31: self = .whitelistkeypermissionUnknown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .whitelistkeypermissionAddToWhitelist: return 0
    case .whitelistkeypermissionLocalUnlock: return 1
    case .whitelistkeypermissionLocalDrive: return 2
    case .whitelistkeypermissionRemoteUnlock: return 3
    case .whitelistkeypermissionRemoteDrive: return 4
    case .whitelistkeypermissionChangePermissions: return 5
    case .whitelistkeypermissionRemoveFromWhitelist: return 6
    case .whitelistkeypermissionRemoveSelfFromWhitelist: return 7
    case .whitelistkeypermissionModifyFleetReservedSlots: return 8
    case .whitelistkeypermissionUnknown: return 31
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension WhitelistKeyPermission_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [WhitelistKeyPermission_E] = [
    .whitelistkeypermissionAddToWhitelist,
    .whitelistkeypermissionLocalUnlock,
    .whitelistkeypermissionLocalDrive,
    .whitelistkeypermissionRemoteUnlock,
    .whitelistkeypermissionRemoteDrive,
    .whitelistkeypermissionChangePermissions,
    .whitelistkeypermissionRemoveFromWhitelist,
    .whitelistkeypermissionRemoveSelfFromWhitelist,
    .whitelistkeypermissionModifyFleetReservedSlots,
    .whitelistkeypermissionUnknown,
  ]
}

#endif  // swift(>=4.2)

enum WhitelistOperation_information_E: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case whitelistoperationInformationNone // = 0
  case whitelistoperationInformationUndocumentedError // = 1
  case whitelistoperationInformationNoPermissionToRemoveOneself // = 2
  case whitelistoperationInformationKeyfobSlotsFull // = 3
  case whitelistoperationInformationWhitelistFull // = 4
  case whitelistoperationInformationNoPermissionToAdd // = 5
  case whitelistoperationInformationInvalidPublicKey // = 6
  case whitelistoperationInformationNoPermissionToRemove // = 7
  case whitelistoperationInformationNoPermissionToChangePermissions // = 8
  case whitelistoperationInformationAttemptingToElevateOtherAboveOneself // = 9
  case whitelistoperationInformationAttemptingToDemoteSuperiorToOneself // = 10
  case whitelistoperationInformationAttemptingToRemoveOwnPermissions // = 11
  case whitelistoperationInformationPublicKeyNotOnWhitelist // = 12
  case whitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist // = 13
  case whitelistoperationInformationNotAllowedToAddUnlessOnReader // = 14
  case whitelistoperationInformationFmModifyingOutsideOfFMode // = 15
  case whitelistoperationInformationFmAttemptingToAddPermanentKey // = 16
  case whitelistoperationInformationFmAttemptingToRemovePermanentKey // = 17
  case whitelistoperationInformationKeychainWhileFsFull // = 18
  case whitelistoperationInformationAttemptingToAddKeyWithoutRole // = 19
  case whitelistoperationInformationAttemptingToAddKeyWithServiceRole // = 20
  case whitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech // = 21
  case whitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode // = 22
  case whitelistoperationInformationCouldNotStartLocalEntityAuth // = 23
  case whitelistoperationInformationLocalEntityAuthFailedUiDenied // = 24
  case whitelistoperationInformationLocalEntityAuthFailedTimedOutWaitingForTap // = 25
  case whitelistoperationInformationLocalEntityAuthFailedTimedOutWaitingForUiAck // = 26
  case whitelistoperationInformationLocalEntityAuthFailedValetMode // = 27
  case whitelistoperationInformationLocalEntityAuthFailedCancelled // = 28
  case UNRECOGNIZED(Int)

  init() {
    self = .whitelistoperationInformationNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .whitelistoperationInformationNone
    case 1: self = .whitelistoperationInformationUndocumentedError
    case 2: self = .whitelistoperationInformationNoPermissionToRemoveOneself
    case 3: self = .whitelistoperationInformationKeyfobSlotsFull
    case 4: self = .whitelistoperationInformationWhitelistFull
    case 5: self = .whitelistoperationInformationNoPermissionToAdd
    case 6: self = .whitelistoperationInformationInvalidPublicKey
    case 7: self = .whitelistoperationInformationNoPermissionToRemove
    case 8: self = .whitelistoperationInformationNoPermissionToChangePermissions
    case 9: self = .whitelistoperationInformationAttemptingToElevateOtherAboveOneself
    case 10: self = .whitelistoperationInformationAttemptingToDemoteSuperiorToOneself
    case 11: self = .whitelistoperationInformationAttemptingToRemoveOwnPermissions
    case 12: self = .whitelistoperationInformationPublicKeyNotOnWhitelist
    case 13: self = .whitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist
    case 14: self = .whitelistoperationInformationNotAllowedToAddUnlessOnReader
    case 15: self = .whitelistoperationInformationFmModifyingOutsideOfFMode
    case 16: self = .whitelistoperationInformationFmAttemptingToAddPermanentKey
    case 17: self = .whitelistoperationInformationFmAttemptingToRemovePermanentKey
    case 18: self = .whitelistoperationInformationKeychainWhileFsFull
    case 19: self = .whitelistoperationInformationAttemptingToAddKeyWithoutRole
    case 20: self = .whitelistoperationInformationAttemptingToAddKeyWithServiceRole
    case 21: self = .whitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech
    case 22: self = .whitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode
    case 23: self = .whitelistoperationInformationCouldNotStartLocalEntityAuth
    case 24: self = .whitelistoperationInformationLocalEntityAuthFailedUiDenied
    case 25: self = .whitelistoperationInformationLocalEntityAuthFailedTimedOutWaitingForTap
    case 26: self = .whitelistoperationInformationLocalEntityAuthFailedTimedOutWaitingForUiAck
    case 27: self = .whitelistoperationInformationLocalEntityAuthFailedValetMode
    case 28: self = .whitelistoperationInformationLocalEntityAuthFailedCancelled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .whitelistoperationInformationNone: return 0
    case .whitelistoperationInformationUndocumentedError: return 1
    case .whitelistoperationInformationNoPermissionToRemoveOneself: return 2
    case .whitelistoperationInformationKeyfobSlotsFull: return 3
    case .whitelistoperationInformationWhitelistFull: return 4
    case .whitelistoperationInformationNoPermissionToAdd: return 5
    case .whitelistoperationInformationInvalidPublicKey: return 6
    case .whitelistoperationInformationNoPermissionToRemove: return 7
    case .whitelistoperationInformationNoPermissionToChangePermissions: return 8
    case .whitelistoperationInformationAttemptingToElevateOtherAboveOneself: return 9
    case .whitelistoperationInformationAttemptingToDemoteSuperiorToOneself: return 10
    case .whitelistoperationInformationAttemptingToRemoveOwnPermissions: return 11
    case .whitelistoperationInformationPublicKeyNotOnWhitelist: return 12
    case .whitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist: return 13
    case .whitelistoperationInformationNotAllowedToAddUnlessOnReader: return 14
    case .whitelistoperationInformationFmModifyingOutsideOfFMode: return 15
    case .whitelistoperationInformationFmAttemptingToAddPermanentKey: return 16
    case .whitelistoperationInformationFmAttemptingToRemovePermanentKey: return 17
    case .whitelistoperationInformationKeychainWhileFsFull: return 18
    case .whitelistoperationInformationAttemptingToAddKeyWithoutRole: return 19
    case .whitelistoperationInformationAttemptingToAddKeyWithServiceRole: return 20
    case .whitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech: return 21
    case .whitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode: return 22
    case .whitelistoperationInformationCouldNotStartLocalEntityAuth: return 23
    case .whitelistoperationInformationLocalEntityAuthFailedUiDenied: return 24
    case .whitelistoperationInformationLocalEntityAuthFailedTimedOutWaitingForTap: return 25
    case .whitelistoperationInformationLocalEntityAuthFailedTimedOutWaitingForUiAck: return 26
    case .whitelistoperationInformationLocalEntityAuthFailedValetMode: return 27
    case .whitelistoperationInformationLocalEntityAuthFailedCancelled: return 28
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension WhitelistOperation_information_E: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [WhitelistOperation_information_E] = [
    .whitelistoperationInformationNone,
    .whitelistoperationInformationUndocumentedError,
    .whitelistoperationInformationNoPermissionToRemoveOneself,
    .whitelistoperationInformationKeyfobSlotsFull,
    .whitelistoperationInformationWhitelistFull,
    .whitelistoperationInformationNoPermissionToAdd,
    .whitelistoperationInformationInvalidPublicKey,
    .whitelistoperationInformationNoPermissionToRemove,
    .whitelistoperationInformationNoPermissionToChangePermissions,
    .whitelistoperationInformationAttemptingToElevateOtherAboveOneself,
    .whitelistoperationInformationAttemptingToDemoteSuperiorToOneself,
    .whitelistoperationInformationAttemptingToRemoveOwnPermissions,
    .whitelistoperationInformationPublicKeyNotOnWhitelist,
    .whitelistoperationInformationAttemptingToAddKeyThatIsAlreadyOnTheWhitelist,
    .whitelistoperationInformationNotAllowedToAddUnlessOnReader,
    .whitelistoperationInformationFmModifyingOutsideOfFMode,
    .whitelistoperationInformationFmAttemptingToAddPermanentKey,
    .whitelistoperationInformationFmAttemptingToRemovePermanentKey,
    .whitelistoperationInformationKeychainWhileFsFull,
    .whitelistoperationInformationAttemptingToAddKeyWithoutRole,
    .whitelistoperationInformationAttemptingToAddKeyWithServiceRole,
    .whitelistoperationInformationNonServiceKeyAttemptingToAddServiceTech,
    .whitelistoperationInformationServiceKeyAttemptingToAddServiceTechOutsideServiceMode,
    .whitelistoperationInformationCouldNotStartLocalEntityAuth,
    .whitelistoperationInformationLocalEntityAuthFailedUiDenied,
    .whitelistoperationInformationLocalEntityAuthFailedTimedOutWaitingForTap,
    .whitelistoperationInformationLocalEntityAuthFailedTimedOutWaitingForUiAck,
    .whitelistoperationInformationLocalEntityAuthFailedValetMode,
    .whitelistoperationInformationLocalEntityAuthFailedCancelled,
  ]
}

#endif  // swift(>=4.2)

struct AccelData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var xAccelG: Int32 = 0

  var zAccelG: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ActiveKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var activeKey: KeyIdentifier {
    get {return _activeKey ?? KeyIdentifier()}
    set {_activeKey = newValue}
  }
  /// Returns true if `activeKey` has been explicitly set.
  var hasActiveKey: Bool {return self._activeKey != nil}
  /// Clears the value of `activeKey`. Subsequent reads from it will return its default value.
  mutating func clearActiveKey() {self._activeKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _activeKey: KeyIdentifier? = nil
}

struct Alert {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: Alert.OneOf_SubMessage? = nil

  var alertHandlePulledWithoutAuth: AlertHandlePulledWithoutAuth {
    get {
      if case .alertHandlePulledWithoutAuth(let v)? = subMessage {return v}
      return AlertHandlePulledWithoutAuth()
    }
    set {subMessage = .alertHandlePulledWithoutAuth(newValue)}
  }

  var alertConfirmation: AlertConfirmation {
    get {
      if case .alertConfirmation(let v)? = subMessage {return v}
      return .none
    }
    set {subMessage = .alertConfirmation(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case alertHandlePulledWithoutAuth(AlertHandlePulledWithoutAuth)
    case alertConfirmation(AlertConfirmation)

  #if !swift(>=4.1)
    static func ==(lhs: Alert.OneOf_SubMessage, rhs: Alert.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.alertHandlePulledWithoutAuth, .alertHandlePulledWithoutAuth): return {
        guard case .alertHandlePulledWithoutAuth(let l) = lhs, case .alertHandlePulledWithoutAuth(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.alertConfirmation, .alertConfirmation): return {
        guard case .alertConfirmation(let l) = lhs, case .alertConfirmation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct AlertHandlePulledWithoutAuth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeSinceAlertSetMs: UInt32 = 0

  var handlePulled: HandlePulled_E = .handlePulledFrontDriverDoor

  var connectionCount: UInt32 = 0

  var unknownDevicePresent: Bool = false

  var authRequested: Bool = false

  var deviceSpecificPayload: [HandlePulledWithoutAuthDeviceSpecificPayload] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AppDeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hardwareModelSha256: Data = Data()

  var os: AppOperatingSystem = .unknown

  var uwbavailable: UWBAvailability = .unknown

  var phoneVersion: PhoneVersionInfo {
    get {return _phoneVersion ?? PhoneVersionInfo()}
    set {_phoneVersion = newValue}
  }
  /// Returns true if `phoneVersion` has been explicitly set.
  var hasPhoneVersion: Bool {return self._phoneVersion != nil}
  /// Clears the value of `phoneVersion`. Subsequent reads from it will return its default value.
  mutating func clearPhoneVersion() {self._phoneVersion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _phoneVersion: PhoneVersionInfo? = nil
}

struct AppEventLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: UInt32 = 0

  var subMessage: AppEventLog.OneOf_SubMessage? = nil

  var peerRemovedPairingInformation: AppEventPeerRemovedPairingInformation {
    get {
      if case .peerRemovedPairingInformation(let v)? = subMessage {return v}
      return AppEventPeerRemovedPairingInformation()
    }
    set {subMessage = .peerRemovedPairingInformation(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case peerRemovedPairingInformation(AppEventPeerRemovedPairingInformation)

  #if !swift(>=4.1)
    static func ==(lhs: AppEventLog.OneOf_SubMessage, rhs: AppEventLog.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.peerRemovedPairingInformation, .peerRemovedPairingInformation): return {
        guard case .peerRemovedPairingInformation(let l) = lhs, case .peerRemovedPairingInformation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

struct AppEventPeerRemovedPairingInformation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyID: KeyIdentifier {
    get {return _keyID ?? KeyIdentifier()}
    set {_keyID = newValue}
  }
  /// Returns true if `keyID` has been explicitly set.
  var hasKeyID: Bool {return self._keyID != nil}
  /// Clears the value of `keyID`. Subsequent reads from it will return its default value.
  mutating func clearKeyID() {self._keyID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyID: KeyIdentifier? = nil
}

struct ASICSPIRead {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: UInt32 = 0

  var data_: UInt32 = 0

  var opCode: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AuthenticationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionInfo: AuthenticationRequestToken {
    get {return _sessionInfo ?? AuthenticationRequestToken()}
    set {_sessionInfo = newValue}
  }
  /// Returns true if `sessionInfo` has been explicitly set.
  var hasSessionInfo: Bool {return self._sessionInfo != nil}
  /// Clears the value of `sessionInfo`. Subsequent reads from it will return its default value.
  mutating func clearSessionInfo() {self._sessionInfo = nil}

  var requestedLevel: AuthenticationLevel_E = .authenticationLevelNone

  var reasonsForAuth: [AuthenticationReason_E] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sessionInfo: AuthenticationRequestToken? = nil
}

struct AuthenticationRequestToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AuthenticationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var authenticationLevel: AuthenticationLevel_E = .authenticationLevelNone

  var estimatedDistance: UInt32 = 0

  var authenticationRejection: AuthenticationRejection_E = .authenticationrejectionNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BLEConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: BLEConfig.OneOf_SubMessage? = nil

  var advinterval: UInt32 {
    get {
      if case .advinterval(let v)? = subMessage {return v}
      return 0
    }
    set {subMessage = .advinterval(newValue)}
  }

  var sleepClockAccuracy: UInt32 {
    get {
      if case .sleepClockAccuracy(let v)? = subMessage {return v}
      return 0
    }
    set {subMessage = .sleepClockAccuracy(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case advinterval(UInt32)
    case sleepClockAccuracy(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: BLEConfig.OneOf_SubMessage, rhs: BLEConfig.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.advinterval, .advinterval): return {
        guard case .advinterval(let l) = lhs, case .advinterval(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sleepClockAccuracy, .sleepClockAccuracy): return {
        guard case .sleepClockAccuracy(let l) = lhs, case .sleepClockAccuracy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct BLEConfigAll {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var advinterval: UInt32 = 0

  var sleepClockAccuracy: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BLEConfigCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bleconfigCommandType: BLEConfigCommandType_E = .bleConfigCommandTypeNone

  var bleconfig: BLEConfig {
    get {return _bleconfig ?? BLEConfig()}
    set {_bleconfig = newValue}
  }
  /// Returns true if `bleconfig` has been explicitly set.
  var hasBleconfig: Bool {return self._bleconfig != nil}
  /// Clears the value of `bleconfig`. Subsequent reads from it will return its default value.
  mutating func clearBleconfig() {self._bleconfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bleconfig: BLEConfig? = nil
}

struct Capabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargePortOpen: Bool = false

  var chargePortClose: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Certificate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: Certificate.OneOf_SubMessage? = nil

  var certificateInParts: CertificateInParts {
    get {
      if case .certificateInParts(let v)? = subMessage {return v}
      return CertificateInParts()
    }
    set {subMessage = .certificateInParts(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case certificateInParts(CertificateInParts)

  #if !swift(>=4.1)
    static func ==(lhs: Certificate.OneOf_SubMessage, rhs: Certificate.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.certificateInParts, .certificateInParts): return {
        guard case .certificateInParts(let l) = lhs, case .certificateInParts(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

struct CertificateInParts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startIndex: UInt32 = 0

  var certificateSize: UInt32 = 0

  var data_: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CertificateRead {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var readIndex: UInt32 = 0

  var lengthToRead: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CertificateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var certificate: Certificate {
    get {return _certificate ?? Certificate()}
    set {_certificate = newValue}
  }
  /// Returns true if `certificate` has been explicitly set.
  var hasCertificate: Bool {return self._certificate != nil}
  /// Clears the value of `certificate`. Subsequent reads from it will return its default value.
  mutating func clearCertificate() {self._certificate = nil}

  var certificateStatus: CertificateStatus_E = .certificateStatusNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _certificate: Certificate? = nil
}

struct ChallengeCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var challenge: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ChallengeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ClosureMoveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frontDriverDoor: ClosureMoveType_E = .closureMoveTypeNone

  var frontPassengerDoor: ClosureMoveType_E = .closureMoveTypeNone

  var rearDriverDoor: ClosureMoveType_E = .closureMoveTypeNone

  var rearPassengerDoor: ClosureMoveType_E = .closureMoveTypeNone

  var rearTrunk: ClosureMoveType_E = .closureMoveTypeNone

  var frontTrunk: ClosureMoveType_E = .closureMoveTypeNone

  var chargePort: ClosureMoveType_E = .closureMoveTypeNone

  var tonneau: ClosureMoveType_E = .closureMoveTypeNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ClosureStatuses {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var frontDriverDoor: ClosureState_E = .closurestateClosed

  var frontPassengerDoor: ClosureState_E = .closurestateClosed

  var rearDriverDoor: ClosureState_E = .closurestateClosed

  var rearPassengerDoor: ClosureState_E = .closurestateClosed

  var rearTrunk: ClosureState_E = .closurestateClosed

  var frontTrunk: ClosureState_E = .closurestateClosed

  var chargePort: ClosureState_E = .closurestateClosed

  var tonneau: ClosureState_E = .closurestateClosed

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CodeDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var codeDescriptorLocation: UpdaterLocation = .none

  var version: UInt32 = 0

  var codeDescriptorBytes: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CommandStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operationStatus: OperationStatus_E = .operationstatusOk

  var subMessage: CommandStatus.OneOf_SubMessage? = nil

  var signedMessageStatus: SignedMessage_status {
    get {
      if case .signedMessageStatus(let v)? = subMessage {return v}
      return SignedMessage_status()
    }
    set {subMessage = .signedMessageStatus(newValue)}
  }

  var whitelistOperationStatus: WhitelistOperation_status {
    get {
      if case .whitelistOperationStatus(let v)? = subMessage {return v}
      return WhitelistOperation_status()
    }
    set {subMessage = .whitelistOperationStatus(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case signedMessageStatus(SignedMessage_status)
    case whitelistOperationStatus(WhitelistOperation_status)

  #if !swift(>=4.1)
    static func ==(lhs: CommandStatus.OneOf_SubMessage, rhs: CommandStatus.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.signedMessageStatus, .signedMessageStatus): return {
        guard case .signedMessageStatus(let l) = lhs, case .signedMessageStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whitelistOperationStatus, .whitelistOperationStatus): return {
        guard case .whitelistOperationStatus(let l) = lhs, case .whitelistOperationStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct ConnectionMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var goodConnEventCount: UInt32 = 0

  var missedConnEventCount: UInt32 = 0

  var badCrcconnEventCount: UInt32 = 0

  var otherFailuresCount: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DelaySleepRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var delayTimeMs: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DetailedClosureStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tonneauPercentOpen: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DeviceMotion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var states: [Device_Motion_State] = []

  var confidence: Device_Motion_Confidence = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FromRCI {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FromVCSECMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: FromVCSECMessage.OneOf_SubMessage? = nil

  var vehicleStatus: VehicleStatus {
    get {
      if case .vehicleStatus(let v)? = subMessage {return v}
      return VehicleStatus()
    }
    set {subMessage = .vehicleStatus(newValue)}
  }

  var sessionInfo: SessionInfo {
    get {
      if case .sessionInfo(let v)? = subMessage {return v}
      return SessionInfo()
    }
    set {subMessage = .sessionInfo(newValue)}
  }

  var authenticationRequest: AuthenticationRequest {
    get {
      if case .authenticationRequest(let v)? = subMessage {return v}
      return AuthenticationRequest()
    }
    set {subMessage = .authenticationRequest(newValue)}
  }

  var commandStatus: CommandStatus {
    get {
      if case .commandStatus(let v)? = subMessage {return v}
      return CommandStatus()
    }
    set {subMessage = .commandStatus(newValue)}
  }

  var personalizationInformation: PersonalizationInformation {
    get {
      if case .personalizationInformation(let v)? = subMessage {return v}
      return PersonalizationInformation()
    }
    set {subMessage = .personalizationInformation(newValue)}
  }

  var whitelistInfo: WhitelistInfo {
    get {
      if case .whitelistInfo(let v)? = subMessage {return v}
      return WhitelistInfo()
    }
    set {subMessage = .whitelistInfo(newValue)}
  }

  var whitelistEntryInfo: WhitelistEntryInfo {
    get {
      if case .whitelistEntryInfo(let v)? = subMessage {return v}
      return WhitelistEntryInfo()
    }
    set {subMessage = .whitelistEntryInfo(newValue)}
  }

  var vehicleInfo: VehicleInfo {
    get {
      if case .vehicleInfo(let v)? = subMessage {return v}
      return VehicleInfo()
    }
    set {subMessage = .vehicleInfo(newValue)}
  }

  var capabilities: Capabilities {
    get {
      if case .capabilities(let v)? = subMessage {return v}
      return Capabilities()
    }
    set {subMessage = .capabilities(newValue)}
  }

  var keyStatusInfo: KeyStatusInfo {
    get {
      if case .keyStatusInfo(let v)? = subMessage {return v}
      return KeyStatusInfo()
    }
    set {subMessage = .keyStatusInfo(newValue)}
  }

  var activeKey: ActiveKey {
    get {
      if case .activeKey(let v)? = subMessage {return v}
      return ActiveKey()
    }
    set {subMessage = .activeKey(newValue)}
  }

  var unknownKeyInfo: UnknownKeyInfo {
    get {
      if case .unknownKeyInfo(let v)? = subMessage {return v}
      return UnknownKeyInfo()
    }
    set {subMessage = .unknownKeyInfo(newValue)}
  }

  var uirequest: UIRequest_E {
    get {
      if case .uirequest(let v)? = subMessage {return v}
      return .uiRequestNone
    }
    set {subMessage = .uirequest(newValue)}
  }

  var updaterCommand: UpdaterCommand {
    get {
      if case .updaterCommand(let v)? = subMessage {return v}
      return UpdaterCommand()
    }
    set {subMessage = .updaterCommand(newValue)}
  }

  var genealogyRequest: GenealogyRequest_E {
    get {
      if case .genealogyRequest(let v)? = subMessage {return v}
      return .genealogyrequestNone
    }
    set {subMessage = .genealogyRequest(newValue)}
  }

  var sleepManagerRequest: SleepManagerRequest {
    get {
      if case .sleepManagerRequest(let v)? = subMessage {return v}
      return SleepManagerRequest()
    }
    set {subMessage = .sleepManagerRequest(newValue)}
  }

  var imuRequest: IMURequest_E {
    get {
      if case .imuRequest(let v)? = subMessage {return v}
      return .imuRequestNone
    }
    set {subMessage = .imuRequest(newValue)}
  }

  var nfcseRequest: NFCSERequest_E {
    get {
      if case .nfcseRequest(let v)? = subMessage {return v}
      return .nfcseRequestNone
    }
    set {subMessage = .nfcseRequest(newValue)}
  }

  var tpdataRequest: TPDataRequest_E {
    get {
      if case .tpdataRequest(let v)? = subMessage {return v}
      return .tpDatarequestNone
    }
    set {subMessage = .tpdataRequest(newValue)}
  }

  var resetTrackerCommand: ResetTrackerCommand_E {
    get {
      if case .resetTrackerCommand(let v)? = subMessage {return v}
      return .resettrackerCommandNone
    }
    set {subMessage = .resetTrackerCommand(newValue)}
  }

  var tpnotifyTrackerCommand: TPNotifyTrackerCommand_E {
    get {
      if case .tpnotifyTrackerCommand(let v)? = subMessage {return v}
      return .tpNotifytrackerCommandNone
    }
    set {subMessage = .tpnotifyTrackerCommand(newValue)}
  }

  var setTpconfiguration: SetTPConfiguration {
    get {
      if case .setTpconfiguration(let v)? = subMessage {return v}
      return SetTPConfiguration()
    }
    set {subMessage = .setTpconfiguration(newValue)}
  }

  var unsecureNotification: UnsecureNotification {
    get {
      if case .unsecureNotification(let v)? = subMessage {return v}
      return UnsecureNotification()
    }
    set {subMessage = .unsecureNotification(newValue)}
  }

  var epochSessionInfo: Signatures.SessionInfo {
    get {
      if case .epochSessionInfo(let v)? = subMessage {return v}
      return Signatures.SessionInfo()
    }
    set {subMessage = .epochSessionInfo(newValue)}
  }

  var toRcicommand: ToRCI {
    get {
      if case .toRcicommand(let v)? = subMessage {return v}
      return ToRCI()
    }
    set {subMessage = .toRcicommand(newValue)}
  }

  var rciControl: RCI_control_E {
    get {
      if case .rciControl(let v)? = subMessage {return v}
      return .rciControlNone
    }
    set {subMessage = .rciControl(newValue)}
  }

  var bleconfigCommand: BLEConfigCommand {
    get {
      if case .bleconfigCommand(let v)? = subMessage {return v}
      return BLEConfigCommand()
    }
    set {subMessage = .bleconfigCommand(newValue)}
  }

  var appDeviceInfoRequest: AppDeviceInfoRequest_E {
    get {
      if case .appDeviceInfoRequest(let v)? = subMessage {return v}
      return .appDeviceInfoRequestNone
    }
    set {subMessage = .appDeviceInfoRequest(newValue)}
  }

  var alert: Alert {
    get {
      if case .alert(let v)? = subMessage {return v}
      return Alert()
    }
    set {subMessage = .alert(newValue)}
  }

  var nominalError: NominalError {
    get {
      if case .nominalError(let v)? = subMessage {return v}
      return NominalError()
    }
    set {subMessage = .nominalError(newValue)}
  }

  var misessionRequest: MISessionRequest {
    get {
      if case .misessionRequest(let v)? = subMessage {return v}
      return MISessionRequest()
    }
    set {subMessage = .misessionRequest(newValue)}
  }

  var misessionStop: MISessionStop {
    get {
      if case .misessionStop(let v)? = subMessage {return v}
      return MISessionStop()
    }
    set {subMessage = .misessionStop(newValue)}
  }

  var clearTpmsalarms_p: TPMSAlarms {
    get {
      if case .clearTpmsalarms_p(let v)? = subMessage {return v}
      return TPMSAlarms()
    }
    set {subMessage = .clearTpmsalarms_p(newValue)}
  }

  var certificateRead: CertificateRead {
    get {
      if case .certificateRead(let v)? = subMessage {return v}
      return CertificateRead()
    }
    set {subMessage = .certificateRead(newValue)}
  }

  var challengeCommand: ChallengeCommand {
    get {
      if case .challengeCommand(let v)? = subMessage {return v}
      return ChallengeCommand()
    }
    set {subMessage = .challengeCommand(newValue)}
  }

  var publicKeyRequest: PublicKeyRequest_E {
    get {
      if case .publicKeyRequest(let v)? = subMessage {return v}
      return .publicKeyRequestNone
    }
    set {subMessage = .publicKeyRequest(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case vehicleStatus(VehicleStatus)
    case sessionInfo(SessionInfo)
    case authenticationRequest(AuthenticationRequest)
    case commandStatus(CommandStatus)
    case personalizationInformation(PersonalizationInformation)
    case whitelistInfo(WhitelistInfo)
    case whitelistEntryInfo(WhitelistEntryInfo)
    case vehicleInfo(VehicleInfo)
    case capabilities(Capabilities)
    case keyStatusInfo(KeyStatusInfo)
    case activeKey(ActiveKey)
    case unknownKeyInfo(UnknownKeyInfo)
    case uirequest(UIRequest_E)
    case updaterCommand(UpdaterCommand)
    case genealogyRequest(GenealogyRequest_E)
    case sleepManagerRequest(SleepManagerRequest)
    case imuRequest(IMURequest_E)
    case nfcseRequest(NFCSERequest_E)
    case tpdataRequest(TPDataRequest_E)
    case resetTrackerCommand(ResetTrackerCommand_E)
    case tpnotifyTrackerCommand(TPNotifyTrackerCommand_E)
    case setTpconfiguration(SetTPConfiguration)
    case unsecureNotification(UnsecureNotification)
    case epochSessionInfo(Signatures.SessionInfo)
    case toRcicommand(ToRCI)
    case rciControl(RCI_control_E)
    case bleconfigCommand(BLEConfigCommand)
    case appDeviceInfoRequest(AppDeviceInfoRequest_E)
    case alert(Alert)
    case nominalError(NominalError)
    case misessionRequest(MISessionRequest)
    case misessionStop(MISessionStop)
    case clearTpmsalarms_p(TPMSAlarms)
    case certificateRead(CertificateRead)
    case challengeCommand(ChallengeCommand)
    case publicKeyRequest(PublicKeyRequest_E)

  #if !swift(>=4.1)
    static func ==(lhs: FromVCSECMessage.OneOf_SubMessage, rhs: FromVCSECMessage.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.vehicleStatus, .vehicleStatus): return {
        guard case .vehicleStatus(let l) = lhs, case .vehicleStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionInfo, .sessionInfo): return {
        guard case .sessionInfo(let l) = lhs, case .sessionInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.authenticationRequest, .authenticationRequest): return {
        guard case .authenticationRequest(let l) = lhs, case .authenticationRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.commandStatus, .commandStatus): return {
        guard case .commandStatus(let l) = lhs, case .commandStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.personalizationInformation, .personalizationInformation): return {
        guard case .personalizationInformation(let l) = lhs, case .personalizationInformation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whitelistInfo, .whitelistInfo): return {
        guard case .whitelistInfo(let l) = lhs, case .whitelistInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whitelistEntryInfo, .whitelistEntryInfo): return {
        guard case .whitelistEntryInfo(let l) = lhs, case .whitelistEntryInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.vehicleInfo, .vehicleInfo): return {
        guard case .vehicleInfo(let l) = lhs, case .vehicleInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.capabilities, .capabilities): return {
        guard case .capabilities(let l) = lhs, case .capabilities(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keyStatusInfo, .keyStatusInfo): return {
        guard case .keyStatusInfo(let l) = lhs, case .keyStatusInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.activeKey, .activeKey): return {
        guard case .activeKey(let l) = lhs, case .activeKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unknownKeyInfo, .unknownKeyInfo): return {
        guard case .unknownKeyInfo(let l) = lhs, case .unknownKeyInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uirequest, .uirequest): return {
        guard case .uirequest(let l) = lhs, case .uirequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updaterCommand, .updaterCommand): return {
        guard case .updaterCommand(let l) = lhs, case .updaterCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.genealogyRequest, .genealogyRequest): return {
        guard case .genealogyRequest(let l) = lhs, case .genealogyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sleepManagerRequest, .sleepManagerRequest): return {
        guard case .sleepManagerRequest(let l) = lhs, case .sleepManagerRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.imuRequest, .imuRequest): return {
        guard case .imuRequest(let l) = lhs, case .imuRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nfcseRequest, .nfcseRequest): return {
        guard case .nfcseRequest(let l) = lhs, case .nfcseRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpdataRequest, .tpdataRequest): return {
        guard case .tpdataRequest(let l) = lhs, case .tpdataRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resetTrackerCommand, .resetTrackerCommand): return {
        guard case .resetTrackerCommand(let l) = lhs, case .resetTrackerCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpnotifyTrackerCommand, .tpnotifyTrackerCommand): return {
        guard case .tpnotifyTrackerCommand(let l) = lhs, case .tpnotifyTrackerCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setTpconfiguration, .setTpconfiguration): return {
        guard case .setTpconfiguration(let l) = lhs, case .setTpconfiguration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsecureNotification, .unsecureNotification): return {
        guard case .unsecureNotification(let l) = lhs, case .unsecureNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.epochSessionInfo, .epochSessionInfo): return {
        guard case .epochSessionInfo(let l) = lhs, case .epochSessionInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.toRcicommand, .toRcicommand): return {
        guard case .toRcicommand(let l) = lhs, case .toRcicommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rciControl, .rciControl): return {
        guard case .rciControl(let l) = lhs, case .rciControl(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bleconfigCommand, .bleconfigCommand): return {
        guard case .bleconfigCommand(let l) = lhs, case .bleconfigCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appDeviceInfoRequest, .appDeviceInfoRequest): return {
        guard case .appDeviceInfoRequest(let l) = lhs, case .appDeviceInfoRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.alert, .alert): return {
        guard case .alert(let l) = lhs, case .alert(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nominalError, .nominalError): return {
        guard case .nominalError(let l) = lhs, case .nominalError(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.misessionRequest, .misessionRequest): return {
        guard case .misessionRequest(let l) = lhs, case .misessionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.misessionStop, .misessionStop): return {
        guard case .misessionStop(let l) = lhs, case .misessionStop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clearTpmsalarms_p, .clearTpmsalarms_p): return {
        guard case .clearTpmsalarms_p(let l) = lhs, case .clearTpmsalarms_p(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.certificateRead, .certificateRead): return {
        guard case .certificateRead(let l) = lhs, case .certificateRead(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.challengeCommand, .challengeCommand): return {
        guard case .challengeCommand(let l) = lhs, case .challengeCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publicKeyRequest, .publicKeyRequest): return {
        guard case .publicKeyRequest(let l) = lhs, case .publicKeyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Genealogy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serialNumber: Data = Data()

  var partNumber: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GenealogyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentGenealogy: Genealogy {
    get {return _currentGenealogy ?? Genealogy()}
    set {_currentGenealogy = newValue}
  }
  /// Returns true if `currentGenealogy` has been explicitly set.
  var hasCurrentGenealogy: Bool {return self._currentGenealogy != nil}
  /// Clears the value of `currentGenealogy`. Subsequent reads from it will return its default value.
  mutating func clearCurrentGenealogy() {self._currentGenealogy = nil}

  var status: GenealogyStatus_E = .genealogyStatusNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _currentGenealogy: Genealogy? = nil
}

struct GetCodeDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var location: UpdaterLocation = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetReaderKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: GetReaderKeyCommand = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HandlePulledWithoutAuthDeviceSpecificPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyChannel: UInt32 {
    get {return _storage._keyChannel}
    set {_uniqueStorage()._keyChannel = newValue}
  }

  var authenticationLevel: AuthenticationLevel_E {
    get {return _storage._authenticationLevel}
    set {_uniqueStorage()._authenticationLevel = newValue}
  }

  var present: Bool {
    get {return _storage._present}
    set {_uniqueStorage()._present = newValue}
  }

  var rssileft: Int32 {
    get {return _storage._rssileft}
    set {_uniqueStorage()._rssileft = newValue}
  }

  var rssiright: Int32 {
    get {return _storage._rssiright}
    set {_uniqueStorage()._rssiright = newValue}
  }

  var rssirear: Int32 {
    get {return _storage._rssirear}
    set {_uniqueStorage()._rssirear = newValue}
  }

  var rssicenter: Int32 {
    get {return _storage._rssicenter}
    set {_uniqueStorage()._rssicenter = newValue}
  }

  var rssifront: Int32 {
    get {return _storage._rssifront}
    set {_uniqueStorage()._rssifront = newValue}
  }

  var rssisecondary: Int32 {
    get {return _storage._rssisecondary}
    set {_uniqueStorage()._rssisecondary = newValue}
  }

  var rssinfccradle: Int32 {
    get {return _storage._rssinfccradle}
    set {_uniqueStorage()._rssinfccradle = newValue}
  }

  var rssirearLeft: Int32 {
    get {return _storage._rssirearLeft}
    set {_uniqueStorage()._rssirearLeft = newValue}
  }

  var rssirearRight: Int32 {
    get {return _storage._rssirearRight}
    set {_uniqueStorage()._rssirearRight = newValue}
  }

  var highThreshLeftPresent: Bool {
    get {return _storage._highThreshLeftPresent}
    set {_uniqueStorage()._highThreshLeftPresent = newValue}
  }

  var highThreshRightPresent: Bool {
    get {return _storage._highThreshRightPresent}
    set {_uniqueStorage()._highThreshRightPresent = newValue}
  }

  var highThreshCenterPresent: Bool {
    get {return _storage._highThreshCenterPresent}
    set {_uniqueStorage()._highThreshCenterPresent = newValue}
  }

  var highThreshFrontPresent: Bool {
    get {return _storage._highThreshFrontPresent}
    set {_uniqueStorage()._highThreshFrontPresent = newValue}
  }

  var highThreshRearPresent: Bool {
    get {return _storage._highThreshRearPresent}
    set {_uniqueStorage()._highThreshRearPresent = newValue}
  }

  var highThreshRearLeftPresent: Bool {
    get {return _storage._highThreshRearLeftPresent}
    set {_uniqueStorage()._highThreshRearLeftPresent = newValue}
  }

  var highThreshRearRightPresent: Bool {
    get {return _storage._highThreshRearRightPresent}
    set {_uniqueStorage()._highThreshRearRightPresent = newValue}
  }

  var highThreshSecondaryPresent: Bool {
    get {return _storage._highThreshSecondaryPresent}
    set {_uniqueStorage()._highThreshSecondaryPresent = newValue}
  }

  var highThreshNfcpresent: Bool {
    get {return _storage._highThreshNfcpresent}
    set {_uniqueStorage()._highThreshNfcpresent = newValue}
  }

  var sortedDeltaBayesLeftPresent: Bool {
    get {return _storage._sortedDeltaBayesLeftPresent}
    set {_uniqueStorage()._sortedDeltaBayesLeftPresent = newValue}
  }

  var sortedDeltaBayesRightPresent: Bool {
    get {return _storage._sortedDeltaBayesRightPresent}
    set {_uniqueStorage()._sortedDeltaBayesRightPresent = newValue}
  }

  var rawDeltaBayesLeftPresent: Bool {
    get {return _storage._rawDeltaBayesLeftPresent}
    set {_uniqueStorage()._rawDeltaBayesLeftPresent = newValue}
  }

  var rawDeltaBayesRightPresent: Bool {
    get {return _storage._rawDeltaBayesRightPresent}
    set {_uniqueStorage()._rawDeltaBayesRightPresent = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct InformationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var informationRequestType: InformationRequestType = .getStatus

  var subMessage: InformationRequest.OneOf_SubMessage? = nil

  var keyID: KeyIdentifier {
    get {
      if case .keyID(let v)? = subMessage {return v}
      return KeyIdentifier()
    }
    set {subMessage = .keyID(newValue)}
  }

  var publicKey: Data {
    get {
      if case .publicKey(let v)? = subMessage {return v}
      return Data()
    }
    set {subMessage = .publicKey(newValue)}
  }

  var slot: UInt32 {
    get {
      if case .slot(let v)? = subMessage {return v}
      return 0
    }
    set {subMessage = .slot(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case keyID(KeyIdentifier)
    case publicKey(Data)
    case slot(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: InformationRequest.OneOf_SubMessage, rhs: InformationRequest.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.keyID, .keyID): return {
        guard case .keyID(let l) = lhs, case .keyID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publicKey, .publicKey): return {
        guard case .publicKey(let l) = lhs, case .publicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.slot, .slot): return {
        guard case .slot(let l) = lhs, case .slot(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct KeyfobInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appCrc: Data = Data()

  var batteryVoltageMV: UInt32 = 0

  var temperatureDegreesC: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct KeyIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKeySha1: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct KeyMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyFormFactor: KeyFormFactor = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct KeyStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyID: KeyIdentifier {
    get {return _keyID ?? KeyIdentifier()}
    set {_keyID = newValue}
  }
  /// Returns true if `keyID` has been explicitly set.
  var hasKeyID: Bool {return self._keyID != nil}
  /// Clears the value of `keyID`. Subsequent reads from it will return its default value.
  mutating func clearKeyID() {self._keyID = nil}

  var nfcPresence: NFCPresence = .notPresent

  var blePresence: BLEPresence = .notPresent

  var publicKey: PublicKey {
    get {return _publicKey ?? PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var keyFormFactor: KeyFormFactor = .unknown

  var slot: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyID: KeyIdentifier? = nil
  fileprivate var _publicKey: PublicKey? = nil
}

struct KeyStatusInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyStatuses: [KeyStatus] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MIConfigurationData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data_: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MISessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: UInt32 = 0

  var accessoryConfigurationData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MISessionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: UInt32 = 0

  var subMessage: MISessionResponse.OneOf_SubMessage? = nil

  var miconfigurationData: MIConfigurationData {
    get {
      if case .miconfigurationData(let v)? = subMessage {return v}
      return MIConfigurationData()
    }
    set {subMessage = .miconfigurationData(newValue)}
  }

  var errorCode: MIError_E {
    get {
      if case .errorCode(let v)? = subMessage {return v}
      return .errorUnknown
    }
    set {subMessage = .errorCode(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case miconfigurationData(MIConfigurationData)
    case errorCode(MIError_E)

  #if !swift(>=4.1)
    static func ==(lhs: MISessionResponse.OneOf_SubMessage, rhs: MISessionResponse.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.miconfigurationData, .miconfigurationData): return {
        guard case .miconfigurationData(let l) = lhs, case .miconfigurationData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.errorCode, .errorCode): return {
        guard case .errorCode(let l) = lhs, case .errorCode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct MISessionStop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: MISessionStop.OneOf_SubMessage? = nil

  var sessionID: UInt32 {
    get {
      if case .sessionID(let v)? = subMessage {return v}
      return 0
    }
    set {subMessage = .sessionID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case sessionID(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: MISessionStop.OneOf_SubMessage, rhs: MISessionStop.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sessionID, .sessionID): return {
        guard case .sessionID(let l) = lhs, case .sessionID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

struct MISessionStopped {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: MISessionStopped.OneOf_SubMessage? = nil

  var sessionID: UInt32 {
    get {
      if case .sessionID(let v)? = subMessage {return v}
      return 0
    }
    set {subMessage = .sessionID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case sessionID(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: MISessionStopped.OneOf_SubMessage, rhs: MISessionStopped.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sessionID, .sessionID): return {
        guard case .sessionID(let l) = lhs, case .sessionID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

struct NFCSEState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var devicePubKeyState: NFCSEDevicePubKeyState_E = .nfcsecDevicepubkeyStateNone

  var vehiclePubKeyState: NFCSEVehiclePubKeyState_E = .nfcsecVehiclepubkeyStateNone

  var sharedSecretState: NFCSESharedSecretState_E = .nfcsecSharedsecretStateNone

  var insecureCommandState: NFCSEInsecureCommandState_E = .nfcsecInsecureCommandStateNone

  var vehiclePubKey: PublicKey {
    get {return _vehiclePubKey ?? PublicKey()}
    set {_vehiclePubKey = newValue}
  }
  /// Returns true if `vehiclePubKey` has been explicitly set.
  var hasVehiclePubKey: Bool {return self._vehiclePubKey != nil}
  /// Clears the value of `vehiclePubKey`. Subsequent reads from it will return its default value.
  mutating func clearVehiclePubKey() {self._vehiclePubKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _vehiclePubKey: PublicKey? = nil
}

struct PermissionChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: PublicKey {
    get {return _key ?? PublicKey()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var permission: [WhitelistKeyPermission_E] = []

  var secondsToBeActive: UInt32 = 0

  var keyRole: Role = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: PublicKey? = nil
}

struct PersonalizationInformation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vin: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PhoneVersionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var osVersionMajor: UInt32 = 0

  var osVersionMinor: UInt32 = 0

  var osVersionPatch: UInt32 = 0

  var appVersionMajor: UInt32 = 0

  var appVersionMinor: UInt32 = 0

  var appVersionPatch: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKeyRaw: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PublicKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publicKey: PublicKey {
    get {return _publicKey ?? PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var publicKeyStatus: PublicKeyStatus_E = .publicKeyStatusNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publicKey: PublicKey? = nil
}

struct RCISignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: Data = Data()

  var tag: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ReplaceKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyToAdd: PublicKey {
    get {return _keyToAdd ?? PublicKey()}
    set {_keyToAdd = newValue}
  }
  /// Returns true if `keyToAdd` has been explicitly set.
  var hasKeyToAdd: Bool {return self._keyToAdd != nil}
  /// Clears the value of `keyToAdd`. Subsequent reads from it will return its default value.
  mutating func clearKeyToAdd() {self._keyToAdd = nil}

  var keyRole: Role = .none

  var impermanent: Bool = false

  var subMessage: ReplaceKey.OneOf_SubMessage? = nil

  var publicKeyToReplace: PublicKey {
    get {
      if case .publicKeyToReplace(let v)? = subMessage {return v}
      return PublicKey()
    }
    set {subMessage = .publicKeyToReplace(newValue)}
  }

  var slotToReplace: UInt32 {
    get {
      if case .slotToReplace(let v)? = subMessage {return v}
      return 0
    }
    set {subMessage = .slotToReplace(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case publicKeyToReplace(PublicKey)
    case slotToReplace(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: ReplaceKey.OneOf_SubMessage, rhs: ReplaceKey.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.publicKeyToReplace, .publicKeyToReplace): return {
        guard case .publicKeyToReplace(let l) = lhs, case .publicKeyToReplace(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.slotToReplace, .slotToReplace): return {
        guard case .slotToReplace(let l) = lhs, case .slotToReplace(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _keyToAdd: PublicKey? = nil
}

struct ResetTrackerStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totalResetsDueToPowerOn: UInt32 = 0

  var totalResetsDueToPinReset: UInt32 = 0

  var totalResetsDueToVddsloss: UInt32 = 0

  var totalResetsDueToVddloss: UInt32 = 0

  var totalResetsDueToVddrloss: UInt32 = 0

  var totalResetsDueToClockLoss: UInt32 = 0

  var totalResetsDueToSystemReset: UInt32 = 0

  var totalResetsDueToWarmReset: UInt32 = 0

  var totalResetsDueToWakeupFromShutdown: UInt32 = 0

  var totalResetsDueToWakeupFromTcknoise: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RFMonitorCounterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rfinterruptCounter: UInt32 = 0

  var advCompleteCounter: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SetTPConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var config: TPConfiguration {
    get {return _config ?? TPConfiguration()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {self._config = nil}

  var permanentConfig: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _config: TPConfiguration? = nil
}

struct SetUpdaterLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updaterLocation: UpdaterLocation = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Signatures {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct SessionInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var counter: UInt32 = 0

    var publicKey: Data = Data()

    var epoch: Data = Data()

    var clockTime: UInt32 = 0

    var status: Session_Info_Status = .ok

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct SignedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var token: Data = Data()

  var protobufMessageAsBytes: Data = Data()

  var signatureType: SignatureType = .aesGcm

  var signature: Data = Data()

  var keyID: Data = Data()

  var counter: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SignedMessage_status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var counter: UInt32 = 0

  var signedMessageInformation: SignedMessage_information_E = .signedmessageInformationNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SleepManagerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: SleepManagerRequest.OneOf_SubMessage? = nil

  var delaySleepRequest: DelaySleepRequest {
    get {
      if case .delaySleepRequest(let v)? = subMessage {return v}
      return DelaySleepRequest()
    }
    set {subMessage = .delaySleepRequest(newValue)}
  }

  var sleepManagerCommand: SleepManagerCommand_E {
    get {
      if case .sleepManagerCommand(let v)? = subMessage {return v}
      return .sleepmanagerCommandNone
    }
    set {subMessage = .sleepManagerCommand(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case delaySleepRequest(DelaySleepRequest)
    case sleepManagerCommand(SleepManagerCommand_E)

  #if !swift(>=4.1)
    static func ==(lhs: SleepManagerRequest.OneOf_SubMessage, rhs: SleepManagerRequest.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.delaySleepRequest, .delaySleepRequest): return {
        guard case .delaySleepRequest(let l) = lhs, case .delaySleepRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sleepManagerCommand, .sleepManagerCommand): return {
        guard case .sleepManagerCommand(let l) = lhs, case .sleepManagerCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct SleepManagerStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totalCputime: UInt32 = 0

  var totalAwakeTime: UInt32 = 0

  var isBletrimApplied: BLEAdditionalTRIMApplied_E = .bleAdditionalTrimAppliedNone

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StageBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockAddress: UInt32 = 0

  var blockToStage: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ToRCI {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: Data = Data()

  var subMessage: ToRCI.OneOf_SubMessage? = nil

  var hmacSignature: Data {
    get {
      if case .hmacSignature(let v)? = subMessage {return v}
      return Data()
    }
    set {subMessage = .hmacSignature(newValue)}
  }

  var rciSignature: RCISignature {
    get {
      if case .rciSignature(let v)? = subMessage {return v}
      return RCISignature()
    }
    set {subMessage = .rciSignature(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case hmacSignature(Data)
    case rciSignature(RCISignature)

  #if !swift(>=4.1)
    static func ==(lhs: ToRCI.OneOf_SubMessage, rhs: ToRCI.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hmacSignature, .hmacSignature): return {
        guard case .hmacSignature(let l) = lhs, case .hmacSignature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rciSignature, .rciSignature): return {
        guard case .rciSignature(let l) = lhs, case .rciSignature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct ToVCSECMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: ToVCSECMessage.OneOf_SubMessage? = nil

  var signedMessage: SignedMessage {
    get {
      if case .signedMessage(let v)? = subMessage {return v}
      return SignedMessage()
    }
    set {subMessage = .signedMessage(newValue)}
  }

  var unsignedMessage: UnsignedMessage {
    get {
      if case .unsignedMessage(let v)? = subMessage {return v}
      return UnsignedMessage()
    }
    set {subMessage = .unsignedMessage(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case signedMessage(SignedMessage)
    case unsignedMessage(UnsignedMessage)

  #if !swift(>=4.1)
    static func ==(lhs: ToVCSECMessage.OneOf_SubMessage, rhs: ToVCSECMessage.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.signedMessage, .signedMessage): return {
        guard case .signedMessage(let l) = lhs, case .signedMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unsignedMessage, .unsignedMessage): return {
        guard case .unsignedMessage(let l) = lhs, case .unsignedMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct TPAdv {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pressure: Int32 = 0

  var temperature: Int32 = 0

  var tpnotifyReason: TPNotifyReason_E = .tpNotifyReasonUnknown

  var batteryVoltageMV: UInt32 = 0

  var advertismentCount: UInt32 = 0

  var tpmsadvType: TPMSAdvType_E = .tpmsAdvTypeSemi

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TPCapabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pressureInAdv: Bool = false

  var configurableIntervalThreshold: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TPConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: TPConfiguration.OneOf_SubMessage? = nil

  var stationaryConfig: TPStationaryConfig {
    get {
      if case .stationaryConfig(let v)? = subMessage {return v}
      return TPStationaryConfig()
    }
    set {subMessage = .stationaryConfig(newValue)}
  }

  var motionConfig: TPMotionConfig {
    get {
      if case .motionConfig(let v)? = subMessage {return v}
      return TPMotionConfig()
    }
    set {subMessage = .motionConfig(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case stationaryConfig(TPStationaryConfig)
    case motionConfig(TPMotionConfig)

  #if !swift(>=4.1)
    static func ==(lhs: TPConfiguration.OneOf_SubMessage, rhs: TPConfiguration.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stationaryConfig, .stationaryConfig): return {
        guard case .stationaryConfig(let l) = lhs, case .stationaryConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.motionConfig, .motionConfig): return {
        guard case .motionConfig(let l) = lhs, case .motionConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct TPData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pressure: Int32 = 0

  var temperature: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TPLRDetection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lrdetectionResult: LRDetectionResult_E = .rrorMaxcnt

  var totalPeriodMs: UInt32 = 0

  var x90DegCnt: UInt32 = 0

  var x270DegCnt: UInt32 = 0

  var zAccelerationDg: Int32 = 0

  var zAccelDiffCnt: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TPMotionConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pressureDelta: UInt32 = 0

  var temperatureDelta: UInt32 = 0

  var motionPeriod: MLXWakePeriod_E = .mlxwakeperiod2Ms

  var accelMeasureMod: UInt32 = 0

  var ptmeasureMod: UInt32 = 0

  var motionDuration: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TPMSAlarms {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pressure: Bool = false

  var temperature: Bool = false

  var acceleration: Bool = false

  var voltage: Bool = false

  var lfdetect: Bool = false

  var wheelMotion: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TPNewSensorData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sensorPublicKey: PublicKey {
    get {return _sensorPublicKey ?? PublicKey()}
    set {_sensorPublicKey = newValue}
  }
  /// Returns true if `sensorPublicKey` has been explicitly set.
  var hasSensorPublicKey: Bool {return self._sensorPublicKey != nil}
  /// Clears the value of `sensorPublicKey`. Subsequent reads from it will return its default value.
  mutating func clearSensorPublicKey() {self._sensorPublicKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sensorPublicKey: PublicKey? = nil
}

struct TPNotifyTrackerStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var notifyReasonUnknownCount: UInt32 = 0

  var notifyReasonLowPressureCount: UInt32 = 0

  var notifyReasonPtvalueUpdateCount: UInt32 = 0

  var notifyReasonWheelMovingCount: UInt32 = 0

  var notifyReasonWheelRotationDirectionReadyCount: UInt32 = 0

  var notifyReasonLfcount: UInt32 = 0

  var notifyReasonFaultCount: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TPStationaryConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lowPressureThreshold: UInt32 = 0

  var pressureDelta: UInt32 = 0

  var stationaryTaskPeriod: MLXWakePeriod_E = .mlxwakeperiod2Ms

  var pressureMeasureMod: UInt32 = 0

  var accelMeasureMod: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TPWheelUnitInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tiappCrc: Data = Data()

  var mlxappCrc: Data = Data()

  var batteryVoltageMV: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UnknownKeyInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyStatus: KeyStatus {
    get {return _keyStatus ?? KeyStatus()}
    set {_keyStatus = newValue}
  }
  /// Returns true if `keyStatus` has been explicitly set.
  var hasKeyStatus: Bool {return self._keyStatus != nil}
  /// Clears the value of `keyStatus`. Subsequent reads from it will return its default value.
  mutating func clearKeyStatus() {self._keyStatus = nil}

  var publicKey: PublicKey {
    get {return _publicKey ?? PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var keyFormFactor: KeyFormFactor = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyStatus: KeyStatus? = nil
  fileprivate var _publicKey: PublicKey? = nil
}

struct UnsecureNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var notifyUser: Bool = false

  var closureStatuses: ClosureStatuses {
    get {return _closureStatuses ?? ClosureStatuses()}
    set {_closureStatuses = newValue}
  }
  /// Returns true if `closureStatuses` has been explicitly set.
  var hasClosureStatuses: Bool {return self._closureStatuses != nil}
  /// Clears the value of `closureStatuses`. Subsequent reads from it will return its default value.
  mutating func clearClosureStatuses() {self._closureStatuses = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _closureStatuses: ClosureStatuses? = nil
}

struct UnsignedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var personalizationInformation: PersonalizationInformation {
    get {return _personalizationInformation ?? PersonalizationInformation()}
    set {_personalizationInformation = newValue}
  }
  /// Returns true if `personalizationInformation` has been explicitly set.
  var hasPersonalizationInformation: Bool {return self._personalizationInformation != nil}
  /// Clears the value of `personalizationInformation`. Subsequent reads from it will return its default value.
  mutating func clearPersonalizationInformation() {self._personalizationInformation = nil}

  var subMessage: UnsignedMessage.OneOf_SubMessage? = nil

  var informationRequest: InformationRequest {
    get {
      if case .informationRequest(let v)? = subMessage {return v}
      return InformationRequest()
    }
    set {subMessage = .informationRequest(newValue)}
  }

  var rkeaction: RKEAction_E {
    get {
      if case .rkeaction(let v)? = subMessage {return v}
      return .rkeActionUnlock
    }
    set {subMessage = .rkeaction(newValue)}
  }

  var authenticationResponse: AuthenticationResponse {
    get {
      if case .authenticationResponse(let v)? = subMessage {return v}
      return AuthenticationResponse()
    }
    set {subMessage = .authenticationResponse(newValue)}
  }

  var closureMoveRequest: ClosureMoveRequest {
    get {
      if case .closureMoveRequest(let v)? = subMessage {return v}
      return ClosureMoveRequest()
    }
    set {subMessage = .closureMoveRequest(newValue)}
  }

  var tpadv: TPAdv {
    get {
      if case .tpadv(let v)? = subMessage {return v}
      return TPAdv()
    }
    set {subMessage = .tpadv(newValue)}
  }

  var whitelistOperation: WhitelistOperation {
    get {
      if case .whitelistOperation(let v)? = subMessage {return v}
      return WhitelistOperation()
    }
    set {subMessage = .whitelistOperation(newValue)}
  }

  var updaterResponse: UpdaterResponse {
    get {
      if case .updaterResponse(let v)? = subMessage {return v}
      return UpdaterResponse()
    }
    set {subMessage = .updaterResponse(newValue)}
  }

  var genealogyResponse: GenealogyResponse {
    get {
      if case .genealogyResponse(let v)? = subMessage {return v}
      return GenealogyResponse()
    }
    set {subMessage = .genealogyResponse(newValue)}
  }

  var setMetaDataForKey: KeyMetadata {
    get {
      if case .setMetaDataForKey(let v)? = subMessage {return v}
      return KeyMetadata()
    }
    set {subMessage = .setMetaDataForKey(newValue)}
  }

  var keyfobInfo: KeyfobInfo {
    get {
      if case .keyfobInfo(let v)? = subMessage {return v}
      return KeyfobInfo()
    }
    set {subMessage = .keyfobInfo(newValue)}
  }

  var imustate: IMUState_E {
    get {
      if case .imustate(let v)? = subMessage {return v}
      return .imuStateNotConfigured
    }
    set {subMessage = .imustate(newValue)}
  }

  var nfcseState: NFCSEState {
    get {
      if case .nfcseState(let v)? = subMessage {return v}
      return NFCSEState()
    }
    set {subMessage = .nfcseState(newValue)}
  }

  var lowPowerDeviceSleepManagerStats: SleepManagerStats {
    get {
      if case .lowPowerDeviceSleepManagerStats(let v)? = subMessage {return v}
      return SleepManagerStats()
    }
    set {subMessage = .lowPowerDeviceSleepManagerStats(newValue)}
  }

  var tpdata: TPData {
    get {
      if case .tpdata(let v)? = subMessage {return v}
      return TPData()
    }
    set {subMessage = .tpdata(newValue)}
  }

  var tpwheelUnitInfo: TPWheelUnitInfo {
    get {
      if case .tpwheelUnitInfo(let v)? = subMessage {return v}
      return TPWheelUnitInfo()
    }
    set {subMessage = .tpwheelUnitInfo(newValue)}
  }

  var resetTrackerStats: ResetTrackerStats {
    get {
      if case .resetTrackerStats(let v)? = subMessage {return v}
      return ResetTrackerStats()
    }
    set {subMessage = .resetTrackerStats(newValue)}
  }

  var tpnotifyTrackerStats: TPNotifyTrackerStats {
    get {
      if case .tpnotifyTrackerStats(let v)? = subMessage {return v}
      return TPNotifyTrackerStats()
    }
    set {subMessage = .tpnotifyTrackerStats(newValue)}
  }

  var tpnewSensorData: TPNewSensorData {
    get {
      if case .tpnewSensorData(let v)? = subMessage {return v}
      return TPNewSensorData()
    }
    set {subMessage = .tpnewSensorData(newValue)}
  }

  var tplrdetection: TPLRDetection {
    get {
      if case .tplrdetection(let v)? = subMessage {return v}
      return TPLRDetection()
    }
    set {subMessage = .tplrdetection(newValue)}
  }

  var connectionMetrics: ConnectionMetrics {
    get {
      if case .connectionMetrics(let v)? = subMessage {return v}
      return ConnectionMetrics()
    }
    set {subMessage = .connectionMetrics(newValue)}
  }

  var deviceActivity: Activity_E {
    get {
      if case .deviceActivity(let v)? = subMessage {return v}
      return .activityNone
    }
    set {subMessage = .deviceActivity(newValue)}
  }

  var getEpochSessionInfo: GetSessionInfoRequest {
    get {
      if case .getEpochSessionInfo(let v)? = subMessage {return v}
      return GetSessionInfoRequest()
    }
    set {subMessage = .getEpochSessionInfo(newValue)}
  }

  var fromRciresponse: FromRCI {
    get {
      if case .fromRciresponse(let v)? = subMessage {return v}
      return FromRCI()
    }
    set {subMessage = .fromRciresponse(newValue)}
  }

  var bleconfigAll: BLEConfigAll {
    get {
      if case .bleconfigAll(let v)? = subMessage {return v}
      return BLEConfigAll()
    }
    set {subMessage = .bleconfigAll(newValue)}
  }

  var deviceMotion: DeviceMotion {
    get {
      if case .deviceMotion(let v)? = subMessage {return v}
      return DeviceMotion()
    }
    set {subMessage = .deviceMotion(newValue)}
  }

  var appDeviceInfo: AppDeviceInfo {
    get {
      if case .appDeviceInfo(let v)? = subMessage {return v}
      return AppDeviceInfo()
    }
    set {subMessage = .appDeviceInfo(newValue)}
  }

  var getReaderKey: GetReaderKey {
    get {
      if case .getReaderKey(let v)? = subMessage {return v}
      return GetReaderKey()
    }
    set {subMessage = .getReaderKey(newValue)}
  }

  var misessionResponse: MISessionResponse {
    get {
      if case .misessionResponse(let v)? = subMessage {return v}
      return MISessionResponse()
    }
    set {subMessage = .misessionResponse(newValue)}
  }

  var misessionStopped: MISessionStopped {
    get {
      if case .misessionStopped(let v)? = subMessage {return v}
      return MISessionStopped()
    }
    set {subMessage = .misessionStopped(newValue)}
  }

  var accelData: AccelData {
    get {
      if case .accelData(let v)? = subMessage {return v}
      return AccelData()
    }
    set {subMessage = .accelData(newValue)}
  }

  var tpmsalarms: TPMSAlarms {
    get {
      if case .tpmsalarms(let v)? = subMessage {return v}
      return TPMSAlarms()
    }
    set {subMessage = .tpmsalarms(newValue)}
  }

  var certificateResponse: CertificateResponse {
    get {
      if case .certificateResponse(let v)? = subMessage {return v}
      return CertificateResponse()
    }
    set {subMessage = .certificateResponse(newValue)}
  }

  var challengeResponse: ChallengeResponse {
    get {
      if case .challengeResponse(let v)? = subMessage {return v}
      return ChallengeResponse()
    }
    set {subMessage = .challengeResponse(newValue)}
  }

  var publicKeyResponse: PublicKeyResponse {
    get {
      if case .publicKeyResponse(let v)? = subMessage {return v}
      return PublicKeyResponse()
    }
    set {subMessage = .publicKeyResponse(newValue)}
  }

  var asicspiread: ASICSPIRead {
    get {
      if case .asicspiread(let v)? = subMessage {return v}
      return ASICSPIRead()
    }
    set {subMessage = .asicspiread(newValue)}
  }

  var rfmonitorCounterResponse: RFMonitorCounterResponse {
    get {
      if case .rfmonitorCounterResponse(let v)? = subMessage {return v}
      return RFMonitorCounterResponse()
    }
    set {subMessage = .rfmonitorCounterResponse(newValue)}
  }

  var blenickName: VehicleBLENickName {
    get {
      if case .blenickName(let v)? = subMessage {return v}
      return VehicleBLENickName()
    }
    set {subMessage = .blenickName(newValue)}
  }

  var tpconfiguration: TPConfiguration {
    get {
      if case .tpconfiguration(let v)? = subMessage {return v}
      return TPConfiguration()
    }
    set {subMessage = .tpconfiguration(newValue)}
  }

  var tpcapabilities: TPCapabilities {
    get {
      if case .tpcapabilities(let v)? = subMessage {return v}
      return TPCapabilities()
    }
    set {subMessage = .tpcapabilities(newValue)}
  }

  var appEventLog: AppEventLog {
    get {
      if case .appEventLog(let v)? = subMessage {return v}
      return AppEventLog()
    }
    set {subMessage = .appEventLog(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case informationRequest(InformationRequest)
    case rkeaction(RKEAction_E)
    case authenticationResponse(AuthenticationResponse)
    case closureMoveRequest(ClosureMoveRequest)
    case tpadv(TPAdv)
    case whitelistOperation(WhitelistOperation)
    case updaterResponse(UpdaterResponse)
    case genealogyResponse(GenealogyResponse)
    case setMetaDataForKey(KeyMetadata)
    case keyfobInfo(KeyfobInfo)
    case imustate(IMUState_E)
    case nfcseState(NFCSEState)
    case lowPowerDeviceSleepManagerStats(SleepManagerStats)
    case tpdata(TPData)
    case tpwheelUnitInfo(TPWheelUnitInfo)
    case resetTrackerStats(ResetTrackerStats)
    case tpnotifyTrackerStats(TPNotifyTrackerStats)
    case tpnewSensorData(TPNewSensorData)
    case tplrdetection(TPLRDetection)
    case connectionMetrics(ConnectionMetrics)
    case deviceActivity(Activity_E)
    case getEpochSessionInfo(GetSessionInfoRequest)
    case fromRciresponse(FromRCI)
    case bleconfigAll(BLEConfigAll)
    case deviceMotion(DeviceMotion)
    case appDeviceInfo(AppDeviceInfo)
    case getReaderKey(GetReaderKey)
    case misessionResponse(MISessionResponse)
    case misessionStopped(MISessionStopped)
    case accelData(AccelData)
    case tpmsalarms(TPMSAlarms)
    case certificateResponse(CertificateResponse)
    case challengeResponse(ChallengeResponse)
    case publicKeyResponse(PublicKeyResponse)
    case asicspiread(ASICSPIRead)
    case rfmonitorCounterResponse(RFMonitorCounterResponse)
    case blenickName(VehicleBLENickName)
    case tpconfiguration(TPConfiguration)
    case tpcapabilities(TPCapabilities)
    case appEventLog(AppEventLog)

  #if !swift(>=4.1)
    static func ==(lhs: UnsignedMessage.OneOf_SubMessage, rhs: UnsignedMessage.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.informationRequest, .informationRequest): return {
        guard case .informationRequest(let l) = lhs, case .informationRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rkeaction, .rkeaction): return {
        guard case .rkeaction(let l) = lhs, case .rkeaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.authenticationResponse, .authenticationResponse): return {
        guard case .authenticationResponse(let l) = lhs, case .authenticationResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.closureMoveRequest, .closureMoveRequest): return {
        guard case .closureMoveRequest(let l) = lhs, case .closureMoveRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpadv, .tpadv): return {
        guard case .tpadv(let l) = lhs, case .tpadv(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whitelistOperation, .whitelistOperation): return {
        guard case .whitelistOperation(let l) = lhs, case .whitelistOperation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updaterResponse, .updaterResponse): return {
        guard case .updaterResponse(let l) = lhs, case .updaterResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.genealogyResponse, .genealogyResponse): return {
        guard case .genealogyResponse(let l) = lhs, case .genealogyResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setMetaDataForKey, .setMetaDataForKey): return {
        guard case .setMetaDataForKey(let l) = lhs, case .setMetaDataForKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keyfobInfo, .keyfobInfo): return {
        guard case .keyfobInfo(let l) = lhs, case .keyfobInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.imustate, .imustate): return {
        guard case .imustate(let l) = lhs, case .imustate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nfcseState, .nfcseState): return {
        guard case .nfcseState(let l) = lhs, case .nfcseState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lowPowerDeviceSleepManagerStats, .lowPowerDeviceSleepManagerStats): return {
        guard case .lowPowerDeviceSleepManagerStats(let l) = lhs, case .lowPowerDeviceSleepManagerStats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpdata, .tpdata): return {
        guard case .tpdata(let l) = lhs, case .tpdata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpwheelUnitInfo, .tpwheelUnitInfo): return {
        guard case .tpwheelUnitInfo(let l) = lhs, case .tpwheelUnitInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resetTrackerStats, .resetTrackerStats): return {
        guard case .resetTrackerStats(let l) = lhs, case .resetTrackerStats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpnotifyTrackerStats, .tpnotifyTrackerStats): return {
        guard case .tpnotifyTrackerStats(let l) = lhs, case .tpnotifyTrackerStats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpnewSensorData, .tpnewSensorData): return {
        guard case .tpnewSensorData(let l) = lhs, case .tpnewSensorData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tplrdetection, .tplrdetection): return {
        guard case .tplrdetection(let l) = lhs, case .tplrdetection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.connectionMetrics, .connectionMetrics): return {
        guard case .connectionMetrics(let l) = lhs, case .connectionMetrics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deviceActivity, .deviceActivity): return {
        guard case .deviceActivity(let l) = lhs, case .deviceActivity(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getEpochSessionInfo, .getEpochSessionInfo): return {
        guard case .getEpochSessionInfo(let l) = lhs, case .getEpochSessionInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fromRciresponse, .fromRciresponse): return {
        guard case .fromRciresponse(let l) = lhs, case .fromRciresponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bleconfigAll, .bleconfigAll): return {
        guard case .bleconfigAll(let l) = lhs, case .bleconfigAll(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deviceMotion, .deviceMotion): return {
        guard case .deviceMotion(let l) = lhs, case .deviceMotion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appDeviceInfo, .appDeviceInfo): return {
        guard case .appDeviceInfo(let l) = lhs, case .appDeviceInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getReaderKey, .getReaderKey): return {
        guard case .getReaderKey(let l) = lhs, case .getReaderKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.misessionResponse, .misessionResponse): return {
        guard case .misessionResponse(let l) = lhs, case .misessionResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.misessionStopped, .misessionStopped): return {
        guard case .misessionStopped(let l) = lhs, case .misessionStopped(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accelData, .accelData): return {
        guard case .accelData(let l) = lhs, case .accelData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpmsalarms, .tpmsalarms): return {
        guard case .tpmsalarms(let l) = lhs, case .tpmsalarms(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.certificateResponse, .certificateResponse): return {
        guard case .certificateResponse(let l) = lhs, case .certificateResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.challengeResponse, .challengeResponse): return {
        guard case .challengeResponse(let l) = lhs, case .challengeResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publicKeyResponse, .publicKeyResponse): return {
        guard case .publicKeyResponse(let l) = lhs, case .publicKeyResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.asicspiread, .asicspiread): return {
        guard case .asicspiread(let l) = lhs, case .asicspiread(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rfmonitorCounterResponse, .rfmonitorCounterResponse): return {
        guard case .rfmonitorCounterResponse(let l) = lhs, case .rfmonitorCounterResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.blenickName, .blenickName): return {
        guard case .blenickName(let l) = lhs, case .blenickName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpconfiguration, .tpconfiguration): return {
        guard case .tpconfiguration(let l) = lhs, case .tpconfiguration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tpcapabilities, .tpcapabilities): return {
        guard case .tpcapabilities(let l) = lhs, case .tpcapabilities(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appEventLog, .appEventLog): return {
        guard case .appEventLog(let l) = lhs, case .appEventLog(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _personalizationInformation: PersonalizationInformation? = nil
}

struct UpdaterCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: UpdaterCommand.OneOf_SubMessage? = nil

  var getCodeDescriptor: GetCodeDescriptor {
    get {
      if case .getCodeDescriptor(let v)? = subMessage {return v}
      return GetCodeDescriptor()
    }
    set {subMessage = .getCodeDescriptor(newValue)}
  }

  var setUpdaterLocation: SetUpdaterLocation {
    get {
      if case .setUpdaterLocation(let v)? = subMessage {return v}
      return SetUpdaterLocation()
    }
    set {subMessage = .setUpdaterLocation(newValue)}
  }

  var stageBlock: StageBlock {
    get {
      if case .stageBlock(let v)? = subMessage {return v}
      return StageBlock()
    }
    set {subMessage = .stageBlock(newValue)}
  }

  var verifyAndInstallApp: VerifyAndInstallApp {
    get {
      if case .verifyAndInstallApp(let v)? = subMessage {return v}
      return VerifyAndInstallApp()
    }
    set {subMessage = .verifyAndInstallApp(newValue)}
  }

  var firmwareInfo: Data {
    get {
      if case .firmwareInfo(let v)? = subMessage {return v}
      return Data()
    }
    set {subMessage = .firmwareInfo(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case getCodeDescriptor(GetCodeDescriptor)
    case setUpdaterLocation(SetUpdaterLocation)
    case stageBlock(StageBlock)
    case verifyAndInstallApp(VerifyAndInstallApp)
    case firmwareInfo(Data)

  #if !swift(>=4.1)
    static func ==(lhs: UpdaterCommand.OneOf_SubMessage, rhs: UpdaterCommand.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getCodeDescriptor, .getCodeDescriptor): return {
        guard case .getCodeDescriptor(let l) = lhs, case .getCodeDescriptor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setUpdaterLocation, .setUpdaterLocation): return {
        guard case .setUpdaterLocation(let l) = lhs, case .setUpdaterLocation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stageBlock, .stageBlock): return {
        guard case .stageBlock(let l) = lhs, case .stageBlock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.verifyAndInstallApp, .verifyAndInstallApp): return {
        guard case .verifyAndInstallApp(let l) = lhs, case .verifyAndInstallApp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.firmwareInfo, .firmwareInfo): return {
        guard case .firmwareInfo(let l) = lhs, case .firmwareInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct UpdaterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subMessage: UpdaterResponse.OneOf_SubMessage? = nil

  var codeDescriptorMessage: CodeDescriptor {
    get {
      if case .codeDescriptorMessage(let v)? = subMessage {return v}
      return CodeDescriptor()
    }
    set {subMessage = .codeDescriptorMessage(newValue)}
  }

  var updaterStatus: UpdaterStatus {
    get {
      if case .updaterStatus(let v)? = subMessage {return v}
      return UpdaterStatus()
    }
    set {subMessage = .updaterStatus(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case codeDescriptorMessage(CodeDescriptor)
    case updaterStatus(UpdaterStatus)

  #if !swift(>=4.1)
    static func ==(lhs: UpdaterResponse.OneOf_SubMessage, rhs: UpdaterResponse.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.codeDescriptorMessage, .codeDescriptorMessage): return {
        guard case .codeDescriptorMessage(let l) = lhs, case .codeDescriptorMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updaterStatus, .updaterStatus): return {
        guard case .updaterStatus(let l) = lhs, case .updaterStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct UpdaterStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var statusCode: UpdaterStatusCode = .error

  var location: UpdaterLocation = .none

  var nextAddressNumber: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleBLENickName {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nickName: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vin: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VehicleStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var closureStatuses: ClosureStatuses {
    get {return _closureStatuses ?? ClosureStatuses()}
    set {_closureStatuses = newValue}
  }
  /// Returns true if `closureStatuses` has been explicitly set.
  var hasClosureStatuses: Bool {return self._closureStatuses != nil}
  /// Clears the value of `closureStatuses`. Subsequent reads from it will return its default value.
  mutating func clearClosureStatuses() {self._closureStatuses = nil}

  var vehicleLockState: VehicleLockState_E = .vehiclelockstateUnlocked

  var vehicleSleepStatus: VehicleSleepStatus_E = .vehicleSleepStatusUnknown

  var userPresence: UserPresence_E = .vehicleUserPresenceUnknown

  var detailedClosureStatus: DetailedClosureStatus {
    get {return _detailedClosureStatus ?? DetailedClosureStatus()}
    set {_detailedClosureStatus = newValue}
  }
  /// Returns true if `detailedClosureStatus` has been explicitly set.
  var hasDetailedClosureStatus: Bool {return self._detailedClosureStatus != nil}
  /// Clears the value of `detailedClosureStatus`. Subsequent reads from it will return its default value.
  mutating func clearDetailedClosureStatus() {self._detailedClosureStatus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _closureStatuses: ClosureStatuses? = nil
  fileprivate var _detailedClosureStatus: DetailedClosureStatus? = nil
}

struct VerifyAndInstallApp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sha256: Data = Data()

  var rValue: Data = Data()

  var sValue: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct WhitelistEntryInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyID: KeyIdentifier {
    get {return _keyID ?? KeyIdentifier()}
    set {_keyID = newValue}
  }
  /// Returns true if `keyID` has been explicitly set.
  var hasKeyID: Bool {return self._keyID != nil}
  /// Clears the value of `keyID`. Subsequent reads from it will return its default value.
  mutating func clearKeyID() {self._keyID = nil}

  var publicKey: PublicKey {
    get {return _publicKey ?? PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var permissions: [WhitelistKeyPermission_E] = []

  var metadataForKey: KeyMetadata {
    get {return _metadataForKey ?? KeyMetadata()}
    set {_metadataForKey = newValue}
  }
  /// Returns true if `metadataForKey` has been explicitly set.
  var hasMetadataForKey: Bool {return self._metadataForKey != nil}
  /// Clears the value of `metadataForKey`. Subsequent reads from it will return its default value.
  mutating func clearMetadataForKey() {self._metadataForKey = nil}

  var secondsEntryRemainsActive: UInt32 = 0

  var slot: UInt32 = 0

  var keyRole: Role = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _keyID: KeyIdentifier? = nil
  fileprivate var _publicKey: PublicKey? = nil
  fileprivate var _metadataForKey: KeyMetadata? = nil
}

struct WhitelistInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var numberOfEntries: UInt32 = 0

  var whitelistEntries: [KeyIdentifier] = []

  var slotMask: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct WhitelistOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var metadataForKey: KeyMetadata {
    get {return _metadataForKey ?? KeyMetadata()}
    set {_metadataForKey = newValue}
  }
  /// Returns true if `metadataForKey` has been explicitly set.
  var hasMetadataForKey: Bool {return self._metadataForKey != nil}
  /// Clears the value of `metadataForKey`. Subsequent reads from it will return its default value.
  mutating func clearMetadataForKey() {self._metadataForKey = nil}

  var subMessage: WhitelistOperation.OneOf_SubMessage? = nil

  var addPublicKeyToWhitelist: PublicKey {
    get {
      if case .addPublicKeyToWhitelist(let v)? = subMessage {return v}
      return PublicKey()
    }
    set {subMessage = .addPublicKeyToWhitelist(newValue)}
  }

  var removePublicKeyFromWhitelist: PublicKey {
    get {
      if case .removePublicKeyFromWhitelist(let v)? = subMessage {return v}
      return PublicKey()
    }
    set {subMessage = .removePublicKeyFromWhitelist(newValue)}
  }

  var addPermissionsToPublicKey: PermissionChange {
    get {
      if case .addPermissionsToPublicKey(let v)? = subMessage {return v}
      return PermissionChange()
    }
    set {subMessage = .addPermissionsToPublicKey(newValue)}
  }

  var removePermissionsFromPublicKey: PermissionChange {
    get {
      if case .removePermissionsFromPublicKey(let v)? = subMessage {return v}
      return PermissionChange()
    }
    set {subMessage = .removePermissionsFromPublicKey(newValue)}
  }

  var addKeyToWhitelistAndAddPermissions: PermissionChange {
    get {
      if case .addKeyToWhitelistAndAddPermissions(let v)? = subMessage {return v}
      return PermissionChange()
    }
    set {subMessage = .addKeyToWhitelistAndAddPermissions(newValue)}
  }

  var updateKeyAndPermissions: PermissionChange {
    get {
      if case .updateKeyAndPermissions(let v)? = subMessage {return v}
      return PermissionChange()
    }
    set {subMessage = .updateKeyAndPermissions(newValue)}
  }

  var addImpermanentKey: PermissionChange {
    get {
      if case .addImpermanentKey(let v)? = subMessage {return v}
      return PermissionChange()
    }
    set {subMessage = .addImpermanentKey(newValue)}
  }

  var addImpermanentKeyAndRemoveExisting: PermissionChange {
    get {
      if case .addImpermanentKeyAndRemoveExisting(let v)? = subMessage {return v}
      return PermissionChange()
    }
    set {subMessage = .addImpermanentKeyAndRemoveExisting(newValue)}
  }

  var removeAllImpermanentKeys: Bool {
    get {
      if case .removeAllImpermanentKeys(let v)? = subMessage {return v}
      return false
    }
    set {subMessage = .removeAllImpermanentKeys(newValue)}
  }

  var replaceKey: ReplaceKey {
    get {
      if case .replaceKey(let v)? = subMessage {return v}
      return ReplaceKey()
    }
    set {subMessage = .replaceKey(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SubMessage: Equatable {
    case addPublicKeyToWhitelist(PublicKey)
    case removePublicKeyFromWhitelist(PublicKey)
    case addPermissionsToPublicKey(PermissionChange)
    case removePermissionsFromPublicKey(PermissionChange)
    case addKeyToWhitelistAndAddPermissions(PermissionChange)
    case updateKeyAndPermissions(PermissionChange)
    case addImpermanentKey(PermissionChange)
    case addImpermanentKeyAndRemoveExisting(PermissionChange)
    case removeAllImpermanentKeys(Bool)
    case replaceKey(ReplaceKey)

  #if !swift(>=4.1)
    static func ==(lhs: WhitelistOperation.OneOf_SubMessage, rhs: WhitelistOperation.OneOf_SubMessage) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.addPublicKeyToWhitelist, .addPublicKeyToWhitelist): return {
        guard case .addPublicKeyToWhitelist(let l) = lhs, case .addPublicKeyToWhitelist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removePublicKeyFromWhitelist, .removePublicKeyFromWhitelist): return {
        guard case .removePublicKeyFromWhitelist(let l) = lhs, case .removePublicKeyFromWhitelist(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addPermissionsToPublicKey, .addPermissionsToPublicKey): return {
        guard case .addPermissionsToPublicKey(let l) = lhs, case .addPermissionsToPublicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removePermissionsFromPublicKey, .removePermissionsFromPublicKey): return {
        guard case .removePermissionsFromPublicKey(let l) = lhs, case .removePermissionsFromPublicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addKeyToWhitelistAndAddPermissions, .addKeyToWhitelistAndAddPermissions): return {
        guard case .addKeyToWhitelistAndAddPermissions(let l) = lhs, case .addKeyToWhitelistAndAddPermissions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateKeyAndPermissions, .updateKeyAndPermissions): return {
        guard case .updateKeyAndPermissions(let l) = lhs, case .updateKeyAndPermissions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addImpermanentKey, .addImpermanentKey): return {
        guard case .addImpermanentKey(let l) = lhs, case .addImpermanentKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addImpermanentKeyAndRemoveExisting, .addImpermanentKeyAndRemoveExisting): return {
        guard case .addImpermanentKeyAndRemoveExisting(let l) = lhs, case .addImpermanentKeyAndRemoveExisting(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeAllImpermanentKeys, .removeAllImpermanentKeys): return {
        guard case .removeAllImpermanentKeys(let l) = lhs, case .removeAllImpermanentKeys(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.replaceKey, .replaceKey): return {
        guard case .replaceKey(let l) = lhs, case .replaceKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _metadataForKey: KeyMetadata? = nil
}

struct WhitelistOperation_status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var whitelistOperationInformation: WhitelistOperation_information_E = .whitelistoperationInformationNone

  var signerOfOperation: KeyIdentifier {
    get {return _signerOfOperation ?? KeyIdentifier()}
    set {_signerOfOperation = newValue}
  }
  /// Returns true if `signerOfOperation` has been explicitly set.
  var hasSignerOfOperation: Bool {return self._signerOfOperation != nil}
  /// Clears the value of `signerOfOperation`. Subsequent reads from it will return its default value.
  mutating func clearSignerOfOperation() {self._signerOfOperation = nil}

  var operationStatus: OperationStatus_E = .operationstatusOk

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signerOfOperation: KeyIdentifier? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Activity_E: @unchecked Sendable {}
extension AlertConfirmation: @unchecked Sendable {}
extension AppDeviceInfoRequest_E: @unchecked Sendable {}
extension AppOperatingSystem: @unchecked Sendable {}
extension AuthenticationLevel_E: @unchecked Sendable {}
extension AuthenticationReason_E: @unchecked Sendable {}
extension AuthenticationRejection_E: @unchecked Sendable {}
extension BLEAdditionalTRIMApplied_E: @unchecked Sendable {}
extension BLEConfigCommandType_E: @unchecked Sendable {}
extension BLEPresence: @unchecked Sendable {}
extension CertificateStatus_E: @unchecked Sendable {}
extension ClosureMoveType_E: @unchecked Sendable {}
extension ClosureState_E: @unchecked Sendable {}
extension Device_Motion_Confidence: @unchecked Sendable {}
extension Device_Motion_State: @unchecked Sendable {}
extension GenealogyRequest_E: @unchecked Sendable {}
extension GenealogyStatus_E: @unchecked Sendable {}
extension GetReaderKeyCommand: @unchecked Sendable {}
extension HandlePulled_E: @unchecked Sendable {}
extension IMURequest_E: @unchecked Sendable {}
extension IMUState_E: @unchecked Sendable {}
extension InformationRequestType: @unchecked Sendable {}
extension KeyFormFactor: @unchecked Sendable {}
extension LRDetectionResult_E: @unchecked Sendable {}
extension MIError_E: @unchecked Sendable {}
extension MLXWakePeriod_E: @unchecked Sendable {}
extension NFCPresence: @unchecked Sendable {}
extension NFCSEDevicePubKeyState_E: @unchecked Sendable {}
extension NFCSEInsecureCommandState_E: @unchecked Sendable {}
extension NFCSERequest_E: @unchecked Sendable {}
extension NFCSESharedSecretState_E: @unchecked Sendable {}
extension NFCSEVehiclePubKeyState_E: @unchecked Sendable {}
extension PublicKeyRequest_E: @unchecked Sendable {}
extension PublicKeyStatus_E: @unchecked Sendable {}
extension RCI_control_E: @unchecked Sendable {}
extension ResetTrackerCommand_E: @unchecked Sendable {}
extension RKEAction_E: @unchecked Sendable {}
extension SignatureType: @unchecked Sendable {}
extension SignedMessage_information_E: @unchecked Sendable {}
extension SleepManagerCommand_E: @unchecked Sendable {}
extension TPDataRequest_E: @unchecked Sendable {}
extension TPMSAdvType_E: @unchecked Sendable {}
extension TPNotifyReason_E: @unchecked Sendable {}
extension TPNotifyTrackerCommand_E: @unchecked Sendable {}
extension UIRequest_E: @unchecked Sendable {}
extension UpdaterLocation: @unchecked Sendable {}
extension UpdaterStatusCode: @unchecked Sendable {}
extension UserPresence_E: @unchecked Sendable {}
extension UWBAvailability: @unchecked Sendable {}
extension VehicleLockState_E: @unchecked Sendable {}
extension VehicleSleepStatus_E: @unchecked Sendable {}
extension WhitelistKeyPermission_E: @unchecked Sendable {}
extension WhitelistOperation_information_E: @unchecked Sendable {}
extension AccelData: @unchecked Sendable {}
extension ActiveKey: @unchecked Sendable {}
extension Alert: @unchecked Sendable {}
extension Alert.OneOf_SubMessage: @unchecked Sendable {}
extension AlertHandlePulledWithoutAuth: @unchecked Sendable {}
extension AppDeviceInfo: @unchecked Sendable {}
extension AppEventLog: @unchecked Sendable {}
extension AppEventLog.OneOf_SubMessage: @unchecked Sendable {}
extension AppEventPeerRemovedPairingInformation: @unchecked Sendable {}
extension ASICSPIRead: @unchecked Sendable {}
extension AuthenticationRequest: @unchecked Sendable {}
extension AuthenticationRequestToken: @unchecked Sendable {}
extension AuthenticationResponse: @unchecked Sendable {}
extension BLEConfig: @unchecked Sendable {}
extension BLEConfig.OneOf_SubMessage: @unchecked Sendable {}
extension BLEConfigAll: @unchecked Sendable {}
extension BLEConfigCommand: @unchecked Sendable {}
extension Capabilities: @unchecked Sendable {}
extension Certificate: @unchecked Sendable {}
extension Certificate.OneOf_SubMessage: @unchecked Sendable {}
extension CertificateInParts: @unchecked Sendable {}
extension CertificateRead: @unchecked Sendable {}
extension CertificateResponse: @unchecked Sendable {}
extension ChallengeCommand: @unchecked Sendable {}
extension ChallengeResponse: @unchecked Sendable {}
extension ClosureMoveRequest: @unchecked Sendable {}
extension ClosureStatuses: @unchecked Sendable {}
extension CodeDescriptor: @unchecked Sendable {}
extension CommandStatus: @unchecked Sendable {}
extension CommandStatus.OneOf_SubMessage: @unchecked Sendable {}
extension ConnectionMetrics: @unchecked Sendable {}
extension DelaySleepRequest: @unchecked Sendable {}
extension DetailedClosureStatus: @unchecked Sendable {}
extension DeviceMotion: @unchecked Sendable {}
extension FromRCI: @unchecked Sendable {}
extension FromVCSECMessage: @unchecked Sendable {}
extension FromVCSECMessage.OneOf_SubMessage: @unchecked Sendable {}
extension Genealogy: @unchecked Sendable {}
extension GenealogyResponse: @unchecked Sendable {}
extension GetCodeDescriptor: @unchecked Sendable {}
extension GetReaderKey: @unchecked Sendable {}
extension HandlePulledWithoutAuthDeviceSpecificPayload: @unchecked Sendable {}
extension InformationRequest: @unchecked Sendable {}
extension InformationRequest.OneOf_SubMessage: @unchecked Sendable {}
extension KeyfobInfo: @unchecked Sendable {}
extension KeyIdentifier: @unchecked Sendable {}
extension KeyMetadata: @unchecked Sendable {}
extension KeyStatus: @unchecked Sendable {}
extension KeyStatusInfo: @unchecked Sendable {}
extension MIConfigurationData: @unchecked Sendable {}
extension MISessionRequest: @unchecked Sendable {}
extension MISessionResponse: @unchecked Sendable {}
extension MISessionResponse.OneOf_SubMessage: @unchecked Sendable {}
extension MISessionStop: @unchecked Sendable {}
extension MISessionStop.OneOf_SubMessage: @unchecked Sendable {}
extension MISessionStopped: @unchecked Sendable {}
extension MISessionStopped.OneOf_SubMessage: @unchecked Sendable {}
extension NFCSEState: @unchecked Sendable {}
extension PermissionChange: @unchecked Sendable {}
extension PersonalizationInformation: @unchecked Sendable {}
extension PhoneVersionInfo: @unchecked Sendable {}
extension PublicKey: @unchecked Sendable {}
extension PublicKeyResponse: @unchecked Sendable {}
extension RCISignature: @unchecked Sendable {}
extension ReplaceKey: @unchecked Sendable {}
extension ReplaceKey.OneOf_SubMessage: @unchecked Sendable {}
extension ResetTrackerStats: @unchecked Sendable {}
extension RFMonitorCounterResponse: @unchecked Sendable {}
extension SetTPConfiguration: @unchecked Sendable {}
extension SetUpdaterLocation: @unchecked Sendable {}
extension Signatures: @unchecked Sendable {}
extension Signatures.SessionInfo: @unchecked Sendable {}
extension SignedMessage: @unchecked Sendable {}
extension SignedMessage_status: @unchecked Sendable {}
extension SleepManagerRequest: @unchecked Sendable {}
extension SleepManagerRequest.OneOf_SubMessage: @unchecked Sendable {}
extension SleepManagerStats: @unchecked Sendable {}
extension StageBlock: @unchecked Sendable {}
extension ToRCI: @unchecked Sendable {}
extension ToRCI.OneOf_SubMessage: @unchecked Sendable {}
extension ToVCSECMessage: @unchecked Sendable {}
extension ToVCSECMessage.OneOf_SubMessage: @unchecked Sendable {}
extension TPAdv: @unchecked Sendable {}
extension TPCapabilities: @unchecked Sendable {}
extension TPConfiguration: @unchecked Sendable {}
extension TPConfiguration.OneOf_SubMessage: @unchecked Sendable {}
extension TPData: @unchecked Sendable {}
extension TPLRDetection: @unchecked Sendable {}
extension TPMotionConfig: @unchecked Sendable {}
extension TPMSAlarms: @unchecked Sendable {}
extension TPNewSensorData: @unchecked Sendable {}
extension TPNotifyTrackerStats: @unchecked Sendable {}
extension TPStationaryConfig: @unchecked Sendable {}
extension TPWheelUnitInfo: @unchecked Sendable {}
extension UnknownKeyInfo: @unchecked Sendable {}
extension UnsecureNotification: @unchecked Sendable {}
extension UnsignedMessage: @unchecked Sendable {}
extension UnsignedMessage.OneOf_SubMessage: @unchecked Sendable {}
extension UpdaterCommand: @unchecked Sendable {}
extension UpdaterCommand.OneOf_SubMessage: @unchecked Sendable {}
extension UpdaterResponse: @unchecked Sendable {}
extension UpdaterResponse.OneOf_SubMessage: @unchecked Sendable {}
extension UpdaterStatus: @unchecked Sendable {}
extension VehicleBLENickName: @unchecked Sendable {}
extension VehicleInfo: @unchecked Sendable {}
extension VehicleStatus: @unchecked Sendable {}
extension VerifyAndInstallApp: @unchecked Sendable {}
extension WhitelistEntryInfo: @unchecked Sendable {}
extension WhitelistInfo: @unchecked Sendable {}
extension WhitelistOperation: @unchecked Sendable {}
extension WhitelistOperation.OneOf_SubMessage: @unchecked Sendable {}
extension WhitelistOperation_status: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Activity_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTIVITY_NONE"),
    1: .same(proto: "ACTIVITY_STATIONARY"),
    2: .same(proto: "ACTIVITY_MOTION"),
    3: .same(proto: "ACTIVITY_SIGNIFICANT_MOTION"),
  ]
}

extension AlertConfirmation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALERT_CONFIRMATION_NONE"),
    1: .same(proto: "ALERT_CONFIRMATION_PEER_REMOVED_INFORMATION"),
  ]
}

extension AppDeviceInfoRequest_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_DEVICE_INFO_REQUEST_NONE"),
    1: .same(proto: "APP_DEVICE_INFO_REQUEST_GET_MODEL_NUMBER"),
  ]
}

extension AppOperatingSystem: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ANDROID"),
    2: .same(proto: "IOS"),
  ]
}

extension AuthenticationLevel_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTHENTICATION_LEVEL_NONE"),
    1: .same(proto: "AUTHENTICATION_LEVEL_UNLOCK"),
    2: .same(proto: "AUTHENTICATION_LEVEL_DRIVE"),
  ]
}

extension AuthenticationReason_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTHENTICATIONREASON_NOT_DOCUMENTED"),
    1: .same(proto: "AUTHENTICATIONREASON_IDENTIFICATION"),
    2: .same(proto: "AUTHENTICATIONREASON_POWER_ON_VEHICLE_REQUEST"),
    3: .same(proto: "AUTHENTICATIONREASON_GTW_REQUEST"),
    4: .same(proto: "AUTHENTICATIONREASON_UI_UNLOCK_PASSIVE_AUTH"),
    5: .same(proto: "AUTHENTICATIONREASON_PASSIVE_UNLOCK_EXTERIOR_HANDLE_PULL"),
    6: .same(proto: "AUTHENTICATIONREASON_PASSIVE_UNLOCK_INTERIOR_HANDLE_PULL"),
    7: .same(proto: "AUTHENTICATIONREASON_PASSIVE_UNLOCK_AUTOPRESENT_DOOR"),
    8: .same(proto: "AUTHENTICATIONREASON_ENTERED_HIGHER_AUTH_ZONE"),
    9: .same(proto: "AUTHENTICATIONREASON_WALK_UP_UNLOCK"),
    10: .same(proto: "AUTHENTICATIONREASON_IMMOBILIZER"),
  ]
}

extension AuthenticationRejection_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTHENTICATIONREJECTION_NONE"),
    1: .same(proto: "AUTHENTICATIONREJECTION_DEVICE_STATIONARY"),
    2: .same(proto: "AUTHENTICATIONREJECTION_PASSIVE_DISABLED"),
    3: .same(proto: "AUTHENTICATIONREJECTION_NO_TOKEN"),
  ]
}

extension BLEAdditionalTRIMApplied_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLE_ADDITIONAL_TRIM_APPLIED_NONE"),
    1: .same(proto: "BLE_ADDITIONAL_TRIM_APPLIED_APPLIED"),
    2: .same(proto: "BLE_ADDITIONAL_TRIM_APPLIED_NOT_APPLIED"),
  ]
}

extension BLEConfigCommandType_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLE_CONFIG_COMMAND_TYPE_NONE"),
    1: .same(proto: "BLE_CONFIG_COMMAND_TYPE_READ"),
    2: .same(proto: "BLE_CONFIG_COMMAND_TYPE_WRITE"),
  ]
}

extension BLEPresence: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLE_PRESENCE_NOT_PRESENT"),
    1: .same(proto: "BLE_PRESENCE_PRESENT"),
  ]
}

extension CertificateStatus_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CERTIFICATE_STATUS_NONE"),
    1: .same(proto: "CERITFICATE_STATUS_NOT_WRITTEN"),
    2: .same(proto: "CERTIFICATE_STATUS_WRITTEN"),
  ]
}

extension ClosureMoveType_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLOSURE_MOVE_TYPE_NONE"),
    1: .same(proto: "CLOSURE_MOVE_TYPE_MOVE"),
    2: .same(proto: "CLOSURE_MOVE_TYPE_STOP"),
    3: .same(proto: "CLOSURE_MOVE_TYPE_OPEN"),
    4: .same(proto: "CLOSURE_MOVE_TYPE_CLOSE"),
  ]
}

extension ClosureState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLOSURESTATE_CLOSED"),
    1: .same(proto: "CLOSURESTATE_OPEN"),
    2: .same(proto: "CLOSURESTATE_AJAR"),
    3: .same(proto: "CLOSURESTATE_UNKNOWN"),
    4: .same(proto: "CLOSURESTATE_FAILED_UNLATCH"),
  ]
}

extension Device_Motion_Confidence: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_MOTION_CONFIDENCE_UNKNOWN"),
    1: .same(proto: "DEVICE_MOTION_CONFIDENCE_LOW"),
    2: .same(proto: "DEVICE_MOTION_CONFIDENCE_MEDIUM"),
    3: .same(proto: "DEVICE_MOTION_CONFIDENCE_HIGH"),
  ]
}

extension Device_Motion_State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_MOTION_UNKNOWN"),
    1: .same(proto: "DEVICE_MOTION_STATIONARY"),
    2: .same(proto: "DEVICE_MOTION_WALKING"),
    3: .same(proto: "DEVICE_MOTION_RUNNING"),
    4: .same(proto: "DEVICE_MOTION_AUTOMOTIVE"),
    5: .same(proto: "DEVICE_MOTION_CYCLING"),
  ]
}

extension GenealogyRequest_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GENEALOGYREQUEST_NONE"),
    1: .same(proto: "GENEALOGYREQUEST_READ"),
    2: .same(proto: "GENEALOGYREQUEST_KEYFOBINFO_READ"),
    3: .same(proto: "GENEALOGYREQUEST_TPWHEELUNITINFO_READ"),
  ]
}

extension GenealogyStatus_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GENEALOGY_STATUS_NONE"),
    1: .same(proto: "GENEALOGY_STATUS_NOT_WRITTEN"),
    2: .same(proto: "GENEALOGY_STATUS_WRITE_SUCCESS"),
    3: .same(proto: "GENEALOGY_STATUS_WRITE_FAILURE"),
    4: .same(proto: "GENEALOGY_STATUS_READ_SUCCESS"),
    5: .same(proto: "GENEALOGY_STATUS_READ_FAILURE"),
    6: .same(proto: "GENEALOGY_STATUS_CRC_FAILURE"),
  ]
}

extension GetReaderKeyCommand: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET_READER_KEY_COMMAND_UNKNOWN"),
    1: .same(proto: "GET_READER_KEY_COMMAND_START_LOOKING"),
    2: .same(proto: "GET_READER_KEY_COMMAND_STOP_LOOKING"),
  ]
}

extension HandlePulled_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HANDLE_PULLED_FRONT_DRIVER_DOOR"),
    1: .same(proto: "HANDLE_PULLED_FRONT_PASSENGER_DOOR"),
    2: .same(proto: "HANDLE_PULLED_REAR_DRIVER_DOOR"),
    3: .same(proto: "HANDLE_PULLED_REAR_PASSENGER_DOOR"),
    4: .same(proto: "HANDLE_PULLED_TRUNK"),
    5: .same(proto: "HANDLE_PULLED_CHARGE_PORT"),
    6: .same(proto: "HANDLE_PULLED_FRONT_DRIVER_AUTO_PRESENT_DOOR"),
    7: .same(proto: "HANDLE_PULLED_FRONT_PASSENGER_AUTO_PRESENT_DOOR"),
    8: .same(proto: "HANDLE_PULLED_OTHER"),
    9: .same(proto: "HANDLE_PULLED_FRUNK"),
  ]
}

extension IMURequest_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IMU_REQUEST_NONE"),
    1: .same(proto: "IMU_REQUEST_GET_SLEEP_STATE"),
    2: .same(proto: "IMU_REQUEST_ENABLE_CONTINUOUS_ACTIVITY_UPDATE"),
    3: .same(proto: "IMU_REQUEST_DISABLE_CONTINUOUS_ACTIVITY_UPDATE"),
  ]
}

extension IMUState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IMU_STATE_NOT_CONFIGURED"),
    1: .same(proto: "IMU_STATE_ACTIVITY"),
    2: .same(proto: "IMU_STATE_INACTIVITY"),
  ]
}

extension InformationRequestType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INFORMATION_REQUEST_TYPE_GET_STATUS"),
    1: .same(proto: "INFORMATION_REQUEST_TYPE_GET_TOKEN"),
    2: .same(proto: "INFORMATION_REQUEST_TYPE_GET_COUNTER"),
    3: .same(proto: "INFORMATION_REQUEST_TYPE_GET_EPHEMERAL_PUBLIC_KEY"),
    4: .same(proto: "INFORMATION_REQUEST_TYPE_GET_SESSION_DATA"),
    5: .same(proto: "INFORMATION_REQUEST_TYPE_GET_WHITELIST_INFO"),
    6: .same(proto: "INFORMATION_REQUEST_TYPE_GET_WHITELIST_ENTRY_INFO"),
    7: .same(proto: "INFORMATION_REQUEST_TYPE_GET_VEHICLE_INFO"),
    8: .same(proto: "INFORMATION_REQUEST_TYPE_GET_KEYSTATUS_INFO"),
    9: .same(proto: "INFORMATION_REQUEST_TYPE_GET_ACTIVE_KEY"),
    16: .same(proto: "INFORMATION_REQUEST_TYPE_GET_CAPABILITIES"),
  ]
}

extension KeyFormFactor: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY_FORM_FACTOR_UNKNOWN"),
    1: .same(proto: "KEY_FORM_FACTOR_NFC_CARD"),
    2: .same(proto: "KEY_FORM_FACTOR_3_BUTTON_BLE_CAR_KEYFOB"),
    3: .same(proto: "KEY_FORM_FACTOR_BLE_DEVICE"),
    4: .same(proto: "KEY_FORM_FACTOR_NFC_DEVICE"),
    5: .same(proto: "KEY_FORM_FACTOR_BLE_AND_NFC_DEVICE"),
    6: .same(proto: "KEY_FORM_FACTOR_IOS_DEVICE"),
    7: .same(proto: "KEY_FORM_FACTOR_ANDROID_DEVICE"),
    8: .same(proto: "KEY_FORM_FACTOR_3_BUTTON_BLE_CAR_KEYFOB_P60"),
    9: .same(proto: "KEY_FORM_FACTOR_CLOUD_KEY"),
    10: .same(proto: "KEY_FORM_FACTOR_3_BUTTON_GEN2_CAR_KEYFOB_P60"),
    11: .same(proto: "KEY_FORM_FACTOR_5_BUTTON_GEN2_CAR_KEYFOB_P60"),
    12: .same(proto: "KEY_FORM_FACTOR_3_BUTTON_GEN2_CAR_KEYFOB_P60_V2"),
    13: .same(proto: "KEY_FORM_FACTOR_3_BUTTON_GEN2_CAR_KEYFOB_P60_V3"),
    14: .same(proto: "KEY_FORM_FACTOR_NFC_CARD_P71"),
  ]
}

extension LRDetectionResult_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LRDETECTIONRESULT_ERROR_MAXCNT"),
    1: .same(proto: "LRDETECTIONRESULT_ERROR_NEGPERIOD"),
    2: .same(proto: "LRDETECTIONRESULT_ERROR_LONGPERIOD"),
    3: .same(proto: "LRDETECTIONRESULT_LEFT"),
    4: .same(proto: "LRDETECTIONRESULT_RIGHT"),
  ]
}

extension MIError_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_UNKNOWN"),
    1: .same(proto: "ERROR_SESSION_LIMIT_EXCEEDED"),
    2: .same(proto: "ERROR_INVALID_CONFIGURATION"),
    3: .same(proto: "ERROR_RESOURCE_USAGE_TIMEOUT"),
    4: .same(proto: "ERROR_SESSION_FAILED"),
    5: .same(proto: "ERROR_UNSUPPORTED_PLATFORM"),
    6: .same(proto: "ERROR_USER_DID_NOT_ALLOW"),
    7: .same(proto: "ERROR_BLE_PEER_UNAVAILABLE"),
    8: .same(proto: "ERROR_VEHICLE_NOT_SELECTED_FOR_RANGING"),
  ]
}

extension MLXWakePeriod_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MLXWAKEPERIOD_2_MS"),
    1: .same(proto: "MLXWAKEPERIOD_3_MS"),
    2: .same(proto: "MLXWAKEPERIOD_5_MS"),
    3: .same(proto: "MLXWAKEPERIOD_15_MS"),
    4: .same(proto: "MLXWAKEPERIOD_30_MS"),
    5: .same(proto: "MLXWAKEPERIOD_50_MS"),
    6: .same(proto: "MLXWAKEPERIOD_100_MS"),
    7: .same(proto: "MLXWAKEPERIOD_150_MS"),
    8: .same(proto: "MLXWAKEPERIOD_250_MS"),
    9: .same(proto: "MLXWAKEPERIOD_500_MS"),
    10: .same(proto: "MLXWAKEPERIOD_1_S"),
    11: .same(proto: "MLXWAKEPERIOD_2_S"),
    12: .same(proto: "MLXWAKEPERIOD_2_5_S"),
    13: .same(proto: "MLXWAKEPERIOD_3_S"),
    14: .same(proto: "MLXWAKEPERIOD_4_S"),
    15: .same(proto: "MLXWAKEPERIOD_5_S"),
    16: .same(proto: "MLXWAKEPERIOD_6_S"),
    17: .same(proto: "MLXWAKEPERIOD_7_S"),
    18: .same(proto: "MLXWAKEPERIOD_8_S"),
    19: .same(proto: "MLXWAKEPERIOD_9_S"),
    20: .same(proto: "MLXWAKEPERIOD_10_S"),
    21: .same(proto: "MLXWAKEPERIOD_11_S"),
    22: .same(proto: "MLXWAKEPERIOD_12_S"),
    23: .same(proto: "MLXWAKEPERIOD_15_S"),
    24: .same(proto: "MLXWAKEPERIOD_20_S"),
    25: .same(proto: "MLXWAKEPERIOD_30_S"),
    26: .same(proto: "MLXWAKEPERIOD_1_M"),
    27: .same(proto: "MLXWAKEPERIOD_2_M"),
    28: .same(proto: "MLXWAKEPERIOD_3_M"),
    29: .same(proto: "MLXWAKEPERIOD_4_M"),
    30: .same(proto: "MLXWAKEPERIOD_5_M"),
    31: .same(proto: "MLXWAKEPERIOD_10_M"),
    32: .same(proto: "MLXWAKEPERIOD_16_M"),
    33: .same(proto: "MLXWAKEPERIOD_NOT_SET"),
  ]
}

extension NFCPresence: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NFC_PRESENCE_NOT_PRESENT"),
    1: .same(proto: "NFC_PRESENCE_PRESENT_AT_B_PILLAR"),
    2: .same(proto: "NFC_PRESENCE_PRESENT_AT_CENTER_CONSOLE"),
  ]
}

extension NFCSEDevicePubKeyState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NFCSEC_DEVICEPUBKEY_STATE_NONE"),
    1: .same(proto: "NFCSEC_DEVICEPUBKEY_STATE_RETRIEVED"),
    2: .same(proto: "NFCSEC_DEVICEPUBKEY_STATE_NOT_RETRIEVED"),
  ]
}

extension NFCSEInsecureCommandState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NFCSEC_INSECURE_COMMAND_STATE_NONE"),
    1: .same(proto: "NFCSEC_INSECURE_COMMAND_STATE_ENABLED"),
    2: .same(proto: "NFCSEC_INSECURE_COMMAND_STATE_DISABLED"),
  ]
}

extension NFCSERequest_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NFCSE_REQUEST_NONE"),
    1: .same(proto: "NFCSE_REQUEST_REFETCH_SESSION_INFO"),
    2: .same(proto: "NFCSE_REQUEST_DISABLE_INSECURE_COMMANDS"),
    3: .same(proto: "NFCSE_REQUEST_GET_CURRENT_STATE"),
  ]
}

extension NFCSESharedSecretState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NFCSEC_SHAREDSECRET_STATE_NONE"),
    1: .same(proto: "NFCSEC_SHAREDSECRET_STATE_GENERATED"),
    2: .same(proto: "NFCSEC_SHAREDSECRET_STATE_NOT_GENERATED"),
  ]
}

extension NFCSEVehiclePubKeyState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NFCSEC_VEHICLEPUBKEY_STATE_NONE"),
    1: .same(proto: "NFCSEC_VEHICLEPUBKEY_STATE_RETRIEVED"),
    2: .same(proto: "NFCSEC_VEHICLEPUBKEY_STATE_NOT_RETRIEVED"),
  ]
}

extension PublicKeyRequest_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUBLIC_KEY_REQUEST_NONE"),
    1: .same(proto: "PUBLIC_KEY_REQUEST_READ"),
  ]
}

extension PublicKeyStatus_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUBLIC_KEY_STATUS_NONE"),
    1: .same(proto: "PUBLIC_KEY_STATUS_NOT_WRITTEN"),
    2: .same(proto: "PUBLIC_KEY_STATUS_WRITTEN"),
  ]
}

extension RCI_control_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RCI_CONTROL_NONE"),
    1: .same(proto: "RCI_CONTROL_TURN_OFF"),
  ]
}

extension ResetTrackerCommand_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESETTRACKER_COMMAND_NONE"),
    1: .same(proto: "RESETTRACKER_COMMAND_GET_STATS"),
    2: .same(proto: "RESETTRACKER_COMMAND_CLEAR_STATS"),
  ]
}

extension RKEAction_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RKE_ACTION_UNLOCK"),
    1: .same(proto: "RKE_ACTION_LOCK"),
    2: .same(proto: "RKE_ACTION_OPEN_TRUNK"),
    3: .same(proto: "RKE_ACTION_OPEN_FRUNK"),
    4: .same(proto: "RKE_ACTION_OPEN_CHARGE_PORT"),
    5: .same(proto: "RKE_ACTION_CLOSE_CHARGE_PORT"),
    6: .same(proto: "RKE_ACTION_CANCEL_EXTERNAL_AUTHENTICATE"),
    7: .same(proto: "RKE_ACTION_SINGLE_PRESS_TOP"),
    8: .same(proto: "RKE_ACTION_DOUBLE_PRESS_TOP"),
    9: .same(proto: "RKE_ACTION_TRIPLE_PRESS_TOP"),
    10: .same(proto: "RKE_ACTION_HOLD_TOP"),
    11: .same(proto: "RKE_ACTION_SINGLE_PRESS_BACK"),
    12: .same(proto: "RKE_ACTION_DOUBLE_PRESS_BACK"),
    13: .same(proto: "RKE_ACTION_TRIPLE_PRESS_BACK"),
    14: .same(proto: "RKE_ACTION_HOLD_BACK"),
    15: .same(proto: "RKE_ACTION_SINGLE_PRESS_FRONT"),
    16: .same(proto: "RKE_ACTION_DOUBLE_PRESS_FRONT"),
    17: .same(proto: "RKE_ACTION_TRIPLE_PRESS_FRONT"),
    18: .same(proto: "RKE_ACTION_HOLD_FRONT"),
    19: .same(proto: "RKE_ACTION_UNKNOWN"),
    20: .same(proto: "RKE_ACTION_REMOTE_DRIVE"),
    21: .same(proto: "RKE_ACTION_SINGLE_PRESS_LEFT"),
    22: .same(proto: "RKE_ACTION_DOUBLE_PRESS_LEFT"),
    23: .same(proto: "RKE_ACTION_TRIPLE_PRESS_LEFT"),
    24: .same(proto: "RKE_ACTION_HOLD_LEFT"),
    25: .same(proto: "RKE_ACTION_SINGLE_PRESS_RIGHT"),
    26: .same(proto: "RKE_ACTION_DOUBLE_PRESS_RIGHT"),
    27: .same(proto: "RKE_ACTION_TRIPLE_PRESS_RIGHT"),
    28: .same(proto: "RKE_ACTION_HOLD_RIGHT"),
    29: .same(proto: "RKE_ACTION_AUTO_SECURE_VEHICLE"),
    30: .same(proto: "RKE_ACTION_WAKE_VEHICLE"),
  ]
}

extension SignatureType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SIGNATURE_TYPE_AES_GCM"),
    1: .same(proto: "SIGNATURE_TYPE_ECDSA"),
    2: .same(proto: "SIGNATURE_TYPE_PRESENT_KEY"),
    3: .same(proto: "SIGNATURE_TYPE_AES_GCM_TOKEN"),
    4: .same(proto: "SIGNATURE_TYPE_UNSIGNED"),
  ]
}

extension SignedMessage_information_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SIGNEDMESSAGE_INFORMATION_NONE"),
    1: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_UNKNOWN"),
    2: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_NOT_ON_WHITELIST"),
    3: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_IV_SMALLER_THAN_EXPECTED"),
    4: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_INVALID_TOKEN"),
    5: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_AND_COUNTER_INVALID"),
    6: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_AES_DECRYPT_AUTH"),
    7: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_INPUT"),
    8: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_ECDSA_SIGNATURE"),
    9: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_START"),
    10: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_LOCAL_ENTITY_RESULT"),
    11: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_KEY"),
    12: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_RETRIEVE_TOKEN"),
    13: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_SIGNATURE_TOO_SHORT"),
    14: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_TOKEN_IS_INCORRECT_LENGTH"),
    15: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_INCORRECT_EPOCH"),
    16: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_IV_INCORRECT_LENGTH"),
    17: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_TIME_EXPIRED"),
    18: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_NOT_PROVISIONED_WITH_IDENTITY"),
    19: .same(proto: "SIGNEDMESSAGE_INFORMATION_FAULT_COULD_NOT_HASH_METADATA"),
  ]
}

extension SleepManagerCommand_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SLEEPMANAGER_COMMAND_NONE"),
    1: .same(proto: "SLEEPMANAGER_GET_STATS"),
    2: .same(proto: "SLEEPMANAGER_RESET_STATS"),
  ]
}

extension TPDataRequest_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TP_DATAREQUEST_NONE"),
    1: .same(proto: "TP_DATAREQUEST_PRESSURE_TEMPERATURE"),
    2: .same(proto: "TP_DATAREQUEST_NEW_SENSOR_INFO"),
    3: .same(proto: "TP_DATAREQUEST_WHEEL_ROTATION_DIRECTION"),
    4: .same(proto: "TP_DATAREQUEST_ACCEL"),
    5: .same(proto: "TP_DATAREQUEST_MOTION_DETECTION_START"),
    6: .same(proto: "TP_DATAREQUEST_READ_ALARMS"),
    7: .same(proto: "TP_DATAREQUEST_MOTION_DETECTION_STOP"),
    8: .same(proto: "TP_DATAREQUEST_READ_PUBLIC_KEY"),
    9: .same(proto: "TP_DATAREQUEST_RF_MONITOR_COUNTERS"),
    10: .same(proto: "TP_DATAREQUEST_MOTION_CONFIG"),
    11: .same(proto: "TP_DATAREQUEST_STATIONARY_CONFIG"),
    12: .same(proto: "TP_DATAREQUEST_CAPABILITIES"),
  ]
}

extension TPMSAdvType_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TPMS_ADV_TYPE_SEMI"),
  ]
}

extension TPNotifyReason_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TP_NOTIFY_REASON_UNKNOWN"),
    1: .same(proto: "TP_NOTIFY_REASON_LOW_PRESSURE"),
    2: .same(proto: "TP_NOTIFY_REASON_PT_VALUE_UPDATE"),
    3: .same(proto: "TP_NOTIFY_REASON_WHEEL_MOVING"),
    4: .same(proto: "TP_NOTIFY_REASON_WHEEL_ROTATION_DIRECTION_CALCULATION_READY"),
    5: .same(proto: "TP_NOTIFY_REASON_LF"),
    6: .same(proto: "TP_NOTIFY_REASON_FAULT"),
  ]
}

extension TPNotifyTrackerCommand_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TP_NOTIFYTRACKER_COMMAND_NONE"),
    1: .same(proto: "TP_NOTIFYTRACKER_COMMAND_GET_STATS"),
    2: .same(proto: "TP_NOTIFYTRACKER_COMMAND_CLEAR_STATS"),
  ]
}

extension UIRequest_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UI_REQUEST_NONE"),
    1: .same(proto: "UI_REQUEST_GET_VEHICLE_BLE_NICK_NAME"),
  ]
}

extension UpdaterLocation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPDATER_LOCATION_NONE"),
    1: .same(proto: "UPDATER_LOCATION_APPLICATION"),
    2: .same(proto: "UPDATER_LOCATION_BOOTLOADER"),
    3: .same(proto: "UPDATER_LOCATION_SECONDARY_APPLICATION"),
    4: .same(proto: "UPDATER_LOCATION_APPLICATION_IN_EXTERNAL_FLASH"),
  ]
}

extension UpdaterStatusCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPDATER_STATUS_CODE_ERROR"),
    1: .same(proto: "UPDATER_STATUS_CODE_WAIT"),
    2: .same(proto: "UPDATER_STATUS_CODE_BLOCK_STAGED"),
    3: .same(proto: "UPDATER_STATUS_CODE_IMAGE_STAGED"),
    4: .same(proto: "UPDATER_STATUS_CODE_CRC_CHECK_SUCCESS"),
    5: .same(proto: "UPDATER_STATUS_CODE_CRC_CHECK_FAIL"),
    6: .same(proto: "UPDATER_STATUS_CODE_HASH_FAIL"),
    7: .same(proto: "UPDATER_STATUS_CODE_SIGNATURE_FAIL"),
    8: .same(proto: "UPDATER_STATUS_CODE_ERROR_HASH_RESTORE_FAIL"),
    9: .same(proto: "UPDATER_STATUS_CODE_LOCATION_SET"),
  ]
}

extension UserPresence_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VEHICLE_USER_PRESENCE_UNKNOWN"),
    1: .same(proto: "VEHICLE_USER_PRESENCE_NOT_PRESENT"),
    2: .same(proto: "VEHICLE_USER_PRESENCE_PRESENT"),
  ]
}

extension UWBAvailability: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UWB_AVAILABILITY_UNKNOWN"),
    1: .same(proto: "UWB_AVAILABILITY_AVAILABLE"),
    2: .same(proto: "UWB_AVAILABILITY_UNAVAILABLE_UNSUPPORTED_DEVICE"),
    3: .same(proto: "UWB_AVAILABILITY_UNAVAILABLE_PERMISSION_DENIED"),
    4: .same(proto: "UWB_AVAILABILITY_UNAVAILABLE"),
  ]
}

extension VehicleLockState_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VEHICLELOCKSTATE_UNLOCKED"),
    1: .same(proto: "VEHICLELOCKSTATE_LOCKED"),
    2: .same(proto: "VEHICLELOCKSTATE_INTERNAL_LOCKED"),
    3: .same(proto: "VEHICLELOCKSTATE_SELECTIVE_UNLOCKED"),
  ]
}

extension VehicleSleepStatus_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VEHICLE_SLEEP_STATUS_UNKNOWN"),
    1: .same(proto: "VEHICLE_SLEEP_STATUS_AWAKE"),
    2: .same(proto: "VEHICLE_SLEEP_STATUS_ASLEEP"),
  ]
}

extension WhitelistKeyPermission_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WHITELISTKEYPERMISSION_ADD_TO_WHITELIST"),
    1: .same(proto: "WHITELISTKEYPERMISSION_LOCAL_UNLOCK"),
    2: .same(proto: "WHITELISTKEYPERMISSION_LOCAL_DRIVE"),
    3: .same(proto: "WHITELISTKEYPERMISSION_REMOTE_UNLOCK"),
    4: .same(proto: "WHITELISTKEYPERMISSION_REMOTE_DRIVE"),
    5: .same(proto: "WHITELISTKEYPERMISSION_CHANGE_PERMISSIONS"),
    6: .same(proto: "WHITELISTKEYPERMISSION_REMOVE_FROM_WHITELIST"),
    7: .same(proto: "WHITELISTKEYPERMISSION_REMOVE_SELF_FROM_WHITELIST"),
    8: .same(proto: "WHITELISTKEYPERMISSION_MODIFY_FLEET_RESERVED_SLOTS"),
    31: .same(proto: "WHITELISTKEYPERMISSION_UNKNOWN"),
  ]
}

extension WhitelistOperation_information_E: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WHITELISTOPERATION_INFORMATION_NONE"),
    1: .same(proto: "WHITELISTOPERATION_INFORMATION_UNDOCUMENTED_ERROR"),
    2: .same(proto: "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE_ONESELF"),
    3: .same(proto: "WHITELISTOPERATION_INFORMATION_KEYFOB_SLOTS_FULL"),
    4: .same(proto: "WHITELISTOPERATION_INFORMATION_WHITELIST_FULL"),
    5: .same(proto: "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_ADD"),
    6: .same(proto: "WHITELISTOPERATION_INFORMATION_INVALID_PUBLIC_KEY"),
    7: .same(proto: "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_REMOVE"),
    8: .same(proto: "WHITELISTOPERATION_INFORMATION_NO_PERMISSION_TO_CHANGE_PERMISSIONS"),
    9: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ELEVATE_OTHER_ABOVE_ONESELF"),
    10: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_DEMOTE_SUPERIOR_TO_ONESELF"),
    11: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_REMOVE_OWN_PERMISSIONS"),
    12: .same(proto: "WHITELISTOPERATION_INFORMATION_PUBLIC_KEY_NOT_ON_WHITELIST"),
    13: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_THAT_IS_ALREADY_ON_THE_WHITELIST"),
    14: .same(proto: "WHITELISTOPERATION_INFORMATION_NOT_ALLOWED_TO_ADD_UNLESS_ON_READER"),
    15: .same(proto: "WHITELISTOPERATION_INFORMATION_FM_MODIFYING_OUTSIDE_OF_F_MODE"),
    16: .same(proto: "WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_ADD_PERMANENT_KEY"),
    17: .same(proto: "WHITELISTOPERATION_INFORMATION_FM_ATTEMPTING_TO_REMOVE_PERMANENT_KEY"),
    18: .same(proto: "WHITELISTOPERATION_INFORMATION_KEYCHAIN_WHILE_FS_FULL"),
    19: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITHOUT_ROLE"),
    20: .same(proto: "WHITELISTOPERATION_INFORMATION_ATTEMPTING_TO_ADD_KEY_WITH_SERVICE_ROLE"),
    21: .same(proto: "WHITELISTOPERATION_INFORMATION_NON_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH"),
    22: .same(proto: "WHITELISTOPERATION_INFORMATION_SERVICE_KEY_ATTEMPTING_TO_ADD_SERVICE_TECH_OUTSIDE_SERVICE_MODE"),
    23: .same(proto: "WHITELISTOPERATION_INFORMATION_COULD_NOT_START_LOCAL_ENTITY_AUTH"),
    24: .same(proto: "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_UI_DENIED"),
    25: .same(proto: "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_TIMED_OUT_WAITING_FOR_TAP"),
    26: .same(proto: "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_TIMED_OUT_WAITING_FOR_UI_ACK"),
    27: .same(proto: "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_VALET_MODE"),
    28: .same(proto: "WHITELISTOPERATION_INFORMATION_LOCAL_ENTITY_AUTH_FAILED_CANCELLED"),
  ]
}

extension AccelData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AccelData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "xAccel_g"),
    2: .standard(proto: "zAccel_g"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.xAccelG) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.zAccelG) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.xAccelG != 0 {
      try visitor.visitSingularInt32Field(value: self.xAccelG, fieldNumber: 1)
    }
    if self.zAccelG != 0 {
      try visitor.visitSingularInt32Field(value: self.zAccelG, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AccelData, rhs: AccelData) -> Bool {
    if lhs.xAccelG != rhs.xAccelG {return false}
    if lhs.zAccelG != rhs.zAccelG {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ActiveKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ActiveKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "activeKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._activeKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._activeKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ActiveKey, rhs: ActiveKey) -> Bool {
    if lhs._activeKey != rhs._activeKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Alert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Alert"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alertHandlePulledWithoutAuth"),
    2: .same(proto: "alertConfirmation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: AlertHandlePulledWithoutAuth?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .alertHandlePulledWithoutAuth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .alertHandlePulledWithoutAuth(v)
        }
      }()
      case 2: try {
        var v: AlertConfirmation?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .alertConfirmation(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .alertHandlePulledWithoutAuth?: try {
      guard case .alertHandlePulledWithoutAuth(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .alertConfirmation?: try {
      guard case .alertConfirmation(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Alert, rhs: Alert) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AlertHandlePulledWithoutAuth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AlertHandlePulledWithoutAuth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timeSinceAlertSet_ms"),
    2: .same(proto: "handlePulled"),
    3: .same(proto: "connectionCount"),
    4: .same(proto: "unknownDevicePresent"),
    5: .same(proto: "authRequested"),
    6: .same(proto: "deviceSpecificPayload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.timeSinceAlertSetMs) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.handlePulled) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.connectionCount) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.unknownDevicePresent) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.authRequested) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.deviceSpecificPayload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timeSinceAlertSetMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeSinceAlertSetMs, fieldNumber: 1)
    }
    if self.handlePulled != .handlePulledFrontDriverDoor {
      try visitor.visitSingularEnumField(value: self.handlePulled, fieldNumber: 2)
    }
    if self.connectionCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.connectionCount, fieldNumber: 3)
    }
    if self.unknownDevicePresent != false {
      try visitor.visitSingularBoolField(value: self.unknownDevicePresent, fieldNumber: 4)
    }
    if self.authRequested != false {
      try visitor.visitSingularBoolField(value: self.authRequested, fieldNumber: 5)
    }
    if !self.deviceSpecificPayload.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deviceSpecificPayload, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AlertHandlePulledWithoutAuth, rhs: AlertHandlePulledWithoutAuth) -> Bool {
    if lhs.timeSinceAlertSetMs != rhs.timeSinceAlertSetMs {return false}
    if lhs.handlePulled != rhs.handlePulled {return false}
    if lhs.connectionCount != rhs.connectionCount {return false}
    if lhs.unknownDevicePresent != rhs.unknownDevicePresent {return false}
    if lhs.authRequested != rhs.authRequested {return false}
    if lhs.deviceSpecificPayload != rhs.deviceSpecificPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AppDeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AppDeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hardware_model_sha256"),
    2: .same(proto: "os"),
    3: .same(proto: "UWBAvailable"),
    4: .same(proto: "phoneVersion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hardwareModelSha256) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.os) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.uwbavailable) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._phoneVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hardwareModelSha256.isEmpty {
      try visitor.visitSingularBytesField(value: self.hardwareModelSha256, fieldNumber: 1)
    }
    if self.os != .unknown {
      try visitor.visitSingularEnumField(value: self.os, fieldNumber: 2)
    }
    if self.uwbavailable != .unknown {
      try visitor.visitSingularEnumField(value: self.uwbavailable, fieldNumber: 3)
    }
    try { if let v = self._phoneVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AppDeviceInfo, rhs: AppDeviceInfo) -> Bool {
    if lhs.hardwareModelSha256 != rhs.hardwareModelSha256 {return false}
    if lhs.os != rhs.os {return false}
    if lhs.uwbavailable != rhs.uwbavailable {return false}
    if lhs._phoneVersion != rhs._phoneVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AppEventLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AppEventLog"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "peerRemovedPairingInformation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.timestamp) }()
      case 2: try {
        var v: AppEventPeerRemovedPairingInformation?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .peerRemovedPairingInformation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .peerRemovedPairingInformation(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularFixed32Field(value: self.timestamp, fieldNumber: 1)
    }
    try { if case .peerRemovedPairingInformation(let v)? = self.subMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AppEventLog, rhs: AppEventLog) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AppEventPeerRemovedPairingInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AppEventPeerRemovedPairingInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AppEventPeerRemovedPairingInformation, rhs: AppEventPeerRemovedPairingInformation) -> Bool {
    if lhs._keyID != rhs._keyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ASICSPIRead: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ASICSPIRead"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "response"),
    2: .standard(proto: "data_"),
    3: .same(proto: "opCode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.response) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.data_) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.opCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.response != 0 {
      try visitor.visitSingularUInt32Field(value: self.response, fieldNumber: 1)
    }
    if self.data_ != 0 {
      try visitor.visitSingularUInt32Field(value: self.data_, fieldNumber: 2)
    }
    if self.opCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.opCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ASICSPIRead, rhs: ASICSPIRead) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.data_ != rhs.data_ {return false}
    if lhs.opCode != rhs.opCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AuthenticationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AuthenticationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "sessionInfo"),
    3: .same(proto: "requestedLevel"),
    4: .same(proto: "reasonsForAuth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sessionInfo) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.requestedLevel) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.reasonsForAuth) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sessionInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.requestedLevel != .authenticationLevelNone {
      try visitor.visitSingularEnumField(value: self.requestedLevel, fieldNumber: 3)
    }
    if !self.reasonsForAuth.isEmpty {
      try visitor.visitPackedEnumField(value: self.reasonsForAuth, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AuthenticationRequest, rhs: AuthenticationRequest) -> Bool {
    if lhs._sessionInfo != rhs._sessionInfo {return false}
    if lhs.requestedLevel != rhs.requestedLevel {return false}
    if lhs.reasonsForAuth != rhs.reasonsForAuth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AuthenticationRequestToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AuthenticationRequestToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularBytesField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AuthenticationRequestToken, rhs: AuthenticationRequestToken) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AuthenticationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AuthenticationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authenticationLevel"),
    2: .same(proto: "estimatedDistance"),
    3: .same(proto: "authenticationRejection"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.authenticationLevel) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.estimatedDistance) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.authenticationRejection) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.authenticationLevel != .authenticationLevelNone {
      try visitor.visitSingularEnumField(value: self.authenticationLevel, fieldNumber: 1)
    }
    if self.estimatedDistance != 0 {
      try visitor.visitSingularUInt32Field(value: self.estimatedDistance, fieldNumber: 2)
    }
    if self.authenticationRejection != .authenticationrejectionNone {
      try visitor.visitSingularEnumField(value: self.authenticationRejection, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AuthenticationResponse, rhs: AuthenticationResponse) -> Bool {
    if lhs.authenticationLevel != rhs.authenticationLevel {return false}
    if lhs.estimatedDistance != rhs.estimatedDistance {return false}
    if lhs.authenticationRejection != rhs.authenticationRejection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BLEConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ADVInterval"),
    2: .same(proto: "sleepClockAccuracy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .advinterval(v)
        }
      }()
      case 2: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .sleepClockAccuracy(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .advinterval?: try {
      guard case .advinterval(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }()
    case .sleepClockAccuracy?: try {
      guard case .sleepClockAccuracy(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEConfig, rhs: BLEConfig) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEConfigAll: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BLEConfigAll"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ADVInterval"),
    2: .same(proto: "sleepClockAccuracy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.advinterval) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sleepClockAccuracy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.advinterval != 0 {
      try visitor.visitSingularUInt32Field(value: self.advinterval, fieldNumber: 1)
    }
    if self.sleepClockAccuracy != 0 {
      try visitor.visitSingularUInt32Field(value: self.sleepClockAccuracy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEConfigAll, rhs: BLEConfigAll) -> Bool {
    if lhs.advinterval != rhs.advinterval {return false}
    if lhs.sleepClockAccuracy != rhs.sleepClockAccuracy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BLEConfigCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BLEConfigCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BLEConfigCommandType"),
    2: .same(proto: "BLEConfig"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.bleconfigCommandType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._bleconfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.bleconfigCommandType != .bleConfigCommandTypeNone {
      try visitor.visitSingularEnumField(value: self.bleconfigCommandType, fieldNumber: 1)
    }
    try { if let v = self._bleconfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BLEConfigCommand, rhs: BLEConfigCommand) -> Bool {
    if lhs.bleconfigCommandType != rhs.bleconfigCommandType {return false}
    if lhs._bleconfig != rhs._bleconfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Capabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Capabilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chargePortOpen"),
    2: .same(proto: "chargePortClose"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.chargePortOpen) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.chargePortClose) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chargePortOpen != false {
      try visitor.visitSingularBoolField(value: self.chargePortOpen, fieldNumber: 1)
    }
    if self.chargePortClose != false {
      try visitor.visitSingularBoolField(value: self.chargePortClose, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Capabilities, rhs: Capabilities) -> Bool {
    if lhs.chargePortOpen != rhs.chargePortOpen {return false}
    if lhs.chargePortClose != rhs.chargePortClose {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Certificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Certificate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "certificateInParts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CertificateInParts?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .certificateInParts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .certificateInParts(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .certificateInParts(let v)? = self.subMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Certificate, rhs: Certificate) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CertificateInParts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CertificateInParts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startIndex"),
    2: .same(proto: "certificateSize"),
    3: .standard(proto: "data_"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.startIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.certificateSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data_) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.startIndex, fieldNumber: 1)
    }
    if self.certificateSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.certificateSize, fieldNumber: 2)
    }
    if !self.data_.isEmpty {
      try visitor.visitSingularBytesField(value: self.data_, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CertificateInParts, rhs: CertificateInParts) -> Bool {
    if lhs.startIndex != rhs.startIndex {return false}
    if lhs.certificateSize != rhs.certificateSize {return false}
    if lhs.data_ != rhs.data_ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CertificateRead: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CertificateRead"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "readIndex"),
    2: .same(proto: "lengthToRead"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.readIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.lengthToRead) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.readIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.readIndex, fieldNumber: 1)
    }
    if self.lengthToRead != 0 {
      try visitor.visitSingularUInt32Field(value: self.lengthToRead, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CertificateRead, rhs: CertificateRead) -> Bool {
    if lhs.readIndex != rhs.readIndex {return false}
    if lhs.lengthToRead != rhs.lengthToRead {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CertificateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CertificateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "certificate"),
    2: .same(proto: "certificateStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._certificate) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.certificateStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._certificate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.certificateStatus != .certificateStatusNone {
      try visitor.visitSingularEnumField(value: self.certificateStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CertificateResponse, rhs: CertificateResponse) -> Bool {
    if lhs._certificate != rhs._certificate {return false}
    if lhs.certificateStatus != rhs.certificateStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChallengeCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChallengeCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "challenge"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.challenge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.challenge.isEmpty {
      try visitor.visitSingularBytesField(value: self.challenge, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChallengeCommand, rhs: ChallengeCommand) -> Bool {
    if lhs.challenge != rhs.challenge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChallengeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChallengeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChallengeResponse, rhs: ChallengeResponse) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClosureMoveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClosureMoveRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "frontDriverDoor"),
    2: .same(proto: "frontPassengerDoor"),
    3: .same(proto: "rearDriverDoor"),
    4: .same(proto: "rearPassengerDoor"),
    5: .same(proto: "rearTrunk"),
    6: .same(proto: "frontTrunk"),
    7: .same(proto: "chargePort"),
    8: .same(proto: "tonneau"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.frontDriverDoor) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.frontPassengerDoor) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.rearDriverDoor) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.rearPassengerDoor) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.rearTrunk) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.frontTrunk) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.chargePort) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.tonneau) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frontDriverDoor != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.frontDriverDoor, fieldNumber: 1)
    }
    if self.frontPassengerDoor != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.frontPassengerDoor, fieldNumber: 2)
    }
    if self.rearDriverDoor != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.rearDriverDoor, fieldNumber: 3)
    }
    if self.rearPassengerDoor != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.rearPassengerDoor, fieldNumber: 4)
    }
    if self.rearTrunk != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.rearTrunk, fieldNumber: 5)
    }
    if self.frontTrunk != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.frontTrunk, fieldNumber: 6)
    }
    if self.chargePort != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.chargePort, fieldNumber: 7)
    }
    if self.tonneau != .closureMoveTypeNone {
      try visitor.visitSingularEnumField(value: self.tonneau, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClosureMoveRequest, rhs: ClosureMoveRequest) -> Bool {
    if lhs.frontDriverDoor != rhs.frontDriverDoor {return false}
    if lhs.frontPassengerDoor != rhs.frontPassengerDoor {return false}
    if lhs.rearDriverDoor != rhs.rearDriverDoor {return false}
    if lhs.rearPassengerDoor != rhs.rearPassengerDoor {return false}
    if lhs.rearTrunk != rhs.rearTrunk {return false}
    if lhs.frontTrunk != rhs.frontTrunk {return false}
    if lhs.chargePort != rhs.chargePort {return false}
    if lhs.tonneau != rhs.tonneau {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClosureStatuses: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClosureStatuses"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "frontDriverDoor"),
    2: .same(proto: "frontPassengerDoor"),
    3: .same(proto: "rearDriverDoor"),
    4: .same(proto: "rearPassengerDoor"),
    5: .same(proto: "rearTrunk"),
    6: .same(proto: "frontTrunk"),
    7: .same(proto: "chargePort"),
    8: .same(proto: "tonneau"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.frontDriverDoor) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.frontPassengerDoor) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.rearDriverDoor) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.rearPassengerDoor) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.rearTrunk) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.frontTrunk) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.chargePort) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.tonneau) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frontDriverDoor != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.frontDriverDoor, fieldNumber: 1)
    }
    if self.frontPassengerDoor != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.frontPassengerDoor, fieldNumber: 2)
    }
    if self.rearDriverDoor != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.rearDriverDoor, fieldNumber: 3)
    }
    if self.rearPassengerDoor != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.rearPassengerDoor, fieldNumber: 4)
    }
    if self.rearTrunk != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.rearTrunk, fieldNumber: 5)
    }
    if self.frontTrunk != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.frontTrunk, fieldNumber: 6)
    }
    if self.chargePort != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.chargePort, fieldNumber: 7)
    }
    if self.tonneau != .closurestateClosed {
      try visitor.visitSingularEnumField(value: self.tonneau, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClosureStatuses, rhs: ClosureStatuses) -> Bool {
    if lhs.frontDriverDoor != rhs.frontDriverDoor {return false}
    if lhs.frontPassengerDoor != rhs.frontPassengerDoor {return false}
    if lhs.rearDriverDoor != rhs.rearDriverDoor {return false}
    if lhs.rearPassengerDoor != rhs.rearPassengerDoor {return false}
    if lhs.rearTrunk != rhs.rearTrunk {return false}
    if lhs.frontTrunk != rhs.frontTrunk {return false}
    if lhs.chargePort != rhs.chargePort {return false}
    if lhs.tonneau != rhs.tonneau {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CodeDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CodeDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codeDescriptorLocation"),
    2: .same(proto: "version"),
    3: .same(proto: "codeDescriptorBytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.codeDescriptorLocation) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.codeDescriptorBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.codeDescriptorLocation != .none {
      try visitor.visitSingularEnumField(value: self.codeDescriptorLocation, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 2)
    }
    if !self.codeDescriptorBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.codeDescriptorBytes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CodeDescriptor, rhs: CodeDescriptor) -> Bool {
    if lhs.codeDescriptorLocation != rhs.codeDescriptorLocation {return false}
    if lhs.version != rhs.version {return false}
    if lhs.codeDescriptorBytes != rhs.codeDescriptorBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CommandStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CommandStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operationStatus"),
    2: .same(proto: "signedMessageStatus"),
    3: .same(proto: "whitelistOperationStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operationStatus) }()
      case 2: try {
        var v: SignedMessage_status?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .signedMessageStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .signedMessageStatus(v)
        }
      }()
      case 3: try {
        var v: WhitelistOperation_status?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .whitelistOperationStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .whitelistOperationStatus(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operationStatus != .operationstatusOk {
      try visitor.visitSingularEnumField(value: self.operationStatus, fieldNumber: 1)
    }
    switch self.subMessage {
    case .signedMessageStatus?: try {
      guard case .signedMessageStatus(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .whitelistOperationStatus?: try {
      guard case .whitelistOperationStatus(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CommandStatus, rhs: CommandStatus) -> Bool {
    if lhs.operationStatus != rhs.operationStatus {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConnectionMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConnectionMetrics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "goodConnEventCount"),
    2: .same(proto: "missedConnEventCount"),
    3: .same(proto: "badCRCConnEventCount"),
    4: .same(proto: "otherFailuresCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.goodConnEventCount) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.missedConnEventCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.badCrcconnEventCount) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.otherFailuresCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.goodConnEventCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.goodConnEventCount, fieldNumber: 1)
    }
    if self.missedConnEventCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.missedConnEventCount, fieldNumber: 2)
    }
    if self.badCrcconnEventCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.badCrcconnEventCount, fieldNumber: 3)
    }
    if self.otherFailuresCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.otherFailuresCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ConnectionMetrics, rhs: ConnectionMetrics) -> Bool {
    if lhs.goodConnEventCount != rhs.goodConnEventCount {return false}
    if lhs.missedConnEventCount != rhs.missedConnEventCount {return false}
    if lhs.badCrcconnEventCount != rhs.badCrcconnEventCount {return false}
    if lhs.otherFailuresCount != rhs.otherFailuresCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DelaySleepRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DelaySleepRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delayTime_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.delayTimeMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.delayTimeMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.delayTimeMs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DelaySleepRequest, rhs: DelaySleepRequest) -> Bool {
    if lhs.delayTimeMs != rhs.delayTimeMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DetailedClosureStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DetailedClosureStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tonneauPercentOpen"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.tonneauPercentOpen) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tonneauPercentOpen != 0 {
      try visitor.visitSingularUInt32Field(value: self.tonneauPercentOpen, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DetailedClosureStatus, rhs: DetailedClosureStatus) -> Bool {
    if lhs.tonneauPercentOpen != rhs.tonneauPercentOpen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceMotion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceMotion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "states"),
    2: .same(proto: "confidence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.states) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.confidence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.states.isEmpty {
      try visitor.visitPackedEnumField(value: self.states, fieldNumber: 1)
    }
    if self.confidence != .unknown {
      try visitor.visitSingularEnumField(value: self.confidence, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceMotion, rhs: DeviceMotion) -> Bool {
    if lhs.states != rhs.states {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FromRCI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FromRCI"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.response) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.response.isEmpty {
      try visitor.visitSingularBytesField(value: self.response, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FromRCI, rhs: FromRCI) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FromVCSECMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FromVCSECMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vehicleStatus"),
    2: .same(proto: "sessionInfo"),
    3: .same(proto: "authenticationRequest"),
    4: .same(proto: "commandStatus"),
    5: .same(proto: "personalizationInformation"),
    16: .same(proto: "whitelistInfo"),
    17: .same(proto: "whitelistEntryInfo"),
    18: .same(proto: "vehicleInfo"),
    19: .same(proto: "capabilities"),
    21: .same(proto: "keyStatusInfo"),
    22: .same(proto: "activeKey"),
    23: .same(proto: "unknownKeyInfo"),
    24: .same(proto: "UIRequest"),
    30: .same(proto: "updaterCommand"),
    31: .same(proto: "genealogyRequest"),
    32: .same(proto: "sleepManagerRequest"),
    33: .same(proto: "imuRequest"),
    34: .same(proto: "nfcseRequest"),
    35: .same(proto: "TPDataRequest"),
    36: .same(proto: "resetTrackerCommand"),
    37: .same(proto: "TPNotifyTrackerCommand"),
    38: .same(proto: "setTPConfiguration"),
    39: .same(proto: "unsecureNotification"),
    40: .same(proto: "epochSessionInfo"),
    41: .same(proto: "toRCICommand"),
    42: .same(proto: "rciControl"),
    43: .same(proto: "BLEConfigCommand"),
    44: .same(proto: "appDeviceInfoRequest"),
    45: .same(proto: "alert"),
    46: .same(proto: "nominalError"),
    47: .same(proto: "MISessionRequest"),
    48: .same(proto: "MISessionStop"),
    49: .same(proto: "clearTPMSAlarms"),
    50: .same(proto: "certificateRead"),
    51: .same(proto: "challengeCommand"),
    52: .same(proto: "publicKeyRequest"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: VehicleStatus?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .vehicleStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .vehicleStatus(v)
        }
      }()
      case 2: try {
        var v: SessionInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .sessionInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .sessionInfo(v)
        }
      }()
      case 3: try {
        var v: AuthenticationRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .authenticationRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .authenticationRequest(v)
        }
      }()
      case 4: try {
        var v: CommandStatus?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .commandStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .commandStatus(v)
        }
      }()
      case 5: try {
        var v: PersonalizationInformation?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .personalizationInformation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .personalizationInformation(v)
        }
      }()
      case 16: try {
        var v: WhitelistInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .whitelistInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .whitelistInfo(v)
        }
      }()
      case 17: try {
        var v: WhitelistEntryInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .whitelistEntryInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .whitelistEntryInfo(v)
        }
      }()
      case 18: try {
        var v: VehicleInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .vehicleInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .vehicleInfo(v)
        }
      }()
      case 19: try {
        var v: Capabilities?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .capabilities(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .capabilities(v)
        }
      }()
      case 21: try {
        var v: KeyStatusInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .keyStatusInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .keyStatusInfo(v)
        }
      }()
      case 22: try {
        var v: ActiveKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .activeKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .activeKey(v)
        }
      }()
      case 23: try {
        var v: UnknownKeyInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .unknownKeyInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .unknownKeyInfo(v)
        }
      }()
      case 24: try {
        var v: UIRequest_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .uirequest(v)
        }
      }()
      case 30: try {
        var v: UpdaterCommand?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .updaterCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .updaterCommand(v)
        }
      }()
      case 31: try {
        var v: GenealogyRequest_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .genealogyRequest(v)
        }
      }()
      case 32: try {
        var v: SleepManagerRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .sleepManagerRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .sleepManagerRequest(v)
        }
      }()
      case 33: try {
        var v: IMURequest_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .imuRequest(v)
        }
      }()
      case 34: try {
        var v: NFCSERequest_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .nfcseRequest(v)
        }
      }()
      case 35: try {
        var v: TPDataRequest_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpdataRequest(v)
        }
      }()
      case 36: try {
        var v: ResetTrackerCommand_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .resetTrackerCommand(v)
        }
      }()
      case 37: try {
        var v: TPNotifyTrackerCommand_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpnotifyTrackerCommand(v)
        }
      }()
      case 38: try {
        var v: SetTPConfiguration?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .setTpconfiguration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .setTpconfiguration(v)
        }
      }()
      case 39: try {
        var v: UnsecureNotification?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .unsecureNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .unsecureNotification(v)
        }
      }()
      case 40: try {
        var v: Signatures.SessionInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .epochSessionInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .epochSessionInfo(v)
        }
      }()
      case 41: try {
        var v: ToRCI?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .toRcicommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .toRcicommand(v)
        }
      }()
      case 42: try {
        var v: RCI_control_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .rciControl(v)
        }
      }()
      case 43: try {
        var v: BLEConfigCommand?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .bleconfigCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .bleconfigCommand(v)
        }
      }()
      case 44: try {
        var v: AppDeviceInfoRequest_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .appDeviceInfoRequest(v)
        }
      }()
      case 45: try {
        var v: Alert?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .alert(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .alert(v)
        }
      }()
      case 46: try {
        var v: NominalError?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .nominalError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .nominalError(v)
        }
      }()
      case 47: try {
        var v: MISessionRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .misessionRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .misessionRequest(v)
        }
      }()
      case 48: try {
        var v: MISessionStop?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .misessionStop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .misessionStop(v)
        }
      }()
      case 49: try {
        var v: TPMSAlarms?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .clearTpmsalarms_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .clearTpmsalarms_p(v)
        }
      }()
      case 50: try {
        var v: CertificateRead?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .certificateRead(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .certificateRead(v)
        }
      }()
      case 51: try {
        var v: ChallengeCommand?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .challengeCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .challengeCommand(v)
        }
      }()
      case 52: try {
        var v: PublicKeyRequest_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .publicKeyRequest(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .vehicleStatus?: try {
      guard case .vehicleStatus(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sessionInfo?: try {
      guard case .sessionInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .authenticationRequest?: try {
      guard case .authenticationRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .commandStatus?: try {
      guard case .commandStatus(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .personalizationInformation?: try {
      guard case .personalizationInformation(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .whitelistInfo?: try {
      guard case .whitelistInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .whitelistEntryInfo?: try {
      guard case .whitelistEntryInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .vehicleInfo?: try {
      guard case .vehicleInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .capabilities?: try {
      guard case .capabilities(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .keyStatusInfo?: try {
      guard case .keyStatusInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .activeKey?: try {
      guard case .activeKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .unknownKeyInfo?: try {
      guard case .unknownKeyInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .uirequest?: try {
      guard case .uirequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 24)
    }()
    case .updaterCommand?: try {
      guard case .updaterCommand(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .genealogyRequest?: try {
      guard case .genealogyRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 31)
    }()
    case .sleepManagerRequest?: try {
      guard case .sleepManagerRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .imuRequest?: try {
      guard case .imuRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 33)
    }()
    case .nfcseRequest?: try {
      guard case .nfcseRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 34)
    }()
    case .tpdataRequest?: try {
      guard case .tpdataRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 35)
    }()
    case .resetTrackerCommand?: try {
      guard case .resetTrackerCommand(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 36)
    }()
    case .tpnotifyTrackerCommand?: try {
      guard case .tpnotifyTrackerCommand(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 37)
    }()
    case .setTpconfiguration?: try {
      guard case .setTpconfiguration(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .unsecureNotification?: try {
      guard case .unsecureNotification(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .epochSessionInfo?: try {
      guard case .epochSessionInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .toRcicommand?: try {
      guard case .toRcicommand(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .rciControl?: try {
      guard case .rciControl(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 42)
    }()
    case .bleconfigCommand?: try {
      guard case .bleconfigCommand(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .appDeviceInfoRequest?: try {
      guard case .appDeviceInfoRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 44)
    }()
    case .alert?: try {
      guard case .alert(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .nominalError?: try {
      guard case .nominalError(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .misessionRequest?: try {
      guard case .misessionRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .misessionStop?: try {
      guard case .misessionStop(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .clearTpmsalarms_p?: try {
      guard case .clearTpmsalarms_p(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .certificateRead?: try {
      guard case .certificateRead(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .challengeCommand?: try {
      guard case .challengeCommand(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .publicKeyRequest?: try {
      guard case .publicKeyRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 52)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FromVCSECMessage, rhs: FromVCSECMessage) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Genealogy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Genealogy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serialNumber"),
    2: .same(proto: "partNumber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.serialNumber) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.partNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serialNumber.isEmpty {
      try visitor.visitSingularBytesField(value: self.serialNumber, fieldNumber: 1)
    }
    if !self.partNumber.isEmpty {
      try visitor.visitSingularBytesField(value: self.partNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Genealogy, rhs: Genealogy) -> Bool {
    if lhs.serialNumber != rhs.serialNumber {return false}
    if lhs.partNumber != rhs.partNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GenealogyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GenealogyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currentGenealogy"),
    2: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currentGenealogy) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currentGenealogy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.status != .genealogyStatusNone {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GenealogyResponse, rhs: GenealogyResponse) -> Bool {
    if lhs._currentGenealogy != rhs._currentGenealogy {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetCodeDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetCodeDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.location) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.location != .none {
      try visitor.visitSingularEnumField(value: self.location, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetCodeDescriptor, rhs: GetCodeDescriptor) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetReaderKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetReaderKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.command != .unknown {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetReaderKey, rhs: GetReaderKey) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HandlePulledWithoutAuthDeviceSpecificPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HandlePulledWithoutAuthDeviceSpecificPayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyChannel"),
    2: .same(proto: "authenticationLevel"),
    3: .same(proto: "present"),
    4: .same(proto: "RSSILeft"),
    5: .same(proto: "RSSIRight"),
    6: .same(proto: "RSSIRear"),
    7: .same(proto: "RSSICenter"),
    8: .same(proto: "RSSIFront"),
    9: .same(proto: "RSSISecondary"),
    10: .same(proto: "RSSINFCCradle"),
    11: .same(proto: "RSSIRearLeft"),
    12: .same(proto: "RSSIRearRight"),
    13: .same(proto: "highThreshLeftPresent"),
    14: .same(proto: "highThreshRightPresent"),
    15: .same(proto: "highThreshCenterPresent"),
    16: .same(proto: "highThreshFrontPresent"),
    17: .same(proto: "highThreshRearPresent"),
    18: .same(proto: "highThreshRearLeftPresent"),
    19: .same(proto: "highThreshRearRightPresent"),
    20: .same(proto: "highThreshSecondaryPresent"),
    21: .same(proto: "highThreshNFCPresent"),
    22: .same(proto: "sortedDeltaBayesLeftPresent"),
    23: .same(proto: "sortedDeltaBayesRightPresent"),
    24: .same(proto: "rawDeltaBayesLeftPresent"),
    25: .same(proto: "rawDeltaBayesRightPresent"),
  ]

  fileprivate class _StorageClass {
    var _keyChannel: UInt32 = 0
    var _authenticationLevel: AuthenticationLevel_E = .authenticationLevelNone
    var _present: Bool = false
    var _rssileft: Int32 = 0
    var _rssiright: Int32 = 0
    var _rssirear: Int32 = 0
    var _rssicenter: Int32 = 0
    var _rssifront: Int32 = 0
    var _rssisecondary: Int32 = 0
    var _rssinfccradle: Int32 = 0
    var _rssirearLeft: Int32 = 0
    var _rssirearRight: Int32 = 0
    var _highThreshLeftPresent: Bool = false
    var _highThreshRightPresent: Bool = false
    var _highThreshCenterPresent: Bool = false
    var _highThreshFrontPresent: Bool = false
    var _highThreshRearPresent: Bool = false
    var _highThreshRearLeftPresent: Bool = false
    var _highThreshRearRightPresent: Bool = false
    var _highThreshSecondaryPresent: Bool = false
    var _highThreshNfcpresent: Bool = false
    var _sortedDeltaBayesLeftPresent: Bool = false
    var _sortedDeltaBayesRightPresent: Bool = false
    var _rawDeltaBayesLeftPresent: Bool = false
    var _rawDeltaBayesRightPresent: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _keyChannel = source._keyChannel
      _authenticationLevel = source._authenticationLevel
      _present = source._present
      _rssileft = source._rssileft
      _rssiright = source._rssiright
      _rssirear = source._rssirear
      _rssicenter = source._rssicenter
      _rssifront = source._rssifront
      _rssisecondary = source._rssisecondary
      _rssinfccradle = source._rssinfccradle
      _rssirearLeft = source._rssirearLeft
      _rssirearRight = source._rssirearRight
      _highThreshLeftPresent = source._highThreshLeftPresent
      _highThreshRightPresent = source._highThreshRightPresent
      _highThreshCenterPresent = source._highThreshCenterPresent
      _highThreshFrontPresent = source._highThreshFrontPresent
      _highThreshRearPresent = source._highThreshRearPresent
      _highThreshRearLeftPresent = source._highThreshRearLeftPresent
      _highThreshRearRightPresent = source._highThreshRearRightPresent
      _highThreshSecondaryPresent = source._highThreshSecondaryPresent
      _highThreshNfcpresent = source._highThreshNfcpresent
      _sortedDeltaBayesLeftPresent = source._sortedDeltaBayesLeftPresent
      _sortedDeltaBayesRightPresent = source._sortedDeltaBayesRightPresent
      _rawDeltaBayesLeftPresent = source._rawDeltaBayesLeftPresent
      _rawDeltaBayesRightPresent = source._rawDeltaBayesRightPresent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._keyChannel) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._authenticationLevel) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._present) }()
        case 4: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssileft) }()
        case 5: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssiright) }()
        case 6: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssirear) }()
        case 7: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssicenter) }()
        case 8: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssifront) }()
        case 9: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssisecondary) }()
        case 10: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssinfccradle) }()
        case 11: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssirearLeft) }()
        case 12: try { try decoder.decodeSingularSInt32Field(value: &_storage._rssirearRight) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshLeftPresent) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshRightPresent) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshCenterPresent) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshFrontPresent) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshRearPresent) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshRearLeftPresent) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshRearRightPresent) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshSecondaryPresent) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._highThreshNfcpresent) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._sortedDeltaBayesLeftPresent) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._sortedDeltaBayesRightPresent) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._rawDeltaBayesLeftPresent) }()
        case 25: try { try decoder.decodeSingularBoolField(value: &_storage._rawDeltaBayesRightPresent) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._keyChannel != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._keyChannel, fieldNumber: 1)
      }
      if _storage._authenticationLevel != .authenticationLevelNone {
        try visitor.visitSingularEnumField(value: _storage._authenticationLevel, fieldNumber: 2)
      }
      if _storage._present != false {
        try visitor.visitSingularBoolField(value: _storage._present, fieldNumber: 3)
      }
      if _storage._rssileft != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssileft, fieldNumber: 4)
      }
      if _storage._rssiright != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssiright, fieldNumber: 5)
      }
      if _storage._rssirear != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssirear, fieldNumber: 6)
      }
      if _storage._rssicenter != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssicenter, fieldNumber: 7)
      }
      if _storage._rssifront != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssifront, fieldNumber: 8)
      }
      if _storage._rssisecondary != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssisecondary, fieldNumber: 9)
      }
      if _storage._rssinfccradle != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssinfccradle, fieldNumber: 10)
      }
      if _storage._rssirearLeft != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssirearLeft, fieldNumber: 11)
      }
      if _storage._rssirearRight != 0 {
        try visitor.visitSingularSInt32Field(value: _storage._rssirearRight, fieldNumber: 12)
      }
      if _storage._highThreshLeftPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshLeftPresent, fieldNumber: 13)
      }
      if _storage._highThreshRightPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshRightPresent, fieldNumber: 14)
      }
      if _storage._highThreshCenterPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshCenterPresent, fieldNumber: 15)
      }
      if _storage._highThreshFrontPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshFrontPresent, fieldNumber: 16)
      }
      if _storage._highThreshRearPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshRearPresent, fieldNumber: 17)
      }
      if _storage._highThreshRearLeftPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshRearLeftPresent, fieldNumber: 18)
      }
      if _storage._highThreshRearRightPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshRearRightPresent, fieldNumber: 19)
      }
      if _storage._highThreshSecondaryPresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshSecondaryPresent, fieldNumber: 20)
      }
      if _storage._highThreshNfcpresent != false {
        try visitor.visitSingularBoolField(value: _storage._highThreshNfcpresent, fieldNumber: 21)
      }
      if _storage._sortedDeltaBayesLeftPresent != false {
        try visitor.visitSingularBoolField(value: _storage._sortedDeltaBayesLeftPresent, fieldNumber: 22)
      }
      if _storage._sortedDeltaBayesRightPresent != false {
        try visitor.visitSingularBoolField(value: _storage._sortedDeltaBayesRightPresent, fieldNumber: 23)
      }
      if _storage._rawDeltaBayesLeftPresent != false {
        try visitor.visitSingularBoolField(value: _storage._rawDeltaBayesLeftPresent, fieldNumber: 24)
      }
      if _storage._rawDeltaBayesRightPresent != false {
        try visitor.visitSingularBoolField(value: _storage._rawDeltaBayesRightPresent, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HandlePulledWithoutAuthDeviceSpecificPayload, rhs: HandlePulledWithoutAuthDeviceSpecificPayload) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._keyChannel != rhs_storage._keyChannel {return false}
        if _storage._authenticationLevel != rhs_storage._authenticationLevel {return false}
        if _storage._present != rhs_storage._present {return false}
        if _storage._rssileft != rhs_storage._rssileft {return false}
        if _storage._rssiright != rhs_storage._rssiright {return false}
        if _storage._rssirear != rhs_storage._rssirear {return false}
        if _storage._rssicenter != rhs_storage._rssicenter {return false}
        if _storage._rssifront != rhs_storage._rssifront {return false}
        if _storage._rssisecondary != rhs_storage._rssisecondary {return false}
        if _storage._rssinfccradle != rhs_storage._rssinfccradle {return false}
        if _storage._rssirearLeft != rhs_storage._rssirearLeft {return false}
        if _storage._rssirearRight != rhs_storage._rssirearRight {return false}
        if _storage._highThreshLeftPresent != rhs_storage._highThreshLeftPresent {return false}
        if _storage._highThreshRightPresent != rhs_storage._highThreshRightPresent {return false}
        if _storage._highThreshCenterPresent != rhs_storage._highThreshCenterPresent {return false}
        if _storage._highThreshFrontPresent != rhs_storage._highThreshFrontPresent {return false}
        if _storage._highThreshRearPresent != rhs_storage._highThreshRearPresent {return false}
        if _storage._highThreshRearLeftPresent != rhs_storage._highThreshRearLeftPresent {return false}
        if _storage._highThreshRearRightPresent != rhs_storage._highThreshRearRightPresent {return false}
        if _storage._highThreshSecondaryPresent != rhs_storage._highThreshSecondaryPresent {return false}
        if _storage._highThreshNfcpresent != rhs_storage._highThreshNfcpresent {return false}
        if _storage._sortedDeltaBayesLeftPresent != rhs_storage._sortedDeltaBayesLeftPresent {return false}
        if _storage._sortedDeltaBayesRightPresent != rhs_storage._sortedDeltaBayesRightPresent {return false}
        if _storage._rawDeltaBayesLeftPresent != rhs_storage._rawDeltaBayesLeftPresent {return false}
        if _storage._rawDeltaBayesRightPresent != rhs_storage._rawDeltaBayesRightPresent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InformationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InformationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "informationRequestType"),
    2: .same(proto: "keyId"),
    3: .same(proto: "publicKey"),
    4: .same(proto: "slot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.informationRequestType) }()
      case 2: try {
        var v: KeyIdentifier?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .keyID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .keyID(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .publicKey(v)
        }
      }()
      case 4: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .slot(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.informationRequestType != .getStatus {
      try visitor.visitSingularEnumField(value: self.informationRequestType, fieldNumber: 1)
    }
    switch self.subMessage {
    case .keyID?: try {
      guard case .keyID(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .publicKey?: try {
      guard case .publicKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .slot?: try {
      guard case .slot(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InformationRequest, rhs: InformationRequest) -> Bool {
    if lhs.informationRequestType != rhs.informationRequestType {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KeyfobInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "KeyfobInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appCRC"),
    2: .standard(proto: "batteryVoltage_mV"),
    3: .standard(proto: "temperature_degreesC"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.appCrc) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.batteryVoltageMV) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.temperatureDegreesC) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appCrc.isEmpty {
      try visitor.visitSingularBytesField(value: self.appCrc, fieldNumber: 1)
    }
    if self.batteryVoltageMV != 0 {
      try visitor.visitSingularUInt32Field(value: self.batteryVoltageMV, fieldNumber: 2)
    }
    if self.temperatureDegreesC != 0 {
      try visitor.visitSingularInt32Field(value: self.temperatureDegreesC, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KeyfobInfo, rhs: KeyfobInfo) -> Bool {
    if lhs.appCrc != rhs.appCrc {return false}
    if lhs.batteryVoltageMV != rhs.batteryVoltageMV {return false}
    if lhs.temperatureDegreesC != rhs.temperatureDegreesC {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KeyIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "KeyIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKeySHA1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKeySha1) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKeySha1.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKeySha1, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KeyIdentifier, rhs: KeyIdentifier) -> Bool {
    if lhs.publicKeySha1 != rhs.publicKeySha1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KeyMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "KeyMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyFormFactor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.keyFormFactor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyFormFactor != .unknown {
      try visitor.visitSingularEnumField(value: self.keyFormFactor, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KeyMetadata, rhs: KeyMetadata) -> Bool {
    if lhs.keyFormFactor != rhs.keyFormFactor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KeyStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "KeyStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyId"),
    2: .same(proto: "nfcPresence"),
    3: .same(proto: "blePresence"),
    4: .same(proto: "publicKey"),
    5: .same(proto: "keyFormFactor"),
    6: .same(proto: "slot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.nfcPresence) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.blePresence) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.keyFormFactor) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.slot) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.nfcPresence != .notPresent {
      try visitor.visitSingularEnumField(value: self.nfcPresence, fieldNumber: 2)
    }
    if self.blePresence != .notPresent {
      try visitor.visitSingularEnumField(value: self.blePresence, fieldNumber: 3)
    }
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.keyFormFactor != .unknown {
      try visitor.visitSingularEnumField(value: self.keyFormFactor, fieldNumber: 5)
    }
    if self.slot != 0 {
      try visitor.visitSingularUInt32Field(value: self.slot, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KeyStatus, rhs: KeyStatus) -> Bool {
    if lhs._keyID != rhs._keyID {return false}
    if lhs.nfcPresence != rhs.nfcPresence {return false}
    if lhs.blePresence != rhs.blePresence {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.keyFormFactor != rhs.keyFormFactor {return false}
    if lhs.slot != rhs.slot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KeyStatusInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "KeyStatusInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyStatuses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keyStatuses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyStatuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyStatuses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: KeyStatusInfo, rhs: KeyStatusInfo) -> Bool {
    if lhs.keyStatuses != rhs.keyStatuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MIConfigurationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MIConfigurationData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data_) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data_.isEmpty {
      try visitor.visitSingularBytesField(value: self.data_, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MIConfigurationData, rhs: MIConfigurationData) -> Bool {
    if lhs.data_ != rhs.data_ {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MISessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MISessionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessionId"),
    2: .same(proto: "accessoryConfigurationData"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.accessoryConfigurationData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sessionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.sessionID, fieldNumber: 1)
    }
    if !self.accessoryConfigurationData.isEmpty {
      try visitor.visitSingularBytesField(value: self.accessoryConfigurationData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MISessionRequest, rhs: MISessionRequest) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.accessoryConfigurationData != rhs.accessoryConfigurationData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MISessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MISessionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessionId"),
    2: .same(proto: "MIConfigurationData"),
    3: .same(proto: "errorCode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sessionID) }()
      case 2: try {
        var v: MIConfigurationData?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .miconfigurationData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .miconfigurationData(v)
        }
      }()
      case 3: try {
        var v: MIError_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .errorCode(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.sessionID != 0 {
      try visitor.visitSingularUInt32Field(value: self.sessionID, fieldNumber: 1)
    }
    switch self.subMessage {
    case .miconfigurationData?: try {
      guard case .miconfigurationData(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .errorCode?: try {
      guard case .errorCode(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MISessionResponse, rhs: MISessionResponse) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MISessionStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MISessionStop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .sessionID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .sessionID(let v)? = self.subMessage {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MISessionStop, rhs: MISessionStop) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MISessionStopped: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MISessionStopped"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .sessionID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .sessionID(let v)? = self.subMessage {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MISessionStopped, rhs: MISessionStopped) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NFCSEState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NFCSEState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devicePubKeyState"),
    2: .same(proto: "vehiclePubKeyState"),
    3: .same(proto: "sharedSecretState"),
    4: .same(proto: "insecureCommandState"),
    5: .same(proto: "vehiclePubKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.devicePubKeyState) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.vehiclePubKeyState) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.sharedSecretState) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.insecureCommandState) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._vehiclePubKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.devicePubKeyState != .nfcsecDevicepubkeyStateNone {
      try visitor.visitSingularEnumField(value: self.devicePubKeyState, fieldNumber: 1)
    }
    if self.vehiclePubKeyState != .nfcsecVehiclepubkeyStateNone {
      try visitor.visitSingularEnumField(value: self.vehiclePubKeyState, fieldNumber: 2)
    }
    if self.sharedSecretState != .nfcsecSharedsecretStateNone {
      try visitor.visitSingularEnumField(value: self.sharedSecretState, fieldNumber: 3)
    }
    if self.insecureCommandState != .nfcsecInsecureCommandStateNone {
      try visitor.visitSingularEnumField(value: self.insecureCommandState, fieldNumber: 4)
    }
    try { if let v = self._vehiclePubKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NFCSEState, rhs: NFCSEState) -> Bool {
    if lhs.devicePubKeyState != rhs.devicePubKeyState {return false}
    if lhs.vehiclePubKeyState != rhs.vehiclePubKeyState {return false}
    if lhs.sharedSecretState != rhs.sharedSecretState {return false}
    if lhs.insecureCommandState != rhs.insecureCommandState {return false}
    if lhs._vehiclePubKey != rhs._vehiclePubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PermissionChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PermissionChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "permission"),
    3: .same(proto: "secondsToBeActive"),
    4: .same(proto: "keyRole"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.permission) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.secondsToBeActive) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.keyRole) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.permission.isEmpty {
      try visitor.visitPackedEnumField(value: self.permission, fieldNumber: 2)
    }
    if self.secondsToBeActive != 0 {
      try visitor.visitSingularUInt32Field(value: self.secondsToBeActive, fieldNumber: 3)
    }
    if self.keyRole != .none {
      try visitor.visitSingularEnumField(value: self.keyRole, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PermissionChange, rhs: PermissionChange) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.permission != rhs.permission {return false}
    if lhs.secondsToBeActive != rhs.secondsToBeActive {return false}
    if lhs.keyRole != rhs.keyRole {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PersonalizationInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PersonalizationInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VIN"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.vin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vin.isEmpty {
      try visitor.visitSingularBytesField(value: self.vin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PersonalizationInformation, rhs: PersonalizationInformation) -> Bool {
    if lhs.vin != rhs.vin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PhoneVersionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PhoneVersionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "os_version_major"),
    2: .standard(proto: "os_version_minor"),
    3: .standard(proto: "os_version_patch"),
    4: .standard(proto: "app_version_major"),
    5: .standard(proto: "app_version_minor"),
    6: .standard(proto: "app_version_patch"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.osVersionMajor) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.osVersionMinor) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.osVersionPatch) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.appVersionMajor) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.appVersionMinor) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.appVersionPatch) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.osVersionMajor != 0 {
      try visitor.visitSingularUInt32Field(value: self.osVersionMajor, fieldNumber: 1)
    }
    if self.osVersionMinor != 0 {
      try visitor.visitSingularUInt32Field(value: self.osVersionMinor, fieldNumber: 2)
    }
    if self.osVersionPatch != 0 {
      try visitor.visitSingularUInt32Field(value: self.osVersionPatch, fieldNumber: 3)
    }
    if self.appVersionMajor != 0 {
      try visitor.visitSingularUInt32Field(value: self.appVersionMajor, fieldNumber: 4)
    }
    if self.appVersionMinor != 0 {
      try visitor.visitSingularUInt32Field(value: self.appVersionMinor, fieldNumber: 5)
    }
    if self.appVersionPatch != 0 {
      try visitor.visitSingularUInt32Field(value: self.appVersionPatch, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PhoneVersionInfo, rhs: PhoneVersionInfo) -> Bool {
    if lhs.osVersionMajor != rhs.osVersionMajor {return false}
    if lhs.osVersionMinor != rhs.osVersionMinor {return false}
    if lhs.osVersionPatch != rhs.osVersionPatch {return false}
    if lhs.appVersionMajor != rhs.appVersionMajor {return false}
    if lhs.appVersionMinor != rhs.appVersionMinor {return false}
    if lhs.appVersionPatch != rhs.appVersionPatch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PublicKeyRaw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKeyRaw) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKeyRaw.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKeyRaw, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PublicKey, rhs: PublicKey) -> Bool {
    if lhs.publicKeyRaw != rhs.publicKeyRaw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PublicKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PublicKeyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "publicKeyStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.publicKeyStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.publicKeyStatus != .publicKeyStatusNone {
      try visitor.visitSingularEnumField(value: self.publicKeyStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PublicKeyResponse, rhs: PublicKeyResponse) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.publicKeyStatus != rhs.publicKeyStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RCISignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RCISignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .same(proto: "tag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.tag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 1)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularBytesField(value: self.tag, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RCISignature, rhs: RCISignature) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ReplaceKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ReplaceKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "keyToAdd"),
    4: .same(proto: "keyRole"),
    5: .same(proto: "impermanent"),
    1: .same(proto: "publicKeyToReplace"),
    2: .same(proto: "slotToReplace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PublicKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .publicKeyToReplace(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .publicKeyToReplace(v)
        }
      }()
      case 2: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .slotToReplace(v)
        }
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._keyToAdd) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.keyRole) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.impermanent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .publicKeyToReplace?: try {
      guard case .publicKeyToReplace(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .slotToReplace?: try {
      guard case .slotToReplace(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._keyToAdd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.keyRole != .none {
      try visitor.visitSingularEnumField(value: self.keyRole, fieldNumber: 4)
    }
    if self.impermanent != false {
      try visitor.visitSingularBoolField(value: self.impermanent, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ReplaceKey, rhs: ReplaceKey) -> Bool {
    if lhs._keyToAdd != rhs._keyToAdd {return false}
    if lhs.keyRole != rhs.keyRole {return false}
    if lhs.impermanent != rhs.impermanent {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ResetTrackerStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ResetTrackerStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "totalResetsDueToPowerOn"),
    2: .same(proto: "totalResetsDueToPinReset"),
    3: .same(proto: "totalResetsDueToVDDSLoss"),
    4: .same(proto: "totalResetsDueToVDDLoss"),
    5: .same(proto: "totalResetsDueToVDDRLoss"),
    6: .same(proto: "totalResetsDueToClockLoss"),
    7: .same(proto: "totalResetsDueToSystemReset"),
    8: .same(proto: "totalResetsDueToWarmReset"),
    9: .same(proto: "totalResetsDueToWakeupFromShutdown"),
    10: .same(proto: "totalResetsDueToWakeupFromTCKNoise"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToPowerOn) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToPinReset) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToVddsloss) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToVddloss) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToVddrloss) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToClockLoss) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToSystemReset) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToWarmReset) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToWakeupFromShutdown) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.totalResetsDueToWakeupFromTcknoise) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalResetsDueToPowerOn != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToPowerOn, fieldNumber: 1)
    }
    if self.totalResetsDueToPinReset != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToPinReset, fieldNumber: 2)
    }
    if self.totalResetsDueToVddsloss != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToVddsloss, fieldNumber: 3)
    }
    if self.totalResetsDueToVddloss != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToVddloss, fieldNumber: 4)
    }
    if self.totalResetsDueToVddrloss != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToVddrloss, fieldNumber: 5)
    }
    if self.totalResetsDueToClockLoss != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToClockLoss, fieldNumber: 6)
    }
    if self.totalResetsDueToSystemReset != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToSystemReset, fieldNumber: 7)
    }
    if self.totalResetsDueToWarmReset != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToWarmReset, fieldNumber: 8)
    }
    if self.totalResetsDueToWakeupFromShutdown != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToWakeupFromShutdown, fieldNumber: 9)
    }
    if self.totalResetsDueToWakeupFromTcknoise != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalResetsDueToWakeupFromTcknoise, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ResetTrackerStats, rhs: ResetTrackerStats) -> Bool {
    if lhs.totalResetsDueToPowerOn != rhs.totalResetsDueToPowerOn {return false}
    if lhs.totalResetsDueToPinReset != rhs.totalResetsDueToPinReset {return false}
    if lhs.totalResetsDueToVddsloss != rhs.totalResetsDueToVddsloss {return false}
    if lhs.totalResetsDueToVddloss != rhs.totalResetsDueToVddloss {return false}
    if lhs.totalResetsDueToVddrloss != rhs.totalResetsDueToVddrloss {return false}
    if lhs.totalResetsDueToClockLoss != rhs.totalResetsDueToClockLoss {return false}
    if lhs.totalResetsDueToSystemReset != rhs.totalResetsDueToSystemReset {return false}
    if lhs.totalResetsDueToWarmReset != rhs.totalResetsDueToWarmReset {return false}
    if lhs.totalResetsDueToWakeupFromShutdown != rhs.totalResetsDueToWakeupFromShutdown {return false}
    if lhs.totalResetsDueToWakeupFromTcknoise != rhs.totalResetsDueToWakeupFromTcknoise {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RFMonitorCounterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RFMonitorCounterResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RFInterruptCounter"),
    2: .same(proto: "advCompleteCounter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.rfinterruptCounter) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.advCompleteCounter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rfinterruptCounter != 0 {
      try visitor.visitSingularUInt32Field(value: self.rfinterruptCounter, fieldNumber: 1)
    }
    if self.advCompleteCounter != 0 {
      try visitor.visitSingularUInt32Field(value: self.advCompleteCounter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RFMonitorCounterResponse, rhs: RFMonitorCounterResponse) -> Bool {
    if lhs.rfinterruptCounter != rhs.rfinterruptCounter {return false}
    if lhs.advCompleteCounter != rhs.advCompleteCounter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SetTPConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SetTPConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .same(proto: "permanentConfig"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.permanentConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.permanentConfig != false {
      try visitor.visitSingularBoolField(value: self.permanentConfig, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SetTPConfiguration, rhs: SetTPConfiguration) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.permanentConfig != rhs.permanentConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SetUpdaterLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SetUpdaterLocation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterLocation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.updaterLocation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.updaterLocation != .none {
      try visitor.visitSingularEnumField(value: self.updaterLocation, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SetUpdaterLocation, rhs: SetUpdaterLocation) -> Bool {
    if lhs.updaterLocation != rhs.updaterLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Signatures"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signatures, rhs: Signatures) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Signatures.SessionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Signatures.protoMessageName + ".SessionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "counter"),
    2: .same(proto: "publicKey"),
    3: .same(proto: "epoch"),
    4: .standard(proto: "clock_time"),
    5: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.counter) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.epoch) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self.clockTime) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.counter != 0 {
      try visitor.visitSingularUInt32Field(value: self.counter, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 2)
    }
    if !self.epoch.isEmpty {
      try visitor.visitSingularBytesField(value: self.epoch, fieldNumber: 3)
    }
    if self.clockTime != 0 {
      try visitor.visitSingularFixed32Field(value: self.clockTime, fieldNumber: 4)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Signatures.SessionInfo, rhs: Signatures.SessionInfo) -> Bool {
    if lhs.counter != rhs.counter {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.clockTime != rhs.clockTime {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SignedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "protobufMessageAsBytes"),
    3: .same(proto: "signatureType"),
    4: .same(proto: "signature"),
    5: .same(proto: "keyId"),
    6: .same(proto: "counter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.protobufMessageAsBytes) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.signatureType) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.keyID) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.counter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularBytesField(value: self.token, fieldNumber: 1)
    }
    if !self.protobufMessageAsBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.protobufMessageAsBytes, fieldNumber: 2)
    }
    if self.signatureType != .aesGcm {
      try visitor.visitSingularEnumField(value: self.signatureType, fieldNumber: 3)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 4)
    }
    if !self.keyID.isEmpty {
      try visitor.visitSingularBytesField(value: self.keyID, fieldNumber: 5)
    }
    if self.counter != 0 {
      try visitor.visitSingularUInt32Field(value: self.counter, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignedMessage, rhs: SignedMessage) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.protobufMessageAsBytes != rhs.protobufMessageAsBytes {return false}
    if lhs.signatureType != rhs.signatureType {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.counter != rhs.counter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignedMessage_status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SignedMessage_status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "counter"),
    2: .same(proto: "signedMessageInformation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.counter) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.signedMessageInformation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.counter != 0 {
      try visitor.visitSingularUInt32Field(value: self.counter, fieldNumber: 1)
    }
    if self.signedMessageInformation != .signedmessageInformationNone {
      try visitor.visitSingularEnumField(value: self.signedMessageInformation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignedMessage_status, rhs: SignedMessage_status) -> Bool {
    if lhs.counter != rhs.counter {return false}
    if lhs.signedMessageInformation != rhs.signedMessageInformation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SleepManagerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SleepManagerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delaySleepRequest"),
    2: .same(proto: "sleepManagerCommand"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: DelaySleepRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .delaySleepRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .delaySleepRequest(v)
        }
      }()
      case 2: try {
        var v: SleepManagerCommand_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .sleepManagerCommand(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .delaySleepRequest?: try {
      guard case .delaySleepRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sleepManagerCommand?: try {
      guard case .sleepManagerCommand(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SleepManagerRequest, rhs: SleepManagerRequest) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SleepManagerStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SleepManagerStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "totalCPUTime"),
    2: .same(proto: "totalAwakeTime"),
    3: .same(proto: "isBLETrimApplied"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.totalCputime) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.totalAwakeTime) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.isBletrimApplied) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalCputime != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalCputime, fieldNumber: 1)
    }
    if self.totalAwakeTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalAwakeTime, fieldNumber: 2)
    }
    if self.isBletrimApplied != .bleAdditionalTrimAppliedNone {
      try visitor.visitSingularEnumField(value: self.isBletrimApplied, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SleepManagerStats, rhs: SleepManagerStats) -> Bool {
    if lhs.totalCputime != rhs.totalCputime {return false}
    if lhs.totalAwakeTime != rhs.totalAwakeTime {return false}
    if lhs.isBletrimApplied != rhs.isBletrimApplied {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StageBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StageBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockAddress"),
    2: .same(proto: "blockToStage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.blockAddress) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.blockToStage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.blockAddress != 0 {
      try visitor.visitSingularUInt32Field(value: self.blockAddress, fieldNumber: 1)
    }
    if !self.blockToStage.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockToStage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StageBlock, rhs: StageBlock) -> Bool {
    if lhs.blockAddress != rhs.blockAddress {return false}
    if lhs.blockToStage != rhs.blockToStage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ToRCI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ToRCI"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .standard(proto: "HMAC_signature"),
    3: .standard(proto: "rci_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.command) }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .hmacSignature(v)
        }
      }()
      case 3: try {
        var v: RCISignature?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .rciSignature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .rciSignature(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.command.isEmpty {
      try visitor.visitSingularBytesField(value: self.command, fieldNumber: 1)
    }
    switch self.subMessage {
    case .hmacSignature?: try {
      guard case .hmacSignature(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .rciSignature?: try {
      guard case .rciSignature(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ToRCI, rhs: ToRCI) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ToVCSECMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ToVCSECMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signedMessage"),
    2: .same(proto: "unsignedMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SignedMessage?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .signedMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .signedMessage(v)
        }
      }()
      case 2: try {
        var v: UnsignedMessage?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .unsignedMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .unsignedMessage(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .signedMessage?: try {
      guard case .signedMessage(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .unsignedMessage?: try {
      guard case .unsignedMessage(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ToVCSECMessage, rhs: ToVCSECMessage) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TPAdv: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TPAdv"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pressure"),
    2: .same(proto: "temperature"),
    3: .same(proto: "TPNotifyReason"),
    4: .standard(proto: "batteryVoltage_mV"),
    5: .same(proto: "advertismentCount"),
    6: .same(proto: "TPMSAdvType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pressure) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self.temperature) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.tpnotifyReason) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.batteryVoltageMV) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.advertismentCount) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.tpmsadvType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pressure != 0 {
      try visitor.visitSingularInt32Field(value: self.pressure, fieldNumber: 1)
    }
    if self.temperature != 0 {
      try visitor.visitSingularSInt32Field(value: self.temperature, fieldNumber: 2)
    }
    if self.tpnotifyReason != .tpNotifyReasonUnknown {
      try visitor.visitSingularEnumField(value: self.tpnotifyReason, fieldNumber: 3)
    }
    if self.batteryVoltageMV != 0 {
      try visitor.visitSingularUInt32Field(value: self.batteryVoltageMV, fieldNumber: 4)
    }
    if self.advertismentCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.advertismentCount, fieldNumber: 5)
    }
    if self.tpmsadvType != .tpmsAdvTypeSemi {
      try visitor.visitSingularEnumField(value: self.tpmsadvType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TPAdv, rhs: TPAdv) -> Bool {
    if lhs.pressure != rhs.pressure {return false}
    if lhs.temperature != rhs.temperature {return false}
    if lhs.tpnotifyReason != rhs.tpnotifyReason {return false}
    if lhs.batteryVoltageMV != rhs.batteryVoltageMV {return false}
    if lhs.advertismentCount != rhs.advertismentCount {return false}
    if lhs.tpmsadvType != rhs.tpmsadvType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TPCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TPCapabilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pressureInAdv"),
    2: .same(proto: "configurableIntervalThreshold"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.pressureInAdv) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.configurableIntervalThreshold) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pressureInAdv != false {
      try visitor.visitSingularBoolField(value: self.pressureInAdv, fieldNumber: 1)
    }
    if self.configurableIntervalThreshold != false {
      try visitor.visitSingularBoolField(value: self.configurableIntervalThreshold, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TPCapabilities, rhs: TPCapabilities) -> Bool {
    if lhs.pressureInAdv != rhs.pressureInAdv {return false}
    if lhs.configurableIntervalThreshold != rhs.configurableIntervalThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TPConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TPConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stationaryConfig"),
    2: .same(proto: "motionConfig"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: TPStationaryConfig?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .stationaryConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .stationaryConfig(v)
        }
      }()
      case 2: try {
        var v: TPMotionConfig?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .motionConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .motionConfig(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .stationaryConfig?: try {
      guard case .stationaryConfig(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .motionConfig?: try {
      guard case .motionConfig(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TPConfiguration, rhs: TPConfiguration) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TPData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TPData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pressure"),
    2: .same(proto: "temperature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pressure) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self.temperature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pressure != 0 {
      try visitor.visitSingularInt32Field(value: self.pressure, fieldNumber: 1)
    }
    if self.temperature != 0 {
      try visitor.visitSingularSInt32Field(value: self.temperature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TPData, rhs: TPData) -> Bool {
    if lhs.pressure != rhs.pressure {return false}
    if lhs.temperature != rhs.temperature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TPLRDetection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TPLRDetection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "LRDetectionResult"),
    2: .standard(proto: "totalPeriod_ms"),
    3: .same(proto: "x90degCnt"),
    4: .same(proto: "x270degCnt"),
    5: .standard(proto: "zAcceleration_dg"),
    6: .same(proto: "zAccelDiffCnt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.lrdetectionResult) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.totalPeriodMs) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.x90DegCnt) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.x270DegCnt) }()
      case 5: try { try decoder.decodeSingularSInt32Field(value: &self.zAccelerationDg) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.zAccelDiffCnt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lrdetectionResult != .rrorMaxcnt {
      try visitor.visitSingularEnumField(value: self.lrdetectionResult, fieldNumber: 1)
    }
    if self.totalPeriodMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalPeriodMs, fieldNumber: 2)
    }
    if self.x90DegCnt != 0 {
      try visitor.visitSingularUInt32Field(value: self.x90DegCnt, fieldNumber: 3)
    }
    if self.x270DegCnt != 0 {
      try visitor.visitSingularUInt32Field(value: self.x270DegCnt, fieldNumber: 4)
    }
    if self.zAccelerationDg != 0 {
      try visitor.visitSingularSInt32Field(value: self.zAccelerationDg, fieldNumber: 5)
    }
    if self.zAccelDiffCnt != 0 {
      try visitor.visitSingularUInt32Field(value: self.zAccelDiffCnt, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TPLRDetection, rhs: TPLRDetection) -> Bool {
    if lhs.lrdetectionResult != rhs.lrdetectionResult {return false}
    if lhs.totalPeriodMs != rhs.totalPeriodMs {return false}
    if lhs.x90DegCnt != rhs.x90DegCnt {return false}
    if lhs.x270DegCnt != rhs.x270DegCnt {return false}
    if lhs.zAccelerationDg != rhs.zAccelerationDg {return false}
    if lhs.zAccelDiffCnt != rhs.zAccelDiffCnt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TPMotionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TPMotionConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pressureDelta"),
    2: .same(proto: "temperatureDelta"),
    3: .same(proto: "motionPeriod"),
    4: .same(proto: "accelMeasureMod"),
    5: .same(proto: "PTMeasureMod"),
    6: .same(proto: "motionDuration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.pressureDelta) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.temperatureDelta) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.motionPeriod) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.accelMeasureMod) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.ptmeasureMod) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.motionDuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pressureDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.pressureDelta, fieldNumber: 1)
    }
    if self.temperatureDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.temperatureDelta, fieldNumber: 2)
    }
    if self.motionPeriod != .mlxwakeperiod2Ms {
      try visitor.visitSingularEnumField(value: self.motionPeriod, fieldNumber: 3)
    }
    if self.accelMeasureMod != 0 {
      try visitor.visitSingularUInt32Field(value: self.accelMeasureMod, fieldNumber: 4)
    }
    if self.ptmeasureMod != 0 {
      try visitor.visitSingularUInt32Field(value: self.ptmeasureMod, fieldNumber: 5)
    }
    if self.motionDuration != 0 {
      try visitor.visitSingularUInt32Field(value: self.motionDuration, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TPMotionConfig, rhs: TPMotionConfig) -> Bool {
    if lhs.pressureDelta != rhs.pressureDelta {return false}
    if lhs.temperatureDelta != rhs.temperatureDelta {return false}
    if lhs.motionPeriod != rhs.motionPeriod {return false}
    if lhs.accelMeasureMod != rhs.accelMeasureMod {return false}
    if lhs.ptmeasureMod != rhs.ptmeasureMod {return false}
    if lhs.motionDuration != rhs.motionDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TPMSAlarms: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TPMSAlarms"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pressure"),
    2: .same(proto: "temperature"),
    3: .same(proto: "acceleration"),
    4: .same(proto: "voltage"),
    5: .same(proto: "LFDetect"),
    6: .same(proto: "wheelMotion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.pressure) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.temperature) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.acceleration) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.voltage) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.lfdetect) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.wheelMotion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pressure != false {
      try visitor.visitSingularBoolField(value: self.pressure, fieldNumber: 1)
    }
    if self.temperature != false {
      try visitor.visitSingularBoolField(value: self.temperature, fieldNumber: 2)
    }
    if self.acceleration != false {
      try visitor.visitSingularBoolField(value: self.acceleration, fieldNumber: 3)
    }
    if self.voltage != false {
      try visitor.visitSingularBoolField(value: self.voltage, fieldNumber: 4)
    }
    if self.lfdetect != false {
      try visitor.visitSingularBoolField(value: self.lfdetect, fieldNumber: 5)
    }
    if self.wheelMotion != false {
      try visitor.visitSingularBoolField(value: self.wheelMotion, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TPMSAlarms, rhs: TPMSAlarms) -> Bool {
    if lhs.pressure != rhs.pressure {return false}
    if lhs.temperature != rhs.temperature {return false}
    if lhs.acceleration != rhs.acceleration {return false}
    if lhs.voltage != rhs.voltage {return false}
    if lhs.lfdetect != rhs.lfdetect {return false}
    if lhs.wheelMotion != rhs.wheelMotion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TPNewSensorData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TPNewSensorData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sensorPublicKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sensorPublicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sensorPublicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TPNewSensorData, rhs: TPNewSensorData) -> Bool {
    if lhs._sensorPublicKey != rhs._sensorPublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TPNotifyTrackerStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TPNotifyTrackerStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notifyReasonUnknownCount"),
    2: .same(proto: "notifyReasonLowPressureCount"),
    3: .same(proto: "notifyReasonPTValueUpdateCount"),
    4: .same(proto: "notifyReasonWheelMovingCount"),
    5: .same(proto: "notifyReasonWheelRotationDirectionReadyCount"),
    6: .same(proto: "notifyReasonLFCount"),
    7: .same(proto: "notifyReasonFaultCount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.notifyReasonUnknownCount) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.notifyReasonLowPressureCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.notifyReasonPtvalueUpdateCount) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.notifyReasonWheelMovingCount) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.notifyReasonWheelRotationDirectionReadyCount) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.notifyReasonLfcount) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.notifyReasonFaultCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.notifyReasonUnknownCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifyReasonUnknownCount, fieldNumber: 1)
    }
    if self.notifyReasonLowPressureCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifyReasonLowPressureCount, fieldNumber: 2)
    }
    if self.notifyReasonPtvalueUpdateCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifyReasonPtvalueUpdateCount, fieldNumber: 3)
    }
    if self.notifyReasonWheelMovingCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifyReasonWheelMovingCount, fieldNumber: 4)
    }
    if self.notifyReasonWheelRotationDirectionReadyCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifyReasonWheelRotationDirectionReadyCount, fieldNumber: 5)
    }
    if self.notifyReasonLfcount != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifyReasonLfcount, fieldNumber: 6)
    }
    if self.notifyReasonFaultCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.notifyReasonFaultCount, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TPNotifyTrackerStats, rhs: TPNotifyTrackerStats) -> Bool {
    if lhs.notifyReasonUnknownCount != rhs.notifyReasonUnknownCount {return false}
    if lhs.notifyReasonLowPressureCount != rhs.notifyReasonLowPressureCount {return false}
    if lhs.notifyReasonPtvalueUpdateCount != rhs.notifyReasonPtvalueUpdateCount {return false}
    if lhs.notifyReasonWheelMovingCount != rhs.notifyReasonWheelMovingCount {return false}
    if lhs.notifyReasonWheelRotationDirectionReadyCount != rhs.notifyReasonWheelRotationDirectionReadyCount {return false}
    if lhs.notifyReasonLfcount != rhs.notifyReasonLfcount {return false}
    if lhs.notifyReasonFaultCount != rhs.notifyReasonFaultCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TPStationaryConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TPStationaryConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lowPressureThreshold"),
    2: .same(proto: "pressureDelta"),
    3: .same(proto: "stationaryTaskPeriod"),
    4: .same(proto: "pressureMeasureMod"),
    5: .same(proto: "accelMeasureMod"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.lowPressureThreshold) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pressureDelta) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.stationaryTaskPeriod) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.pressureMeasureMod) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.accelMeasureMod) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lowPressureThreshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.lowPressureThreshold, fieldNumber: 1)
    }
    if self.pressureDelta != 0 {
      try visitor.visitSingularUInt32Field(value: self.pressureDelta, fieldNumber: 2)
    }
    if self.stationaryTaskPeriod != .mlxwakeperiod2Ms {
      try visitor.visitSingularEnumField(value: self.stationaryTaskPeriod, fieldNumber: 3)
    }
    if self.pressureMeasureMod != 0 {
      try visitor.visitSingularUInt32Field(value: self.pressureMeasureMod, fieldNumber: 4)
    }
    if self.accelMeasureMod != 0 {
      try visitor.visitSingularUInt32Field(value: self.accelMeasureMod, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TPStationaryConfig, rhs: TPStationaryConfig) -> Bool {
    if lhs.lowPressureThreshold != rhs.lowPressureThreshold {return false}
    if lhs.pressureDelta != rhs.pressureDelta {return false}
    if lhs.stationaryTaskPeriod != rhs.stationaryTaskPeriod {return false}
    if lhs.pressureMeasureMod != rhs.pressureMeasureMod {return false}
    if lhs.accelMeasureMod != rhs.accelMeasureMod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TPWheelUnitInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TPWheelUnitInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TIAppCRC"),
    2: .same(proto: "MLXAppCRC"),
    3: .standard(proto: "batteryVoltage_mV"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tiappCrc) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.mlxappCrc) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.batteryVoltageMV) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tiappCrc.isEmpty {
      try visitor.visitSingularBytesField(value: self.tiappCrc, fieldNumber: 1)
    }
    if !self.mlxappCrc.isEmpty {
      try visitor.visitSingularBytesField(value: self.mlxappCrc, fieldNumber: 2)
    }
    if self.batteryVoltageMV != 0 {
      try visitor.visitSingularUInt32Field(value: self.batteryVoltageMV, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TPWheelUnitInfo, rhs: TPWheelUnitInfo) -> Bool {
    if lhs.tiappCrc != rhs.tiappCrc {return false}
    if lhs.mlxappCrc != rhs.mlxappCrc {return false}
    if lhs.batteryVoltageMV != rhs.batteryVoltageMV {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UnknownKeyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UnknownKeyInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyStatus"),
    2: .same(proto: "publicKey"),
    3: .same(proto: "keyFormFactor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyStatus) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.keyFormFactor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.keyFormFactor != .unknown {
      try visitor.visitSingularEnumField(value: self.keyFormFactor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UnknownKeyInfo, rhs: UnknownKeyInfo) -> Bool {
    if lhs._keyStatus != rhs._keyStatus {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.keyFormFactor != rhs.keyFormFactor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UnsecureNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UnsecureNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notifyUser"),
    2: .same(proto: "closureStatuses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.notifyUser) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._closureStatuses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.notifyUser != false {
      try visitor.visitSingularBoolField(value: self.notifyUser, fieldNumber: 1)
    }
    try { if let v = self._closureStatuses {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UnsecureNotification, rhs: UnsecureNotification) -> Bool {
    if lhs.notifyUser != rhs.notifyUser {return false}
    if lhs._closureStatuses != rhs._closureStatuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UnsignedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UnsignedMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    25: .same(proto: "personalizationInformation"),
    1: .same(proto: "InformationRequest"),
    2: .same(proto: "RKEAction"),
    3: .same(proto: "authenticationResponse"),
    4: .same(proto: "closureMoveRequest"),
    5: .same(proto: "TPAdv"),
    16: .same(proto: "WhitelistOperation"),
    20: .same(proto: "updaterResponse"),
    21: .same(proto: "genealogyResponse"),
    22: .same(proto: "setMetaDataForKey"),
    23: .same(proto: "keyfobInfo"),
    24: .same(proto: "IMUState"),
    26: .same(proto: "nfcseState"),
    27: .same(proto: "lowPowerDeviceSleepManagerStats"),
    28: .same(proto: "TPData"),
    29: .same(proto: "TPWheelUnitInfo"),
    30: .same(proto: "resetTrackerStats"),
    31: .same(proto: "TPNotifyTrackerStats"),
    32: .same(proto: "TPNewSensorData"),
    33: .same(proto: "TPLRDetection"),
    34: .same(proto: "connectionMetrics"),
    35: .same(proto: "deviceActivity"),
    36: .same(proto: "getEpochSessionInfo"),
    37: .same(proto: "fromRCIResponse"),
    38: .same(proto: "BLEConfigAll"),
    39: .same(proto: "deviceMotion"),
    40: .same(proto: "appDeviceInfo"),
    41: .same(proto: "getReaderKey"),
    42: .same(proto: "MISessionResponse"),
    43: .same(proto: "MISessionStopped"),
    44: .same(proto: "accelData"),
    45: .same(proto: "TPMSAlarms"),
    46: .same(proto: "certificateResponse"),
    47: .same(proto: "challengeResponse"),
    48: .same(proto: "publicKeyResponse"),
    49: .same(proto: "ASICSPIRead"),
    50: .same(proto: "RFMonitorCounterResponse"),
    51: .same(proto: "BLENickName"),
    52: .same(proto: "TPConfiguration"),
    53: .same(proto: "TPCapabilities"),
    54: .same(proto: "appEventLog"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: InformationRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .informationRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .informationRequest(v)
        }
      }()
      case 2: try {
        var v: RKEAction_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .rkeaction(v)
        }
      }()
      case 3: try {
        var v: AuthenticationResponse?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .authenticationResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .authenticationResponse(v)
        }
      }()
      case 4: try {
        var v: ClosureMoveRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .closureMoveRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .closureMoveRequest(v)
        }
      }()
      case 5: try {
        var v: TPAdv?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tpadv(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpadv(v)
        }
      }()
      case 16: try {
        var v: WhitelistOperation?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .whitelistOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .whitelistOperation(v)
        }
      }()
      case 20: try {
        var v: UpdaterResponse?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .updaterResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .updaterResponse(v)
        }
      }()
      case 21: try {
        var v: GenealogyResponse?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .genealogyResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .genealogyResponse(v)
        }
      }()
      case 22: try {
        var v: KeyMetadata?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .setMetaDataForKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .setMetaDataForKey(v)
        }
      }()
      case 23: try {
        var v: KeyfobInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .keyfobInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .keyfobInfo(v)
        }
      }()
      case 24: try {
        var v: IMUState_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .imustate(v)
        }
      }()
      case 25: try { try decoder.decodeSingularMessageField(value: &self._personalizationInformation) }()
      case 26: try {
        var v: NFCSEState?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .nfcseState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .nfcseState(v)
        }
      }()
      case 27: try {
        var v: SleepManagerStats?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .lowPowerDeviceSleepManagerStats(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .lowPowerDeviceSleepManagerStats(v)
        }
      }()
      case 28: try {
        var v: TPData?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tpdata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpdata(v)
        }
      }()
      case 29: try {
        var v: TPWheelUnitInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tpwheelUnitInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpwheelUnitInfo(v)
        }
      }()
      case 30: try {
        var v: ResetTrackerStats?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .resetTrackerStats(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .resetTrackerStats(v)
        }
      }()
      case 31: try {
        var v: TPNotifyTrackerStats?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tpnotifyTrackerStats(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpnotifyTrackerStats(v)
        }
      }()
      case 32: try {
        var v: TPNewSensorData?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tpnewSensorData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpnewSensorData(v)
        }
      }()
      case 33: try {
        var v: TPLRDetection?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tplrdetection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tplrdetection(v)
        }
      }()
      case 34: try {
        var v: ConnectionMetrics?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .connectionMetrics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .connectionMetrics(v)
        }
      }()
      case 35: try {
        var v: Activity_E?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .deviceActivity(v)
        }
      }()
      case 36: try {
        var v: GetSessionInfoRequest?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .getEpochSessionInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .getEpochSessionInfo(v)
        }
      }()
      case 37: try {
        var v: FromRCI?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .fromRciresponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .fromRciresponse(v)
        }
      }()
      case 38: try {
        var v: BLEConfigAll?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .bleconfigAll(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .bleconfigAll(v)
        }
      }()
      case 39: try {
        var v: DeviceMotion?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .deviceMotion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .deviceMotion(v)
        }
      }()
      case 40: try {
        var v: AppDeviceInfo?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .appDeviceInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .appDeviceInfo(v)
        }
      }()
      case 41: try {
        var v: GetReaderKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .getReaderKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .getReaderKey(v)
        }
      }()
      case 42: try {
        var v: MISessionResponse?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .misessionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .misessionResponse(v)
        }
      }()
      case 43: try {
        var v: MISessionStopped?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .misessionStopped(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .misessionStopped(v)
        }
      }()
      case 44: try {
        var v: AccelData?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .accelData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .accelData(v)
        }
      }()
      case 45: try {
        var v: TPMSAlarms?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tpmsalarms(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpmsalarms(v)
        }
      }()
      case 46: try {
        var v: CertificateResponse?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .certificateResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .certificateResponse(v)
        }
      }()
      case 47: try {
        var v: ChallengeResponse?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .challengeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .challengeResponse(v)
        }
      }()
      case 48: try {
        var v: PublicKeyResponse?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .publicKeyResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .publicKeyResponse(v)
        }
      }()
      case 49: try {
        var v: ASICSPIRead?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .asicspiread(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .asicspiread(v)
        }
      }()
      case 50: try {
        var v: RFMonitorCounterResponse?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .rfmonitorCounterResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .rfmonitorCounterResponse(v)
        }
      }()
      case 51: try {
        var v: VehicleBLENickName?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .blenickName(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .blenickName(v)
        }
      }()
      case 52: try {
        var v: TPConfiguration?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tpconfiguration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpconfiguration(v)
        }
      }()
      case 53: try {
        var v: TPCapabilities?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .tpcapabilities(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .tpcapabilities(v)
        }
      }()
      case 54: try {
        var v: AppEventLog?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .appEventLog(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .appEventLog(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .informationRequest?: try {
      guard case .informationRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .rkeaction?: try {
      guard case .rkeaction(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .authenticationResponse?: try {
      guard case .authenticationResponse(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .closureMoveRequest?: try {
      guard case .closureMoveRequest(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .tpadv?: try {
      guard case .tpadv(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .whitelistOperation?: try {
      guard case .whitelistOperation(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .updaterResponse?: try {
      guard case .updaterResponse(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .genealogyResponse?: try {
      guard case .genealogyResponse(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .setMetaDataForKey?: try {
      guard case .setMetaDataForKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .keyfobInfo?: try {
      guard case .keyfobInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .imustate?: try {
      guard case .imustate(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 24)
    }()
    default: break
    }
    try { if let v = self._personalizationInformation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    } }()
    switch self.subMessage {
    case .nfcseState?: try {
      guard case .nfcseState(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .lowPowerDeviceSleepManagerStats?: try {
      guard case .lowPowerDeviceSleepManagerStats(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .tpdata?: try {
      guard case .tpdata(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .tpwheelUnitInfo?: try {
      guard case .tpwheelUnitInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .resetTrackerStats?: try {
      guard case .resetTrackerStats(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .tpnotifyTrackerStats?: try {
      guard case .tpnotifyTrackerStats(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .tpnewSensorData?: try {
      guard case .tpnewSensorData(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .tplrdetection?: try {
      guard case .tplrdetection(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .connectionMetrics?: try {
      guard case .connectionMetrics(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .deviceActivity?: try {
      guard case .deviceActivity(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 35)
    }()
    case .getEpochSessionInfo?: try {
      guard case .getEpochSessionInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .fromRciresponse?: try {
      guard case .fromRciresponse(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .bleconfigAll?: try {
      guard case .bleconfigAll(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .deviceMotion?: try {
      guard case .deviceMotion(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .appDeviceInfo?: try {
      guard case .appDeviceInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .getReaderKey?: try {
      guard case .getReaderKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .misessionResponse?: try {
      guard case .misessionResponse(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .misessionStopped?: try {
      guard case .misessionStopped(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .accelData?: try {
      guard case .accelData(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .tpmsalarms?: try {
      guard case .tpmsalarms(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .certificateResponse?: try {
      guard case .certificateResponse(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .challengeResponse?: try {
      guard case .challengeResponse(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .publicKeyResponse?: try {
      guard case .publicKeyResponse(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .asicspiread?: try {
      guard case .asicspiread(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .rfmonitorCounterResponse?: try {
      guard case .rfmonitorCounterResponse(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .blenickName?: try {
      guard case .blenickName(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .tpconfiguration?: try {
      guard case .tpconfiguration(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .tpcapabilities?: try {
      guard case .tpcapabilities(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case .appEventLog?: try {
      guard case .appEventLog(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UnsignedMessage, rhs: UnsignedMessage) -> Bool {
    if lhs._personalizationInformation != rhs._personalizationInformation {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdaterCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UpdaterCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "getCodeDescriptor"),
    2: .same(proto: "setUpdaterLocation"),
    3: .same(proto: "stageBlock"),
    4: .same(proto: "verifyAndInstallApp"),
    5: .same(proto: "firmwareInfo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: GetCodeDescriptor?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .getCodeDescriptor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .getCodeDescriptor(v)
        }
      }()
      case 2: try {
        var v: SetUpdaterLocation?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .setUpdaterLocation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .setUpdaterLocation(v)
        }
      }()
      case 3: try {
        var v: StageBlock?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .stageBlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .stageBlock(v)
        }
      }()
      case 4: try {
        var v: VerifyAndInstallApp?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .verifyAndInstallApp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .verifyAndInstallApp(v)
        }
      }()
      case 5: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .firmwareInfo(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .getCodeDescriptor?: try {
      guard case .getCodeDescriptor(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .setUpdaterLocation?: try {
      guard case .setUpdaterLocation(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .stageBlock?: try {
      guard case .stageBlock(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .verifyAndInstallApp?: try {
      guard case .verifyAndInstallApp(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .firmwareInfo?: try {
      guard case .firmwareInfo(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UpdaterCommand, rhs: UpdaterCommand) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdaterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UpdaterResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codeDescriptorMessage"),
    2: .same(proto: "updaterStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CodeDescriptor?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .codeDescriptorMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .codeDescriptorMessage(v)
        }
      }()
      case 2: try {
        var v: UpdaterStatus?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .updaterStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .updaterStatus(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .codeDescriptorMessage?: try {
      guard case .codeDescriptorMessage(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .updaterStatus?: try {
      guard case .updaterStatus(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UpdaterResponse, rhs: UpdaterResponse) -> Bool {
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdaterStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UpdaterStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "statusCode"),
    2: .same(proto: "location"),
    3: .same(proto: "nextAddressNumber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.statusCode) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.location) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.nextAddressNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.statusCode != .error {
      try visitor.visitSingularEnumField(value: self.statusCode, fieldNumber: 1)
    }
    if self.location != .none {
      try visitor.visitSingularEnumField(value: self.location, fieldNumber: 2)
    }
    if self.nextAddressNumber != 0 {
      try visitor.visitSingularUInt32Field(value: self.nextAddressNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UpdaterStatus, rhs: UpdaterStatus) -> Bool {
    if lhs.statusCode != rhs.statusCode {return false}
    if lhs.location != rhs.location {return false}
    if lhs.nextAddressNumber != rhs.nextAddressNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleBLENickName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleBLENickName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nickName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nickName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nickName.isEmpty {
      try visitor.visitSingularBytesField(value: self.nickName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleBLENickName, rhs: VehicleBLENickName) -> Bool {
    if lhs.nickName != rhs.nickName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VIN"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vin.isEmpty {
      try visitor.visitSingularStringField(value: self.vin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleInfo, rhs: VehicleInfo) -> Bool {
    if lhs.vin != rhs.vin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VehicleStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VehicleStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "closureStatuses"),
    2: .same(proto: "vehicleLockState"),
    3: .same(proto: "vehicleSleepStatus"),
    4: .same(proto: "userPresence"),
    5: .same(proto: "detailedClosureStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._closureStatuses) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.vehicleLockState) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.vehicleSleepStatus) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.userPresence) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._detailedClosureStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._closureStatuses {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.vehicleLockState != .vehiclelockstateUnlocked {
      try visitor.visitSingularEnumField(value: self.vehicleLockState, fieldNumber: 2)
    }
    if self.vehicleSleepStatus != .vehicleSleepStatusUnknown {
      try visitor.visitSingularEnumField(value: self.vehicleSleepStatus, fieldNumber: 3)
    }
    if self.userPresence != .vehicleUserPresenceUnknown {
      try visitor.visitSingularEnumField(value: self.userPresence, fieldNumber: 4)
    }
    try { if let v = self._detailedClosureStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VehicleStatus, rhs: VehicleStatus) -> Bool {
    if lhs._closureStatuses != rhs._closureStatuses {return false}
    if lhs.vehicleLockState != rhs.vehicleLockState {return false}
    if lhs.vehicleSleepStatus != rhs.vehicleSleepStatus {return false}
    if lhs.userPresence != rhs.userPresence {return false}
    if lhs._detailedClosureStatus != rhs._detailedClosureStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VerifyAndInstallApp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VerifyAndInstallApp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sha256"),
    2: .same(proto: "rValue"),
    3: .same(proto: "sValue"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sha256) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rValue) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.sValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sha256.isEmpty {
      try visitor.visitSingularBytesField(value: self.sha256, fieldNumber: 1)
    }
    if !self.rValue.isEmpty {
      try visitor.visitSingularBytesField(value: self.rValue, fieldNumber: 2)
    }
    if !self.sValue.isEmpty {
      try visitor.visitSingularBytesField(value: self.sValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VerifyAndInstallApp, rhs: VerifyAndInstallApp) -> Bool {
    if lhs.sha256 != rhs.sha256 {return false}
    if lhs.rValue != rhs.rValue {return false}
    if lhs.sValue != rhs.sValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WhitelistEntryInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "WhitelistEntryInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keyId"),
    2: .same(proto: "publicKey"),
    3: .same(proto: "permissions"),
    4: .same(proto: "metadataForKey"),
    5: .same(proto: "secondsEntryRemainsActive"),
    6: .same(proto: "slot"),
    7: .same(proto: "keyRole"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.permissions) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadataForKey) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.secondsEntryRemainsActive) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.slot) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.keyRole) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.permissions.isEmpty {
      try visitor.visitPackedEnumField(value: self.permissions, fieldNumber: 3)
    }
    try { if let v = self._metadataForKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.secondsEntryRemainsActive != 0 {
      try visitor.visitSingularUInt32Field(value: self.secondsEntryRemainsActive, fieldNumber: 5)
    }
    if self.slot != 0 {
      try visitor.visitSingularUInt32Field(value: self.slot, fieldNumber: 6)
    }
    if self.keyRole != .none {
      try visitor.visitSingularEnumField(value: self.keyRole, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: WhitelistEntryInfo, rhs: WhitelistEntryInfo) -> Bool {
    if lhs._keyID != rhs._keyID {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs._metadataForKey != rhs._metadataForKey {return false}
    if lhs.secondsEntryRemainsActive != rhs.secondsEntryRemainsActive {return false}
    if lhs.slot != rhs.slot {return false}
    if lhs.keyRole != rhs.keyRole {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WhitelistInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "WhitelistInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numberOfEntries"),
    2: .same(proto: "whitelistEntries"),
    3: .same(proto: "slotMask"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.numberOfEntries) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.whitelistEntries) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.slotMask) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numberOfEntries != 0 {
      try visitor.visitSingularUInt32Field(value: self.numberOfEntries, fieldNumber: 1)
    }
    if !self.whitelistEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.whitelistEntries, fieldNumber: 2)
    }
    if self.slotMask != 0 {
      try visitor.visitSingularUInt32Field(value: self.slotMask, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: WhitelistInfo, rhs: WhitelistInfo) -> Bool {
    if lhs.numberOfEntries != rhs.numberOfEntries {return false}
    if lhs.whitelistEntries != rhs.whitelistEntries {return false}
    if lhs.slotMask != rhs.slotMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WhitelistOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "WhitelistOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "metadataForKey"),
    1: .same(proto: "addPublicKeyToWhitelist"),
    2: .same(proto: "removePublicKeyFromWhitelist"),
    3: .same(proto: "addPermissionsToPublicKey"),
    4: .same(proto: "removePermissionsFromPublicKey"),
    5: .same(proto: "addKeyToWhitelistAndAddPermissions"),
    7: .same(proto: "updateKeyAndPermissions"),
    8: .same(proto: "addImpermanentKey"),
    9: .same(proto: "addImpermanentKeyAndRemoveExisting"),
    16: .same(proto: "removeAllImpermanentKeys"),
    17: .same(proto: "replaceKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PublicKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addPublicKeyToWhitelist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addPublicKeyToWhitelist(v)
        }
      }()
      case 2: try {
        var v: PublicKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .removePublicKeyFromWhitelist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .removePublicKeyFromWhitelist(v)
        }
      }()
      case 3: try {
        var v: PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addPermissionsToPublicKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addPermissionsToPublicKey(v)
        }
      }()
      case 4: try {
        var v: PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .removePermissionsFromPublicKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .removePermissionsFromPublicKey(v)
        }
      }()
      case 5: try {
        var v: PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addKeyToWhitelistAndAddPermissions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addKeyToWhitelistAndAddPermissions(v)
        }
      }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._metadataForKey) }()
      case 7: try {
        var v: PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .updateKeyAndPermissions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .updateKeyAndPermissions(v)
        }
      }()
      case 8: try {
        var v: PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addImpermanentKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addImpermanentKey(v)
        }
      }()
      case 9: try {
        var v: PermissionChange?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .addImpermanentKeyAndRemoveExisting(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .addImpermanentKeyAndRemoveExisting(v)
        }
      }()
      case 16: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.subMessage != nil {try decoder.handleConflictingOneOf()}
          self.subMessage = .removeAllImpermanentKeys(v)
        }
      }()
      case 17: try {
        var v: ReplaceKey?
        var hadOneofValue = false
        if let current = self.subMessage {
          hadOneofValue = true
          if case .replaceKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.subMessage = .replaceKey(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.subMessage {
    case .addPublicKeyToWhitelist?: try {
      guard case .addPublicKeyToWhitelist(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .removePublicKeyFromWhitelist?: try {
      guard case .removePublicKeyFromWhitelist(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .addPermissionsToPublicKey?: try {
      guard case .addPermissionsToPublicKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .removePermissionsFromPublicKey?: try {
      guard case .removePermissionsFromPublicKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .addKeyToWhitelistAndAddPermissions?: try {
      guard case .addKeyToWhitelistAndAddPermissions(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    default: break
    }
    try { if let v = self._metadataForKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    switch self.subMessage {
    case .updateKeyAndPermissions?: try {
      guard case .updateKeyAndPermissions(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .addImpermanentKey?: try {
      guard case .addImpermanentKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .addImpermanentKeyAndRemoveExisting?: try {
      guard case .addImpermanentKeyAndRemoveExisting(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .removeAllImpermanentKeys?: try {
      guard case .removeAllImpermanentKeys(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
    }()
    case .replaceKey?: try {
      guard case .replaceKey(let v)? = self.subMessage else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: WhitelistOperation, rhs: WhitelistOperation) -> Bool {
    if lhs._metadataForKey != rhs._metadataForKey {return false}
    if lhs.subMessage != rhs.subMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WhitelistOperation_status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "WhitelistOperation_status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "whitelistOperationInformation"),
    2: .same(proto: "signerOfOperation"),
    3: .same(proto: "operationStatus"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.whitelistOperationInformation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signerOfOperation) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.operationStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.whitelistOperationInformation != .whitelistoperationInformationNone {
      try visitor.visitSingularEnumField(value: self.whitelistOperationInformation, fieldNumber: 1)
    }
    try { if let v = self._signerOfOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.operationStatus != .operationstatusOk {
      try visitor.visitSingularEnumField(value: self.operationStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: WhitelistOperation_status, rhs: WhitelistOperation_status) -> Bool {
    if lhs.whitelistOperationInformation != rhs.whitelistOperationInformation {return false}
    if lhs._signerOfOperation != rhs._signerOfOperation {return false}
    if lhs.operationStatus != rhs.operationStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
